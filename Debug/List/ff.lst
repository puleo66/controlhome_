###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       04/Oct/2017  15:38:50
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  E:\HW Projects\ControlHome\CntrHome - RF69w\uC-FatFS\ff.c
#    Command line =  
#        "E:\HW Projects\ControlHome\CntrHome - RF69w\uC-FatFS\ff.c" -lCN
#        "E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\List" -o "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Debug\Obj" --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\APP\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\BSP\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\CPU\inc\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-CPU\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-RTC\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-LIB\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uCOS-II\Ports\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uCOS-II\Source\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\I2C-Out\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Direct_Sw\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Wdt_led\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-LCD\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-RF\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\" -Oh
#    List file    =  
#        E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\List\ff.lst
#    Object file  =  E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\Obj\ff.o
#
###############################################################################

E:\HW Projects\ControlHome\CntrHome - RF69w\uC-FatFS\ff.c
      1              /*----------------------------------------------------------------------------/  
      2              /  FatFs - FAT file system module  R0.06                     (C)ChaN, 2008  
      3              /-----------------------------------------------------------------------------/  
      4              / The FatFs module is an experimenal project to implement FAT file system to  
      5              / cheap microcontrollers. This is a free software and is opened for education,  
      6              / research and development under license policy of following trems.  
      7              /  
      8              /  Copyright (C) 2008, ChaN, all right reserved.  
      9              /  
     10              / * The FatFs module is a free software and there is no warranty.  
     11              / * You can use, modify and/or redistribute it for personal, non-profit or  
     12              /   commercial use without restriction under your responsibility.  
     13              / * Redistributions of source code must retain the above copyright notice.  
     14              /  
     15              /-----------------------------------------------------------------------------/  
     16              / Feb 26,'06 R0.00  Prototype.  
     17              /  
     18              / Apr 29,'06 R0.01  First stable version.  
     19              /  
     20              / Jun 01,'06 R0.02  Added FAT12 support.  
     21              /                   Removed unbuffered mode.  
     22              /                   Fixed a problem on small (<32M) patition.  
     23              / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).  
     24              /  
     25              / Sep 22,'06 R0.03  Added f_rename().  
     26              /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.  
     27              / Dec 11,'06 R0.03a Improved cluster scan algolithm to write files fast.  
     28              /                   Fixed f_mkdir() creates incorrect directory on FAT32.  
     29              /  
     30              / Feb 04,'07 R0.04  Supported multiple drive system.  
     31              /                   Changed some interfaces for multiple drive system.  
     32              /                   Changed f_mountdrv() to f_mount().  
     33              /                   Added f_mkfs().  
     34              / Apr 01,'07 R0.04a Supported multiple partitions on a plysical drive.  
     35              /                   Added a capability of extending file size to f_lseek().  
     36              /                   Added minimization level 3.  
     37              /                   Fixed an endian sensitive code in f_mkfs().  
     38              / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.  
     39              /                   Added FSInfo support.  
     40              /                   Fixed DBCS name can result FR_INVALID_NAME.  
     41              /                   Fixed short seek (<= csize) collapses the file object.  
     42              /  
     43              / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().  
     44              /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.  
     45              /                   Fixed f_mkdir() on FAT32 creates incorrect directory.  
     46              / Feb 03,'08 R0.05a Added f_truncate() and f_utime().  
     47              /                   Fixed off by one error at FAT sub-type determination.  
     48              /                   Fixed btr in f_read() can be mistruncated.  
     49              /                   Fixed cached sector is not flushed when create and close  
     50              /                   without write.  
     51              /  
     52              / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().  
     53              /                   Improved performance of f_lseek() on moving to the same  
     54              /                   or following cluster.  
     55              /---------------------------------------------------------------------------*/   
     56                 
     57              #include <string.h>   
     58              #include "ff.h"         /* FatFs declarations */   
     59              #include "diskio.h"     /* Include file for user provided disk functions */   
     60                 
     61              /*--------------------------------------------------------------------------  
     62                
     63                 Module Private Functions  
     64                
     65              ---------------------------------------------------------------------------*/   
     66                 
     67              static   

   \                                 In section .bss, align 4
     68              FATFS *FatFs[_DRIVES];  /* Pointer to the file system objects (logical drives) */   
     69              static   
     70              WORD fsid;              /* File system mount ID */   
   \                     fsid:
   \   00000000                      DS8 2
   \   00000002                      DS8 2
   \   00000004                      DS8 4
     71                 
     72                 
     73                 
     74              /*-----------------------------------------------------------------------*/   
     75              /* Change window offset                                                  */   
     76              /*-----------------------------------------------------------------------*/   
     77                 

   \                                 In section .text, align 2, keep-with-next
     78              static   
     79              BOOL move_window (  /* TRUE: successful, FALSE: failed */   
     80                  FATFS *fs,      /* File system object */   
     81                  DWORD sector    /* Sector number to make apperance in the fs->win[] */   
     82              )                   /* Move to zero only writes back dirty window */   
     83              {   
   \                     move_window: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4680             MOV      R8,R0
     84                  DWORD wsect;   
     85                 
     86                 
     87                  wsect = fs->winsect;   
   \   00000006   0xF108 0x0604      ADD      R6,R8,#+4
   \   0000000A   0x460D             MOV      R5,R1
   \   0000000C   0xF8D6 0x9000      LDR      R9,[R6, #+0]
     88                  if (wsect != sector) {  /* Changed current window */   
   \   00000010   0x45A9             CMP      R9,R5
   \   00000012   0xD02B             BEQ.N    ??move_window_0
     89              #if !_FS_READONLY   
     90                      BYTE n;   
     91                      if (fs->winflag) {   /* Write back dirty window if needed */   
   \   00000014   0xF108 0x042C      ADD      R4,R8,#+44
   \   00000018   0x78A0             LDRB     R0,[R4, #+2]
   \   0000001A   0xB1E0             CBZ.N    R0,??move_window_1
     92                          if (disk_write(fs->drive, fs->win, wsect, 1) != RES_OK)   
   \   0000001C   0x7860             LDRB     R0,[R4, #+1]
   \   0000001E   0x2301             MOVS     R3,#+1
   \   00000020   0x464A             MOV      R2,R9
   \   00000022   0xF108 0x0130      ADD      R1,R8,#+48
   \   00000026   0x.... 0x....      BL       disk_write
   \   0000002A   0xB9E8             CBNZ.N   R0,??move_window_2
     93                              return FALSE;   
     94                          fs->winflag = 0;   
   \   0000002C   0x70A0             STRB     R0,[R4, #+2]
     95                          if (wsect < (fs->fatbase + fs->sects_fat)) {   /* In FAT area */   
   \   0000002E   0x6871             LDR      R1,[R6, #+4]
   \   00000030   0x68F0             LDR      R0,[R6, #+12]
   \   00000032   0x1808             ADDS     R0,R1,R0
   \   00000034   0x4581             CMP      R9,R0
   \   00000036   0xD20E             BCS.N    ??move_window_1
   \   00000038   0x7820             LDRB     R0,[R4, #+0]
   \   0000003A   0x2802             CMP      R0,#+2
   \   0000003C   0xDB0B             BLT.N    ??move_window_1
   \   0000003E   0x1E47             SUBS     R7,R0,#+1
     96                              for (n = fs->n_fats; n >= 2; n--) {   /* Refrect the change to FAT copy */   
     97                                  wsect += fs->sects_fat;   
   \                     ??move_window_3: (+1)
   \   00000040   0x6870             LDR      R0,[R6, #+4]
   \   00000042   0x4481             ADD      R9,R0,R9
     98                                  disk_write(fs->drive, fs->win, wsect, 1);   
   \   00000044   0x7860             LDRB     R0,[R4, #+1]
   \   00000046   0x2301             MOVS     R3,#+1
   \   00000048   0x464A             MOV      R2,R9
   \   0000004A   0xF108 0x0130      ADD      R1,R8,#+48
   \   0000004E   0x.... 0x....      BL       disk_write
     99                              }   
   \   00000052   0x1E7F             SUBS     R7,R7,#+1
   \   00000054   0xD1F4             BNE.N    ??move_window_3
    100                          }   
    101                      }   
    102              #endif   
    103                      if (sector) {   
   \                     ??move_window_1: (+1)
   \   00000056   0xB14D             CBZ.N    R5,??move_window_0
    104                          if (disk_read(fs->drive, fs->win, sector, 1) != RES_OK)   
   \   00000058   0x7860             LDRB     R0,[R4, #+1]
   \   0000005A   0x2301             MOVS     R3,#+1
   \   0000005C   0x462A             MOV      R2,R5
   \   0000005E   0xF108 0x0130      ADD      R1,R8,#+48
   \   00000062   0x.... 0x....      BL       disk_read
   \   00000066   0xB100             CBZ.N    R0,??move_window_4
    105                              return FALSE;   
   \                     ??move_window_2: (+1)
   \   00000068   0x....             B.N      ?Subroutine1
    106                          fs->winsect = sector;   
   \                     ??move_window_4: (+1)
   \   0000006A   0x6035             STR      R5,[R6, #+0]
    107                      }   
    108                  }   
    109                  return TRUE;   
   \                     ??move_window_0: (+1)
   \   0000006C   0x....             B.N      ?Subroutine0
    110              }   

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    111                 
    112                 
    113                 
    114                 
    115              /*-----------------------------------------------------------------------*/   
    116              /* Clean-up cached data                                                  */   
    117              /*-----------------------------------------------------------------------*/   
    118                 
    119              #if !_FS_READONLY   

   \                                 In section .text, align 2, keep-with-next
    120              static   
    121              FRESULT sync (  /* FR_OK: successful, FR_RW_ERROR: failed */   
    122                  FATFS *fs   /* File system object */   
    123              )   
    124              {   
   \                     sync: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4680             MOV      R8,R0
    125                  fs->winflag = 1;   
   \   00000006   0xF108 0x0528      ADD      R5,R8,#+40
   \   0000000A   0x2001             MOVS     R0,#+1
    126                  if (!move_window(fs, 0)) return FR_RW_ERROR;   
   \   0000000C   0xF108 0x0604      ADD      R6,R8,#+4
   \   00000010   0x71A8             STRB     R0,[R5, #+6]
   \   00000012   0x6837             LDR      R7,[R6, #+0]
   \   00000014   0xB1EF             CBZ.N    R7,??sync_0
   \   00000016   0x7968             LDRB     R0,[R5, #+5]
   \   00000018   0x2301             MOVS     R3,#+1
   \   0000001A   0x463A             MOV      R2,R7
   \   0000001C   0xF108 0x0130      ADD      R1,R8,#+48
   \   00000020   0x.... 0x....      BL       disk_write
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD13F             BNE.N    ??sync_1
   \   00000028   0x71A8             STRB     R0,[R5, #+6]
   \   0000002A   0x6871             LDR      R1,[R6, #+4]
   \   0000002C   0x68F0             LDR      R0,[R6, #+12]
   \   0000002E   0x1808             ADDS     R0,R1,R0
   \   00000030   0x4287             CMP      R7,R0
   \   00000032   0xD20E             BCS.N    ??sync_0
   \   00000034   0x7928             LDRB     R0,[R5, #+4]
   \   00000036   0x2802             CMP      R0,#+2
   \   00000038   0xDB0B             BLT.N    ??sync_0
   \   0000003A   0x1E44             SUBS     R4,R0,#+1
   \                     ??sync_2: (+1)
   \   0000003C   0x6870             LDR      R0,[R6, #+4]
   \   0000003E   0x19C7             ADDS     R7,R0,R7
   \   00000040   0x7968             LDRB     R0,[R5, #+5]
   \   00000042   0x2301             MOVS     R3,#+1
   \   00000044   0x463A             MOV      R2,R7
   \   00000046   0xF108 0x0130      ADD      R1,R8,#+48
   \   0000004A   0x.... 0x....      BL       disk_write
   \   0000004E   0x1E64             SUBS     R4,R4,#+1
   \   00000050   0xD1F4             BNE.N    ??sync_2
    127              #if _USE_FSINFO   
    128                  /* Update FSInfo sector if needed */   
    129                  if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {   
   \                     ??sync_0: (+1)
   \   00000052   0x78A8             LDRB     R0,[R5, #+2]
   \   00000054   0x2803             CMP      R0,#+3
   \   00000056   0xD121             BNE.N    ??sync_3
   \   00000058   0x7828             LDRB     R0,[R5, #+0]
   \   0000005A   0xB1F8             CBZ.N    R0,??sync_3
    130                      fs->winsect = 0;   
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x6030             STR      R0,[R6, #+0]
    131                      memset(fs->win, 0, 512);   
   \   00000060   0xF44F 0x7100      MOV      R1,#+512
   \   00000064   0xF108 0x0030      ADD      R0,R8,#+48
   \   00000068   0x.... 0x....      BL       __aeabi_memclr4
    132                      ST_WORD(&fs->win[BS_55AA], 0xAA55);   
   \   0000006C   0xF508 0x7005      ADD      R0,R8,#+532
   \   00000070   0xF64A 0x2155      MOVW     R1,#+43605
   \   00000074   0x8341             STRH     R1,[R0, #+26]
    133                      ST_DWORD(&fs->win[FSI_LeadSig], 0x41615252);   
    134                      ST_DWORD(&fs->win[FSI_StrucSig], 0x61417272);   
    135                      ST_DWORD(&fs->win[FSI_Free_Count], fs->free_clust);   
    136                      ST_DWORD(&fs->win[FSI_Nxt_Free], fs->last_clust);   
    137                      disk_write(fs->drive, fs->win, fs->fsi_sector, 1);   
   \   00000076   0x2301             MOVS     R3,#+1
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable7  ;; 0x41615252
   \   0000007C   0x60A9             STR      R1,[R5, #+8]
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable7_2  ;; 0x61417272
   \   00000082   0x6001             STR      R1,[R0, #+0]
   \   00000084   0x69F1             LDR      R1,[R6, #+28]
   \   00000086   0x6041             STR      R1,[R0, #+4]
   \   00000088   0x69B1             LDR      R1,[R6, #+24]
   \   0000008A   0x6081             STR      R1,[R0, #+8]
   \   0000008C   0x6A32             LDR      R2,[R6, #+32]
   \   0000008E   0x7968             LDRB     R0,[R5, #+5]
   \   00000090   0xF108 0x0130      ADD      R1,R8,#+48
   \   00000094   0x.... 0x....      BL       disk_write
    138                      fs->fsi_flag = 0;   
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x7028             STRB     R0,[R5, #+0]
    139                  }   
    140              #endif   
    141                  /* Make sure that no pending write process in the physical drive */   
    142                  if (disk_ioctl(fs->drive, CTRL_SYNC, NULL) != RES_OK)   
   \                     ??sync_3: (+1)
   \   0000009C   0x2200             MOVS     R2,#+0
   \   0000009E   0x7968             LDRB     R0,[R5, #+5]
   \   000000A0   0x2100             MOVS     R1,#+0
   \   000000A2   0x.... 0x....      BL       disk_ioctl
   \   000000A6   0xB100             CBZ.N    R0,??sync_4
   \                     ??sync_1: (+1)
   \   000000A8   0x2008             MOVS     R0,#+8
    143                      return FR_RW_ERROR;   
    144                  return FR_OK;   
   \                     ??sync_4: (+1)
   \   000000AA   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    145              }   
    146              #endif   
    147                 
    148                 
    149                 
    150                 
    151              /*-----------------------------------------------------------------------*/   
    152              /* Get a cluster status                                                  */   
    153              /*-----------------------------------------------------------------------*/   
    154                 

   \                                 In section .text, align 2, keep-with-next
    155              static   
    156              DWORD get_cluster ( /* 0,>=2: successful, 1: failed */   
    157                  FATFS *fs,      /* File system object */   
    158                  DWORD clust     /* Cluster# to get the link information */   
    159              )   
    160              {   
   \                     get_cluster: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x468A             MOV      R10,R1
    161                  WORD wc, bc;   
    162                  DWORD fatsect;   
    163                 
    164                 
    165                  if (clust >= 2 && clust < fs->max_clust) {     /* Is it a valid cluster#? */   
   \   00000006   0xF1BA 0x0F02      CMP      R10,#+2
   \   0000000A   0x4680             MOV      R8,R0
   \   0000000C   0xF0C0 0x8114      BCC.W    ??get_cluster_0
   \   00000010   0xF108 0x0604      ADD      R6,R8,#+4
   \   00000014   0x68B0             LDR      R0,[R6, #+8]
   \   00000016   0x4582             CMP      R10,R0
   \   00000018   0xF080 0x810E      BCS.W    ??get_cluster_0
    166                      fatsect = fs->fatbase;   
    167                      switch (fs->fs_type) {   
   \   0000001C   0xF108 0x072A      ADD      R7,R8,#+42
   \   00000020   0x7838             LDRB     R0,[R7, #+0]
   \   00000022   0xF8D6 0x900C      LDR      R9,[R6, #+12]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD007             BEQ.N    ??get_cluster_1
   \   0000002A   0xF0C0 0x8105      BCC.W    ??get_cluster_0
   \   0000002E   0x2803             CMP      R0,#+3
   \   00000030   0xF000 0x80C9      BEQ.W    ??get_cluster_2
   \   00000034   0xF0C0 0x808E      BCC.W    ??get_cluster_3
   \   00000038   0xE0FE             B.N      ??get_cluster_0
    168                      case FS_FAT12 :   
    169                          bc = (WORD)clust * 3 / 2;   
   \                     ??get_cluster_1: (+1)
   \   0000003A   0xFA1F 0xF08A      UXTH     R0,R10
   \   0000003E   0xEB00 0x0040      ADD      R0,R0,R0, LSL #+1
   \   00000042   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   00000046   0x03C4             LSLS     R4,R0,#+15
   \   00000048   0x0C24             LSRS     R4,R4,#+16
    170                          if (!move_window(fs, fatsect + (bc / SS(fs)))) break;   
   \   0000004A   0xEB09 0x2054      ADD      R0,R9,R4, LSR #+9
   \   0000004E   0x9000             STR      R0,[SP, #+0]
   \   00000050   0x6835             LDR      R5,[R6, #+0]
   \   00000052   0x4285             CMP      R5,R0
   \   00000054   0xD030             BEQ.N    ??get_cluster_4
   \   00000056   0x7938             LDRB     R0,[R7, #+4]
   \   00000058   0xB300             CBZ.N    R0,??get_cluster_5
   \   0000005A   0x78F8             LDRB     R0,[R7, #+3]
   \   0000005C   0x2301             MOVS     R3,#+1
   \   0000005E   0x462A             MOV      R2,R5
   \   00000060   0xF108 0x0130      ADD      R1,R8,#+48
   \   00000064   0x.... 0x....      BL       disk_write
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xF040 0x80E5      BNE.W    ??get_cluster_0
   \   0000006E   0x7138             STRB     R0,[R7, #+4]
   \   00000070   0x6871             LDR      R1,[R6, #+4]
   \   00000072   0x68F0             LDR      R0,[R6, #+12]
   \   00000074   0x1808             ADDS     R0,R1,R0
   \   00000076   0x4285             CMP      R5,R0
   \   00000078   0xD210             BCS.N    ??get_cluster_5
   \   0000007A   0x78B8             LDRB     R0,[R7, #+2]
   \   0000007C   0x2802             CMP      R0,#+2
   \   0000007E   0xDB0D             BLT.N    ??get_cluster_5
   \   00000080   0xF1A0 0x0B01      SUB      R11,R0,#+1
   \                     ??get_cluster_6: (+1)
   \   00000084   0x6870             LDR      R0,[R6, #+4]
   \   00000086   0x1945             ADDS     R5,R0,R5
   \   00000088   0x78F8             LDRB     R0,[R7, #+3]
   \   0000008A   0x2301             MOVS     R3,#+1
   \   0000008C   0x462A             MOV      R2,R5
   \   0000008E   0xF108 0x0130      ADD      R1,R8,#+48
   \   00000092   0x.... 0x....      BL       disk_write
   \   00000096   0xF1BB 0x0B01      SUBS     R11,R11,#+1
   \   0000009A   0xD1F3             BNE.N    ??get_cluster_6
   \                     ??get_cluster_5: (+1)
   \   0000009C   0x9800             LDR      R0,[SP, #+0]
   \   0000009E   0xB158             CBZ.N    R0,??get_cluster_4
   \   000000A0   0x4602             MOV      R2,R0
   \   000000A2   0x78F8             LDRB     R0,[R7, #+3]
   \   000000A4   0x2301             MOVS     R3,#+1
   \   000000A6   0xF108 0x0130      ADD      R1,R8,#+48
   \   000000AA   0x.... 0x....      BL       disk_read
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xF040 0x80C2      BNE.W    ??get_cluster_0
   \   000000B4   0x9800             LDR      R0,[SP, #+0]
   \   000000B6   0x6030             STR      R0,[R6, #+0]
    171                          wc = fs->win[bc & (SS(fs) - 1)]; bc++;   
   \                     ??get_cluster_4: (+1)
   \   000000B8   0x05E0             LSLS     R0,R4,#+23
   \   000000BA   0xEB08 0x50D0      ADD      R0,R8,R0, LSR #+23
   \   000000BE   0x1C64             ADDS     R4,R4,#+1
   \   000000C0   0xF890 0x5030      LDRB     R5,[R0, #+48]
   \   000000C4   0xB2A4             UXTH     R4,R4
    172                          if (!move_window(fs, fatsect + (bc / SS(fs)))) break;   
   \   000000C6   0xEB09 0x2054      ADD      R0,R9,R4, LSR #+9
   \   000000CA   0x9000             STR      R0,[SP, #+0]
   \   000000CC   0xF8D6 0x9000      LDR      R9,[R6, #+0]
   \   000000D0   0x4581             CMP      R9,R0
   \   000000D2   0xD030             BEQ.N    ??get_cluster_7
   \   000000D4   0x7938             LDRB     R0,[R7, #+4]
   \   000000D6   0xB300             CBZ.N    R0,??get_cluster_8
   \   000000D8   0x78F8             LDRB     R0,[R7, #+3]
   \   000000DA   0x2301             MOVS     R3,#+1
   \   000000DC   0x464A             MOV      R2,R9
   \   000000DE   0xF108 0x0130      ADD      R1,R8,#+48
   \   000000E2   0x.... 0x....      BL       disk_write
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xF040 0x80A6      BNE.W    ??get_cluster_0
   \   000000EC   0x7138             STRB     R0,[R7, #+4]
   \   000000EE   0x6871             LDR      R1,[R6, #+4]
   \   000000F0   0x68F0             LDR      R0,[R6, #+12]
   \   000000F2   0x1808             ADDS     R0,R1,R0
   \   000000F4   0x4581             CMP      R9,R0
   \   000000F6   0xD210             BCS.N    ??get_cluster_8
   \   000000F8   0x78B8             LDRB     R0,[R7, #+2]
   \   000000FA   0x2802             CMP      R0,#+2
   \   000000FC   0xDB0D             BLT.N    ??get_cluster_8
   \   000000FE   0xF1A0 0x0B01      SUB      R11,R0,#+1
   \                     ??get_cluster_9: (+1)
   \   00000102   0x6870             LDR      R0,[R6, #+4]
   \   00000104   0x4481             ADD      R9,R0,R9
   \   00000106   0x78F8             LDRB     R0,[R7, #+3]
   \   00000108   0x2301             MOVS     R3,#+1
   \   0000010A   0x464A             MOV      R2,R9
   \   0000010C   0xF108 0x0130      ADD      R1,R8,#+48
   \   00000110   0x.... 0x....      BL       disk_write
   \   00000114   0xF1BB 0x0B01      SUBS     R11,R11,#+1
   \   00000118   0xD1F3             BNE.N    ??get_cluster_9
   \                     ??get_cluster_8: (+1)
   \   0000011A   0x9800             LDR      R0,[SP, #+0]
   \   0000011C   0xB158             CBZ.N    R0,??get_cluster_7
   \   0000011E   0x4602             MOV      R2,R0
   \   00000120   0x78F8             LDRB     R0,[R7, #+3]
   \   00000122   0x2301             MOVS     R3,#+1
   \   00000124   0xF108 0x0130      ADD      R1,R8,#+48
   \   00000128   0x.... 0x....      BL       disk_read
   \   0000012C   0x2800             CMP      R0,#+0
   \   0000012E   0xF040 0x8083      BNE.W    ??get_cluster_0
   \   00000132   0x9800             LDR      R0,[SP, #+0]
   \   00000134   0x6030             STR      R0,[R6, #+0]
    173                          wc |= (WORD)fs->win[bc & (SS(fs) - 1)] << 8;   
   \                     ??get_cluster_7: (+1)
   \   00000136   0x05E0             LSLS     R0,R4,#+23
   \   00000138   0xEB08 0x50D0      ADD      R0,R8,R0, LSR #+23
   \   0000013C   0xF890 0x0030      LDRB     R0,[R0, #+48]
   \   00000140   0xEA45 0x2500      ORR      R5,R5,R0, LSL #+8
    174                          return (clust & 1) ? (wc >> 4) : (wc & 0xFFF);   
   \   00000144   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   00000148   0xBF5A             ITTE     PL 
   \   0000014A   0x0528             LSLPL    R0,R5,#+20
   \   0000014C   0x0D00             LSRPL    R0,R0,#+20
   \   0000014E   0x0928             LSRMI    R0,R5,#+4
   \   00000150   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    175                 
    176                      case FS_FAT16 :   
    177                          if (!move_window(fs, fatsect + (clust / (SS(fs) / 2)))) break;   
   \                     ??get_cluster_3: (+1)
   \   00000154   0xEB09 0x241A      ADD      R4,R9,R10, LSR #+8
   \   00000158   0xF8D6 0x9000      LDR      R9,[R6, #+0]
   \   0000015C   0x45A1             CMP      R9,R4
   \   0000015E   0xD02A             BEQ.N    ??get_cluster_10
   \   00000160   0x7938             LDRB     R0,[R7, #+4]
   \   00000162   0xB1E8             CBZ.N    R0,??get_cluster_11
   \   00000164   0x78F8             LDRB     R0,[R7, #+3]
   \   00000166   0x2301             MOVS     R3,#+1
   \   00000168   0x464A             MOV      R2,R9
   \   0000016A   0xF108 0x0130      ADD      R1,R8,#+48
   \   0000016E   0x.... 0x....      BL       disk_write
   \   00000172   0x2800             CMP      R0,#+0
   \   00000174   0xD160             BNE.N    ??get_cluster_0
   \   00000176   0x7138             STRB     R0,[R7, #+4]
   \   00000178   0x6871             LDR      R1,[R6, #+4]
   \   0000017A   0x68F0             LDR      R0,[R6, #+12]
   \   0000017C   0x1808             ADDS     R0,R1,R0
   \   0000017E   0x4581             CMP      R9,R0
   \   00000180   0xD20E             BCS.N    ??get_cluster_11
   \   00000182   0x78B8             LDRB     R0,[R7, #+2]
   \   00000184   0x2802             CMP      R0,#+2
   \   00000186   0xDB0B             BLT.N    ??get_cluster_11
   \   00000188   0x1E45             SUBS     R5,R0,#+1
   \                     ??get_cluster_12: (+1)
   \   0000018A   0x6870             LDR      R0,[R6, #+4]
   \   0000018C   0x4481             ADD      R9,R0,R9
   \   0000018E   0x78F8             LDRB     R0,[R7, #+3]
   \   00000190   0x2301             MOVS     R3,#+1
   \   00000192   0x464A             MOV      R2,R9
   \   00000194   0xF108 0x0130      ADD      R1,R8,#+48
   \   00000198   0x.... 0x....      BL       disk_write
   \   0000019C   0x1E6D             SUBS     R5,R5,#+1
   \   0000019E   0xD1F4             BNE.N    ??get_cluster_12
   \                     ??get_cluster_11: (+1)
   \   000001A0   0xB14C             CBZ.N    R4,??get_cluster_10
   \   000001A2   0x78F8             LDRB     R0,[R7, #+3]
   \   000001A4   0x2301             MOVS     R3,#+1
   \   000001A6   0x4622             MOV      R2,R4
   \   000001A8   0xF108 0x0130      ADD      R1,R8,#+48
   \   000001AC   0x.... 0x....      BL       disk_read
   \   000001B0   0x2800             CMP      R0,#+0
   \   000001B2   0xD141             BNE.N    ??get_cluster_0
   \   000001B4   0x6034             STR      R4,[R6, #+0]
    178                          return LD_WORD(&fs->win[((WORD)clust * 2) & (SS(fs) - 1)]);   
   \                     ??get_cluster_10: (+1)
   \   000001B6   0xEA4F 0x004A      LSL      R0,R10,#+1
   \   000001BA   0x05C0             LSLS     R0,R0,#+23
   \   000001BC   0xEB08 0x50D0      ADD      R0,R8,R0, LSR #+23
   \   000001C0   0x8E00             LDRH     R0,[R0, #+48]
   \   000001C2   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    179                 
    180                      case FS_FAT32 :   
    181                          if (!move_window(fs, fatsect + (clust / (SS(fs) / 4)))) break;   
   \                     ??get_cluster_2: (+1)
   \   000001C6   0xEB09 0x14DA      ADD      R4,R9,R10, LSR #+7
   \   000001CA   0xF8D6 0x9000      LDR      R9,[R6, #+0]
   \   000001CE   0x45A1             CMP      R9,R4
   \   000001D0   0xD028             BEQ.N    ??get_cluster_13
   \   000001D2   0x7938             LDRB     R0,[R7, #+4]
   \   000001D4   0xB1E0             CBZ.N    R0,??get_cluster_14
   \   000001D6   0x78F8             LDRB     R0,[R7, #+3]
   \   000001D8   0x2301             MOVS     R3,#+1
   \   000001DA   0x464A             MOV      R2,R9
   \   000001DC   0xF108 0x0130      ADD      R1,R8,#+48
   \   000001E0   0x.... 0x....      BL       disk_write
   \   000001E4   0xBB40             CBNZ.N   R0,??get_cluster_0
   \   000001E6   0x7138             STRB     R0,[R7, #+4]
   \   000001E8   0x6871             LDR      R1,[R6, #+4]
   \   000001EA   0x68F0             LDR      R0,[R6, #+12]
   \   000001EC   0x1808             ADDS     R0,R1,R0
   \   000001EE   0x4581             CMP      R9,R0
   \   000001F0   0xD20E             BCS.N    ??get_cluster_14
   \   000001F2   0x78B8             LDRB     R0,[R7, #+2]
   \   000001F4   0x2802             CMP      R0,#+2
   \   000001F6   0xDB0B             BLT.N    ??get_cluster_14
   \   000001F8   0x1E45             SUBS     R5,R0,#+1
   \                     ??get_cluster_15: (+1)
   \   000001FA   0x6870             LDR      R0,[R6, #+4]
   \   000001FC   0x4481             ADD      R9,R0,R9
   \   000001FE   0x78F8             LDRB     R0,[R7, #+3]
   \   00000200   0x2301             MOVS     R3,#+1
   \   00000202   0x464A             MOV      R2,R9
   \   00000204   0xF108 0x0130      ADD      R1,R8,#+48
   \   00000208   0x.... 0x....      BL       disk_write
   \   0000020C   0x1E6D             SUBS     R5,R5,#+1
   \   0000020E   0xD1F4             BNE.N    ??get_cluster_15
   \                     ??get_cluster_14: (+1)
   \   00000210   0xB144             CBZ.N    R4,??get_cluster_13
   \   00000212   0x78F8             LDRB     R0,[R7, #+3]
   \   00000214   0x2301             MOVS     R3,#+1
   \   00000216   0x4622             MOV      R2,R4
   \   00000218   0xF108 0x0130      ADD      R1,R8,#+48
   \   0000021C   0x.... 0x....      BL       disk_read
   \   00000220   0xB950             CBNZ.N   R0,??get_cluster_0
   \   00000222   0x6034             STR      R4,[R6, #+0]
    182                          return LD_DWORD(&fs->win[((WORD)clust * 4) & (SS(fs) - 1)]) & 0x0FFFFFFF;   
   \                     ??get_cluster_13: (+1)
   \   00000224   0xEA4F 0x008A      LSL      R0,R10,#+2
   \   00000228   0x05C0             LSLS     R0,R0,#+23
   \   0000022A   0xEB08 0x50D0      ADD      R0,R8,R0, LSR #+23
   \   0000022E   0x6B00             LDR      R0,[R0, #+48]
   \   00000230   0x0100             LSLS     R0,R0,#+4
   \   00000232   0x0900             LSRS     R0,R0,#+4
   \   00000234   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    183                      }   
    184                  }   
    185                 
    186                  return 1;   /* Out of cluster range, or an error occured */   
   \                     ??get_cluster_0: (+1)
   \   00000238   0x2001             MOVS     R0,#+1
   \   0000023A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    187              }   
    188                 
    189                 
    190                 
    191                 
    192              /*-----------------------------------------------------------------------*/   
    193              /* Change a cluster status                                               */   
    194              /*-----------------------------------------------------------------------*/   
    195                 
    196              #if !_FS_READONLY   

   \                                 In section .text, align 2, keep-with-next
    197              static   
    198              BOOL put_cluster (  /* TRUE: successful, FALSE: failed */   
    199                  FATFS *fs,      /* File system object */   
    200                  DWORD clust,    /* Cluster# to change (must be 2 to fs->max_clust-1) */   
    201                  DWORD val       /* New value to mark the cluster */   
    202              )   
    203              {   
   \                     put_cluster: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
    204                  WORD bc;   
    205                  BYTE *p;   
    206                  DWORD fatsect;   
    207                 
    208                 
    209                  fatsect = fs->fatbase;   
    210                  switch (fs->fs_type) {   
   \   00000006   0xF108 0x072A      ADD      R7,R8,#+42
   \   0000000A   0xF108 0x0404      ADD      R4,R8,#+4
   \   0000000E   0x7838             LDRB     R0,[R7, #+0]
   \   00000010   0xF8D4 0x900C      LDR      R9,[R4, #+12]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0x460D             MOV      R5,R1
   \   00000018   0x4616             MOV      R6,R2
   \   0000001A   0xD005             BEQ.N    ??put_cluster_0
   \   0000001C   0xF0C0 0x8085      BCC.W    ??put_cluster_1
   \   00000020   0x2803             CMP      R0,#+3
   \   00000022   0xD048             BEQ.N    ??put_cluster_2
   \   00000024   0xD33A             BCC.N    ??put_cluster_3
   \   00000026   0xE080             B.N      ??put_cluster_1
    211                  case FS_FAT12 :   
    212                      bc = (WORD)clust * 3 / 2;   
   \                     ??put_cluster_0: (+1)
   \   00000028   0xB2A8             UXTH     R0,R5
   \   0000002A   0xEB00 0x0040      ADD      R0,R0,R0, LSL #+1
   \   0000002E   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   00000032   0x03C4             LSLS     R4,R0,#+15
   \   00000034   0x0C24             LSRS     R4,R4,#+16
    213                      if (!move_window(fs, fatsect + (bc / SS(fs)))) return FALSE;   
   \   00000036   0xEB09 0x2154      ADD      R1,R9,R4, LSR #+9
   \   0000003A   0x4640             MOV      R0,R8
   \   0000003C   0x.... 0x....      BL       move_window
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD072             BEQ.N    ??put_cluster_1
    214                      p = &fs->win[bc & (SS(fs) - 1)];   
   \   00000044   0x05E0             LSLS     R0,R4,#+23
   \   00000046   0xEB08 0x50D0      ADD      R0,R8,R0, LSR #+23
   \   0000004A   0x3030             ADDS     R0,R0,#+48
    215                      *p = (clust & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;   
   \   0000004C   0x07E9             LSLS     R1,R5,#+31
   \   0000004E   0xBF43             ITTTE    MI 
   \   00000050   0x7801             LDRBMI   R1,[R0, #+0]
   \   00000052   0xF001 0x010F      ANDMI    R1,R1,#0xF
   \   00000056   0xEA41 0x1106      ORRMI    R1,R1,R6, LSL #+4
   \   0000005A   0x4631             MOVPL    R1,R6
   \   0000005C   0x7001             STRB     R1,[R0, #+0]
    216                      bc++;   
    217                      fs->winflag = 1;   
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0x1C64             ADDS     R4,R4,#+1
   \   00000062   0x7138             STRB     R0,[R7, #+4]
   \   00000064   0xB2A4             UXTH     R4,R4
    218                      if (!move_window(fs, fatsect + (bc / SS(fs)))) return FALSE;   
   \   00000066   0xEB09 0x2154      ADD      R1,R9,R4, LSR #+9
   \   0000006A   0x4640             MOV      R0,R8
   \   0000006C   0x.... 0x....      BL       move_window
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD05A             BEQ.N    ??put_cluster_1
    219                      p = &fs->win[bc & (SS(fs) - 1)];   
   \   00000074   0x05E0             LSLS     R0,R4,#+23
   \   00000076   0xEB08 0x50D0      ADD      R0,R8,R0, LSR #+23
   \   0000007A   0x3030             ADDS     R0,R0,#+48
    220                      *p = (clust & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));   
   \   0000007C   0x07E9             LSLS     R1,R5,#+31
   \   0000007E   0xBF48             IT       MI 
   \   00000080   0x0931             LSRMI    R1,R6,#+4
   \   00000082   0xD406             BMI.N    ??put_cluster_4
   \   00000084   0x7801             LDRB     R1,[R0, #+0]
   \   00000086   0x0A32             LSRS     R2,R6,#+8
   \   00000088   0xF001 0x01F0      AND      R1,R1,#0xF0
   \   0000008C   0xF002 0x020F      AND      R2,R2,#0xF
   \   00000090   0x4311             ORRS     R1,R2,R1
   \                     ??put_cluster_4: (+1)
   \   00000092   0x7001             STRB     R1,[R0, #+0]
    221                      break;   
    222                 
    223                  case FS_FAT16 :   
    224                      if (!move_window(fs, fatsect + (clust / (SS(fs) / 2)))) return FALSE;   
    225                      ST_WORD(&fs->win[((WORD)clust * 2) & (SS(fs) - 1)], (WORD)val);   
    226                      break;   
    227                 
    228                  case FS_FAT32 :   
    229                      if (!move_window(fs, fatsect + (clust / (SS(fs) / 4)))) return FALSE;   
    230                      ST_DWORD(&fs->win[((WORD)clust * 4) & (SS(fs) - 1)], val);   
    231                      break;   
    232                 
    233                  default :   
    234                      return FALSE;   
    235                  }   
    236                  fs->winflag = 1;   
   \                     ??put_cluster_5: (+1)
   \   00000094   0x2001             MOVS     R0,#+1
   \   00000096   0x7138             STRB     R0,[R7, #+4]
    237                  return TRUE;   
   \   00000098   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \                     ??put_cluster_3: (+1)
   \   0000009C   0xEB09 0x2115      ADD      R1,R9,R5, LSR #+8
   \   000000A0   0x4640             MOV      R0,R8
   \   000000A2   0x.... 0x....      BL       move_window
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD03F             BEQ.N    ??put_cluster_1
   \   000000AA   0x0068             LSLS     R0,R5,#+1
   \   000000AC   0x05C0             LSLS     R0,R0,#+23
   \   000000AE   0xEB08 0x50D0      ADD      R0,R8,R0, LSR #+23
   \   000000B2   0x8606             STRH     R6,[R0, #+48]
   \   000000B4   0xE7EE             B.N      ??put_cluster_5
   \                     ??put_cluster_2: (+1)
   \   000000B6   0xF8D4 0xA000      LDR      R10,[R4, #+0]
   \   000000BA   0xEB09 0x19D5      ADD      R9,R9,R5, LSR #+7
   \   000000BE   0x45CA             CMP      R10,R9
   \   000000C0   0xD02D             BEQ.N    ??put_cluster_6
   \   000000C2   0x7938             LDRB     R0,[R7, #+4]
   \   000000C4   0xB1F0             CBZ.N    R0,??put_cluster_7
   \   000000C6   0x78F8             LDRB     R0,[R7, #+3]
   \   000000C8   0x2301             MOVS     R3,#+1
   \   000000CA   0x4652             MOV      R2,R10
   \   000000CC   0xF108 0x0130      ADD      R1,R8,#+48
   \   000000D0   0x.... 0x....      BL       disk_write
   \   000000D4   0xBB48             CBNZ.N   R0,??put_cluster_1
   \   000000D6   0x7138             STRB     R0,[R7, #+4]
   \   000000D8   0x6861             LDR      R1,[R4, #+4]
   \   000000DA   0x68E0             LDR      R0,[R4, #+12]
   \   000000DC   0x1808             ADDS     R0,R1,R0
   \   000000DE   0x4582             CMP      R10,R0
   \   000000E0   0xD210             BCS.N    ??put_cluster_7
   \   000000E2   0x78B8             LDRB     R0,[R7, #+2]
   \   000000E4   0x2802             CMP      R0,#+2
   \   000000E6   0xDB0D             BLT.N    ??put_cluster_7
   \   000000E8   0xF1A0 0x0B01      SUB      R11,R0,#+1
   \                     ??put_cluster_8: (+1)
   \   000000EC   0x6860             LDR      R0,[R4, #+4]
   \   000000EE   0x4482             ADD      R10,R0,R10
   \   000000F0   0x78F8             LDRB     R0,[R7, #+3]
   \   000000F2   0x2301             MOVS     R3,#+1
   \   000000F4   0x4652             MOV      R2,R10
   \   000000F6   0xF108 0x0130      ADD      R1,R8,#+48
   \   000000FA   0x.... 0x....      BL       disk_write
   \   000000FE   0xF1BB 0x0B01      SUBS     R11,R11,#+1
   \   00000102   0xD1F3             BNE.N    ??put_cluster_8
   \                     ??put_cluster_7: (+1)
   \   00000104   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000108   0xD009             BEQ.N    ??put_cluster_6
   \   0000010A   0x78F8             LDRB     R0,[R7, #+3]
   \   0000010C   0x2301             MOVS     R3,#+1
   \   0000010E   0x464A             MOV      R2,R9
   \   00000110   0xF108 0x0130      ADD      R1,R8,#+48
   \   00000114   0x.... 0x....      BL       disk_read
   \   00000118   0xB938             CBNZ.N   R0,??put_cluster_1
   \   0000011A   0xF8C4 0x9000      STR      R9,[R4, #+0]
   \                     ??put_cluster_6: (+1)
   \   0000011E   0x00A8             LSLS     R0,R5,#+2
   \   00000120   0x05C0             LSLS     R0,R0,#+23
   \   00000122   0xEB08 0x50D0      ADD      R0,R8,R0, LSR #+23
   \   00000126   0x6306             STR      R6,[R0, #+48]
   \   00000128   0xE7B4             B.N      ??put_cluster_5
   \                     ??put_cluster_1: (+1)
   \   0000012A   0x....             B.N      ?Subroutine3
    238              }   

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    239              #endif /* !_FS_READONLY */   
    240                 
    241                 
    242                 
    243                 
    244              /*-----------------------------------------------------------------------*/   
    245              /* Remove a cluster chain                                                */   
    246              /*-----------------------------------------------------------------------*/   
    247                 
    248              #if !_FS_READONLY   

   \                                 In section .text, align 2, keep-with-next
    249              static   
    250              BOOL remove_chain ( /* TRUE: successful, FALSE: failed */   
    251                  FATFS *fs,      /* File system object */   
    252                  DWORD clust     /* Cluster# to remove chain from */   
    253              )   
    254              {   
   \                     remove_chain: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4681             MOV      R9,R0
   \   00000006   0x460F             MOV      R7,R1
   \   00000008   0xF109 0x050C      ADD      R5,R9,#+12
   \   0000000C   0xE060             B.N      ??remove_chain_0
    255                  DWORD nxt;   
    256                 
    257                 
    258                  while (clust >= 2 && clust < fs->max_clust) {   
    259                      nxt = get_cluster(fs, clust);   
    260                      if (nxt == 1) return FALSE;   
    261                      if (!put_cluster(fs, clust, 0)) return FALSE;   
   \                     ??remove_chain_1: (+1)
   \   0000000E   0x7FA8             LDRB     R0,[R5, #+30]
   \   00000010   0xF8D5 0x8004      LDR      R8,[R5, #+4]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD020             BEQ.N    ??remove_chain_2
   \   00000018   0xD366             BCC.N    ??remove_chain_3
   \   0000001A   0x2803             CMP      R0,#+3
   \   0000001C   0xD001             BEQ.N    ??remove_chain_4
   \   0000001E   0xD30E             BCC.N    ??remove_chain_5
   \   00000020   0xE062             B.N      ??remove_chain_3
   \                     ??remove_chain_4: (+1)
   \   00000022   0xEB08 0x11D7      ADD      R1,R8,R7, LSR #+7
   \   00000026   0x4648             MOV      R0,R9
   \   00000028   0x.... 0x....      BL       move_window
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD05B             BEQ.N    ??remove_chain_3
   \   00000030   0x00B8             LSLS     R0,R7,#+2
   \   00000032   0x05C0             LSLS     R0,R0,#+23
   \   00000034   0xEB09 0x50D0      ADD      R0,R9,R0, LSR #+23
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x6301             STR      R1,[R0, #+48]
   \   0000003C   0xE03C             B.N      ??remove_chain_6
   \                     ??remove_chain_5: (+1)
   \   0000003E   0xEB08 0x2117      ADD      R1,R8,R7, LSR #+8
   \   00000042   0x4648             MOV      R0,R9
   \   00000044   0x.... 0x....      BL       move_window
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD04D             BEQ.N    ??remove_chain_3
   \   0000004C   0x0078             LSLS     R0,R7,#+1
   \   0000004E   0x05C0             LSLS     R0,R0,#+23
   \   00000050   0xEB09 0x50D0      ADD      R0,R9,R0, LSR #+23
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x8601             STRH     R1,[R0, #+48]
   \   00000058   0xE02E             B.N      ??remove_chain_6
   \                     ??remove_chain_2: (+1)
   \   0000005A   0xB2B8             UXTH     R0,R7
   \   0000005C   0xEB00 0x0040      ADD      R0,R0,R0, LSL #+1
   \   00000060   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   00000064   0x03C4             LSLS     R4,R0,#+15
   \   00000066   0x0C24             LSRS     R4,R4,#+16
   \   00000068   0xEB08 0x2154      ADD      R1,R8,R4, LSR #+9
   \   0000006C   0x4648             MOV      R0,R9
   \   0000006E   0x.... 0x....      BL       move_window
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD038             BEQ.N    ??remove_chain_3
   \   00000076   0x05E0             LSLS     R0,R4,#+23
   \   00000078   0xEB09 0x50D0      ADD      R0,R9,R0, LSR #+23
   \   0000007C   0x3030             ADDS     R0,R0,#+48
   \   0000007E   0x07F9             LSLS     R1,R7,#+31
   \   00000080   0xBF46             ITTE     MI 
   \   00000082   0x7801             LDRBMI   R1,[R0, #+0]
   \   00000084   0xF001 0x010F      ANDMI    R1,R1,#0xF
   \   00000088   0x2100             MOVPL    R1,#+0
   \   0000008A   0x7001             STRB     R1,[R0, #+0]
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0x1C64             ADDS     R4,R4,#+1
   \   00000090   0xF889 0x002E      STRB     R0,[R9, #+46]
   \   00000094   0xB2A4             UXTH     R4,R4
   \   00000096   0xEB08 0x2154      ADD      R1,R8,R4, LSR #+9
   \   0000009A   0x4648             MOV      R0,R9
   \   0000009C   0x.... 0x....      BL       move_window
   \   000000A0   0xB310             CBZ.N    R0,??remove_chain_3
   \   000000A2   0x05E0             LSLS     R0,R4,#+23
   \   000000A4   0xEB09 0x50D0      ADD      R0,R9,R0, LSR #+23
   \   000000A8   0x3030             ADDS     R0,R0,#+48
   \   000000AA   0x07F9             LSLS     R1,R7,#+31
   \   000000AC   0xBF4E             ITEE     MI 
   \   000000AE   0x2100             MOVMI    R1,#+0
   \   000000B0   0x7801             LDRBPL   R1,[R0, #+0]
   \   000000B2   0xF001 0x01F0      ANDPL    R1,R1,#0xF0
   \   000000B6   0x7001             STRB     R1,[R0, #+0]
   \                     ??remove_chain_6: (+1)
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0xF889 0x002E      STRB     R0,[R9, #+46]
    262                      if (fs->free_clust != 0xFFFFFFFF) {   
   \   000000BE   0x6968             LDR      R0,[R5, #+20]
   \   000000C0   0xF110 0x0F01      CMN      R0,#+1
   \   000000C4   0xD003             BEQ.N    ??remove_chain_7
    263                          fs->free_clust++;   
   \   000000C6   0x1C40             ADDS     R0,R0,#+1
   \   000000C8   0x6168             STR      R0,[R5, #+20]
    264              #if _USE_FSINFO   
    265                          fs->fsi_flag = 1;   
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0x7728             STRB     R0,[R5, #+28]
    266              #endif   
    267                      }   
    268                      clust = nxt;   
   \                     ??remove_chain_7: (+1)
   \   000000CE   0x4637             MOV      R7,R6
   \                     ??remove_chain_0: (+1)
   \   000000D0   0x2F02             CMP      R7,#+2
   \   000000D2   0xD30A             BCC.N    ??remove_chain_8
   \   000000D4   0x6828             LDR      R0,[R5, #+0]
   \   000000D6   0x4287             CMP      R7,R0
   \   000000D8   0xD207             BCS.N    ??remove_chain_8
   \   000000DA   0x4639             MOV      R1,R7
   \   000000DC   0x4648             MOV      R0,R9
   \   000000DE   0x.... 0x....      BL       get_cluster
   \   000000E2   0x4606             MOV      R6,R0
   \   000000E4   0x2E01             CMP      R6,#+1
   \   000000E6   0xD192             BNE.N    ??remove_chain_1
   \                     ??remove_chain_3: (+1)
   \   000000E8   0x....             B.N      ?Subroutine1
    269                  }   
    270                  return TRUE;   
   \                     ??remove_chain_8: (+1)
   \   000000EA   0x....             B.N      ?Subroutine0
    271              }   
    272              #endif   
    273                 
    274                 
    275                 
    276                 
    277              /*-----------------------------------------------------------------------*/   
    278              /* Stretch or create a cluster chain                                     */   
    279              /*-----------------------------------------------------------------------*/   
    280                 
    281              #if !_FS_READONLY   

   \                                 In section .text, align 2, keep-with-next
    282              static   
    283              DWORD create_chain (    /* 0: No free cluster, 1: Error, >=2: New cluster number */   
    284                  FATFS *fs,          /* File system object */   
    285                  DWORD clust         /* Cluster# to stretch, 0 means create new */   
    286              )   
    287              {   
   \                     create_chain: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4681             MOV      R9,R0
    288                  DWORD cstat, ncl, scl, mcl = fs->max_clust;   
   \   00000006   0xF109 0x040C      ADD      R4,R9,#+12
   \   0000000A   0x000F             MOVS     R7,R1
   \   0000000C   0xF8D4 0x8000      LDR      R8,[R4, #+0]
    289                 
    290                 
    291                  if (clust == 0) {       /* Create new chain */   
   \   00000010   0xD105             BNE.N    ??create_chain_0
    292                      scl = fs->last_clust;            /* Get suggested start point */   
   \   00000012   0x6926             LDR      R6,[R4, #+16]
    293                      if (scl == 0 || scl >= mcl) scl = 1;   
   \   00000014   0xB10E             CBZ.N    R6,??create_chain_1
   \   00000016   0x4546             CMP      R6,R8
   \   00000018   0xD308             BCC.N    ??create_chain_2
   \                     ??create_chain_1: (+1)
   \   0000001A   0x2601             MOVS     R6,#+1
   \   0000001C   0xE006             B.N      ??create_chain_2
    294                  }   
    295                  else {                  /* Stretch existing chain */   
    296                      cstat = get_cluster(fs, clust); /* Check the cluster status */   
   \                     ??create_chain_0: (+1)
   \   0000001E   0x.... 0x....      BL       get_cluster
    297                      if (cstat < 2) return 1;     /* It is an invalid cluster */   
   \   00000022   0x2802             CMP      R0,#+2
   \   00000024   0xD31C             BCC.N    ??create_chain_3
    298                      if (cstat < mcl) return cstat;   /* It is already followed by next cluster */   
   \   00000026   0x4540             CMP      R0,R8
   \   00000028   0xD32A             BCC.N    ??create_chain_4
    299                      scl = clust;   
   \   0000002A   0x463E             MOV      R6,R7
    300                  }   
    301                 
    302                  ncl = scl;              /* Start cluster */   
   \                     ??create_chain_2: (+1)
   \   0000002C   0x4635             MOV      R5,R6
    303                  for (;;) {   
    304                      ncl++;                          /* Next cluster */   
   \                     ??create_chain_5: (+1)
   \   0000002E   0x1C6D             ADDS     R5,R5,#+1
    305                      if (ncl >= mcl) {                /* Wrap around */   
   \   00000030   0x4545             CMP      R5,R8
   \   00000032   0xD302             BCC.N    ??create_chain_6
    306                          ncl = 2;   
   \   00000034   0x2502             MOVS     R5,#+2
    307                          if (ncl > scl) return 0; /* No free custer */   
   \   00000036   0x2E02             CMP      R6,#+2
   \   00000038   0xD317             BCC.N    ??create_chain_7
    308                      }   
    309                      cstat = get_cluster(fs, ncl);   /* Get the cluster status */   
   \                     ??create_chain_6: (+1)
   \   0000003A   0x4629             MOV      R1,R5
   \   0000003C   0x4648             MOV      R0,R9
   \   0000003E   0x.... 0x....      BL       get_cluster
    310                      if (cstat == 0) break;          /* Found a free cluster */   
   \   00000042   0xB970             CBNZ.N   R0,??create_chain_8
    311                      if (cstat == 1) return 1;       /* Any error occured */   
    312                      if (ncl == scl) return 0;       /* No free custer */   
    313                  }   
    314                 
    315                  if (!put_cluster(fs, ncl, 0x0FFFFFFF)) return 1;            /* Mark the new cluster "in use" */   
   \   00000044   0xF06F 0x4270      MVN      R2,#-268435456
   \   00000048   0x4629             MOV      R1,R5
   \   0000004A   0x4648             MOV      R0,R9
   \   0000004C   0x.... 0x....      BL       put_cluster
   \   00000050   0xB130             CBZ.N    R0,??create_chain_3
    316                  if (clust != 0 && !put_cluster(fs, clust, ncl)) return 1;   /* Link it to previous one if needed */   
   \   00000052   0xB15F             CBZ.N    R7,??create_chain_9
   \   00000054   0x462A             MOV      R2,R5
   \   00000056   0x4639             MOV      R1,R7
   \   00000058   0x4648             MOV      R0,R9
   \   0000005A   0x.... 0x....      BL       put_cluster
   \   0000005E   0xB928             CBNZ.N   R0,??create_chain_9
   \                     ??create_chain_3: (+1)
   \   00000060   0x....             B.N      ?Subroutine0
   \                     ??create_chain_8: (+1)
   \   00000062   0x2801             CMP      R0,#+1
   \   00000064   0xD0FC             BEQ.N    ??create_chain_3
   \   00000066   0x42B5             CMP      R5,R6
   \   00000068   0xD1E1             BNE.N    ??create_chain_5
   \                     ??create_chain_7: (+1)
   \   0000006A   0x....             B.N      ?Subroutine1
    317                 
    318                  fs->last_clust = ncl;                /* Update fsinfo */   
    319                  if (fs->free_clust != 0xFFFFFFFF) {   
   \                     ??create_chain_9: (+1)
   \   0000006C   0x6960             LDR      R0,[R4, #+20]
   \   0000006E   0x6125             STR      R5,[R4, #+16]
   \   00000070   0xF110 0x0F01      CMN      R0,#+1
   \   00000074   0xD003             BEQ.N    ??create_chain_10
    320                      fs->free_clust--;   
   \   00000076   0x1E40             SUBS     R0,R0,#+1
   \   00000078   0x6160             STR      R0,[R4, #+20]
    321              #if _USE_FSINFO   
    322                      fs->fsi_flag = 1;   
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0x7720             STRB     R0,[R4, #+28]
    323              #endif   
    324                  }   
    325                 
    326                  return ncl;     /* Return new cluster number */   
   \                     ??create_chain_10: (+1)
   \   0000007E   0x4628             MOV      R0,R5
   \                     ??create_chain_4: (+1)
   \   00000080   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    327              }   
    328              #endif /* !_FS_READONLY */   
    329                 
    330                 
    331                 
    332                 
    333              /*-----------------------------------------------------------------------*/   
    334              /* Get sector# from cluster#                                             */   
    335              /*-----------------------------------------------------------------------*/   
    336                 

   \                                 In section .text, align 2, keep-with-next
    337              static   
    338              DWORD clust2sect (  /* !=0: sector number, 0: failed - invalid cluster# */   
    339                  FATFS *fs,      /* File system object */   
    340                  DWORD clust     /* Cluster# to be converted */   
    341              )   
    342              {   
    343                  clust -= 2;   
    344                  if (clust >= (fs->max_clust - 2)) return 0;       /* Invalid cluster# */   
   \                     clust2sect: (+1)
   \   00000000   0xF850 0x2F0C      LDR      R2,[R0, #+12]!
   \   00000004   0x1E89             SUBS     R1,R1,#+2
   \   00000006   0x1E92             SUBS     R2,R2,#+2
   \   00000008   0x4291             CMP      R1,R2
   \   0000000A   0xBF2F             ITEEE    CS 
   \   0000000C   0x2000             MOVCS    R0,#+0
   \   0000000E   0x7FC2             LDRBCC   R2,[R0, #+31]
   \   00000010   0x68C0             LDRCC    R0,[R0, #+12]
   \   00000012   0xFB02 0x0001      MLACC    R0,R2,R1,R0
    345                  return clust * fs->csize + fs->database;   
   \   00000016   0x4770             BX       LR
    346              }   
    347                 
    348                 
    349                 
    350                 
    351              /*-----------------------------------------------------------------------*/   
    352              /* Move directory pointer to next                                        */   
    353              /*-----------------------------------------------------------------------*/   
    354                 

   \                                 In section .text, align 2, keep-with-next
    355              static   
    356              BOOL next_dir_entry (   /* TRUE: successful, FALSE: could not move next */   
    357                  DIR *dj             /* Pointer to directory object */   
    358              )   
    359              {   
   \                     next_dir_entry: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    360                  DWORD clust;   
    361                  WORD idx;   
    362                 
    363                 
    364                  idx = dj->index + 1;   
   \   00000004   0x8860             LDRH     R0,[R4, #+2]
   \   00000006   0x1C45             ADDS     R5,R0,#+1
   \   00000008   0xB2AD             UXTH     R5,R5
    365                  if ((idx & ((SS(dj->fs) - 1) / 32)) == 0) {      /* Table sector changed? */   
   \   0000000A   0xF015 0x0F0F      TST      R5,#0xF
   \   0000000E   0xD11F             BNE.N    ??next_dir_entry_0
    366                      dj->sect++;              /* Next sector */   
   \   00000010   0x6920             LDR      R0,[R4, #+16]
    367                      if (dj->clust == 0) {    /* In static table */   
   \   00000012   0x68E1             LDR      R1,[R4, #+12]
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   \   00000016   0x6120             STR      R0,[R4, #+16]
   \   00000018   0x6860             LDR      R0,[R4, #+4]
   \   0000001A   0xB919             CBNZ.N   R1,??next_dir_entry_1
    368                          if (idx >= dj->fs->n_rootdir) return FALSE;    /* Reached to end of table */   
   \   0000001C   0x8840             LDRH     R0,[R0, #+2]
   \   0000001E   0x4285             CMP      R5,R0
   \   00000020   0xDB16             BLT.N    ??next_dir_entry_0
   \   00000022   0xE00D             B.N      ??next_dir_entry_2
    369                      } else {                    /* In dynamic table */   
    370                          if (((idx / (SS(dj->fs) / 32)) & (dj->fs->csize - 1)) == 0) {  /* Cluster changed? */   
   \                     ??next_dir_entry_1: (+1)
   \   00000024   0xF890 0x202B      LDRB     R2,[R0, #+43]
   \   00000028   0x1E52             SUBS     R2,R2,#+1
   \   0000002A   0xEA12 0x1F15      TST      R2,R5, LSR #+4
   \   0000002E   0xD10F             BNE.N    ??next_dir_entry_0
    371                              clust = get_cluster(dj->fs, dj->clust);           /* Get next cluster */   
   \   00000030   0x.... 0x....      BL       get_cluster
    372                              if (clust < 2 || clust >= dj->fs->max_clust)    /* Reached to end of table */   
   \   00000034   0x2802             CMP      R0,#+2
   \   00000036   0xD303             BCC.N    ??next_dir_entry_2
   \   00000038   0x6862             LDR      R2,[R4, #+4]
   \   0000003A   0x68D1             LDR      R1,[R2, #+12]
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xD301             BCC.N    ??next_dir_entry_3
    373                                  return FALSE;   
   \                     ??next_dir_entry_2: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBD32             POP      {R1,R4,R5,PC}
    374                              dj->clust = clust;               /* Initialize for new cluster */   
   \                     ??next_dir_entry_3: (+1)
   \   00000044   0x60E0             STR      R0,[R4, #+12]
    375                              dj->sect = clust2sect(dj->fs, clust);   
   \   00000046   0x4601             MOV      R1,R0
   \   00000048   0x4610             MOV      R0,R2
   \   0000004A   0x.... 0x....      BL       clust2sect
   \   0000004E   0x6120             STR      R0,[R4, #+16]
    376                          }   
    377                      }   
    378                  }   
    379                  dj->index = idx; /* Lower several bits of dj->index indicates offset in dj->sect */   
   \                     ??next_dir_entry_0: (+1)
   \   00000050   0x8065             STRH     R5,[R4, #+2]
    380                  return TRUE;   
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    381              }   
    382                 
    383                 
    384                 
    385                 
    386              /*-----------------------------------------------------------------------*/   
    387              /* Get file status from directory entry                                  */   
    388              /*-----------------------------------------------------------------------*/   
    389                 
    390              #if _FS_MINIMIZE <= 1   

   \                                 In section .text, align 2, keep-with-next
    391              static   
    392              void get_fileinfo ( /* No return code */   
    393                  FILINFO *finfo, /* Ptr to store the file information */   
    394                  const BYTE *dir /* Ptr to the directory entry */   
    395              )   
    396              {   
   \                     get_fileinfo: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    397                  BYTE n, c, a;   
    398                  char *p;   
    399                 
    400                 
    401                  p = &finfo->fname[0];   
    402                  a = _USE_NTFLAG ? dir[DIR_NTres] : 0;       /* NT flag */   
   \   00000002   0x7B0B             LDRB     R3,[R1, #+12]
   \   00000004   0xF100 0x0209      ADD      R2,R0,#+9
    403                  for (n = 0; n < 8; n++) {    /* Convert file name (body) */   
   \   00000008   0x460C             MOV      R4,R1
   \   0000000A   0x2508             MOVS     R5,#+8
   \   0000000C   0xF003 0x0608      AND      R6,R3,#0x8
    404                      c = dir[n];   
   \                     ??get_fileinfo_0: (+1)
   \   00000010   0x7827             LDRB     R7,[R4, #+0]
    405                      if (c == ' ') break;   
   \   00000012   0x2F20             CMP      R7,#+32
   \   00000014   0xD00F             BEQ.N    ??get_fileinfo_1
    406                      if (c == 0x05) c = 0xE5;   
   \   00000016   0x2F05             CMP      R7,#+5
   \   00000018   0xBF08             IT       EQ 
   \   0000001A   0x27E5             MOVEQ    R7,#+229
    407                      if (a & 0x08 && c >= 'A' && c <= 'Z') c += 0x20;   
   \   0000001C   0xB136             CBZ.N    R6,??get_fileinfo_2
   \   0000001E   0xF1A7 0x0C41      SUB      R12,R7,#+65
   \   00000022   0xF1BC 0x0F1A      CMP      R12,#+26
   \   00000026   0xBF3C             ITT      CC 
   \   00000028   0x3720             ADDCC    R7,R7,#+32
   \   0000002A   0xB2FF             UXTBCC   R7,R7
    408                      *p++ = c;   
    409                  }   
   \                     ??get_fileinfo_2: (+1)
   \   0000002C   0x1C64             ADDS     R4,R4,#+1
   \   0000002E   0x1E6D             SUBS     R5,R5,#+1
   \   00000030   0xF802 0x7B01      STRB     R7,[R2], #+1
   \   00000034   0xD1EC             BNE.N    ??get_fileinfo_0
    410                  if (dir[8] != ' ') {        /* Convert file name (extension) */   
   \                     ??get_fileinfo_1: (+1)
   \   00000036   0x7A0C             LDRB     R4,[R1, #+8]
   \   00000038   0x2C20             CMP      R4,#+32
   \   0000003A   0xD015             BEQ.N    ??get_fileinfo_3
    411                      *p++ = '.';   
   \   0000003C   0x242E             MOVS     R4,#+46
   \   0000003E   0xF802 0x4B01      STRB     R4,[R2], #+1
    412                      for (n = 8; n < 11; n++) {   
   \   00000042   0x2503             MOVS     R5,#+3
   \   00000044   0xF101 0x0408      ADD      R4,R1,#+8
    413                          c = dir[n];   
   \                     ??get_fileinfo_4: (+1)
   \   00000048   0x7827             LDRB     R7,[R4, #+0]
    414                          if (c == ' ') break;   
   \   0000004A   0x2F20             CMP      R7,#+32
   \   0000004C   0xD00C             BEQ.N    ??get_fileinfo_3
    415                          if (a & 0x10 && c >= 'A' && c <= 'Z') c += 0x20;   
   \   0000004E   0x06DE             LSLS     R6,R3,#+27
   \   00000050   0xD505             BPL.N    ??get_fileinfo_5
   \   00000052   0xF1A7 0x0641      SUB      R6,R7,#+65
   \   00000056   0x2E1A             CMP      R6,#+26
   \   00000058   0xBF3C             ITT      CC 
   \   0000005A   0x3720             ADDCC    R7,R7,#+32
   \   0000005C   0xB2FF             UXTBCC   R7,R7
    416                          *p++ = c;   
    417                      }   
   \                     ??get_fileinfo_5: (+1)
   \   0000005E   0x1C64             ADDS     R4,R4,#+1
   \   00000060   0x1E6D             SUBS     R5,R5,#+1
   \   00000062   0xF802 0x7B01      STRB     R7,[R2], #+1
   \   00000066   0xD1EF             BNE.N    ??get_fileinfo_4
    418                  }   
    419                  *p = '\0';   
   \                     ??get_fileinfo_3: (+1)
   \   00000068   0x2300             MOVS     R3,#+0
   \   0000006A   0x7013             STRB     R3,[R2, #+0]
    420                 
    421                  finfo->fattrib = dir[DIR_Attr];                  /* Attribute */   
   \   0000006C   0x7ACA             LDRB     R2,[R1, #+11]
   \   0000006E   0x7202             STRB     R2,[R0, #+8]
    422                  finfo->fsize = LD_DWORD(&dir[DIR_FileSize]); /* Size */   
   \   00000070   0x69CA             LDR      R2,[R1, #+28]
   \   00000072   0x6002             STR      R2,[R0, #+0]
    423                  finfo->fdate = LD_WORD(&dir[DIR_WrtDate]);       /* Date */   
   \   00000074   0x8B0A             LDRH     R2,[R1, #+24]
   \   00000076   0x8082             STRH     R2,[R0, #+4]
    424                  finfo->ftime = LD_WORD(&dir[DIR_WrtTime]);       /* Time */   
   \   00000078   0x8AC9             LDRH     R1,[R1, #+22]
   \   0000007A   0x80C1             STRH     R1,[R0, #+6]
    425              }   
   \   0000007C   0xBCF0             POP      {R4-R7}
   \   0000007E   0x4770             BX       LR               ;; return
    426              #endif /* _FS_MINIMIZE <= 1 */   
    427                 
    428                 
    429                 
    430                 
    431              /*-----------------------------------------------------------------------*/   
    432              /* Pick a paragraph and create the name in format of directory entry     */   
    433              /*-----------------------------------------------------------------------*/   
    434                 

   \                                 In section .text, align 2, keep-with-next
    435              static   
    436              char make_dirfile (     /* 1: error - detected an invalid format, '\0'or'/': next character */   
    437                  const char **path,  /* Pointer to the file path pointer */   
    438                  char *dirname       /* Pointer to directory name buffer {Name(8), Ext(3), NT flag(1)} */   
    439              )   
    440              {   
   \                     make_dirfile: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    441                  BYTE n, t, c, a, b;   
    442                 
    443                 
    444                  memset(dirname, ' ', 8+3);  /* Fill buffer with spaces */   
   \   00000006   0x2220             MOVS     R2,#+32
   \   00000008   0x210B             MOVS     R1,#+11
   \   0000000A   0x4628             MOV      R0,R5
   \   0000000C   0x.... 0x....      BL       __aeabi_memset
    445                  a = 0; b = 0x18;    /* NT flag */   
   \   00000010   0x2300             MOVS     R3,#+0
   \   00000012   0x2118             MOVS     R1,#+24
    446                  n = 0; t = 8;   
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x2608             MOVS     R6,#+8
   \   00000018   0xE007             B.N      ??make_dirfile_0
    447                  for (;;) {   
    448                      c = *(*path)++;   
    449                      if (c == '\0' || c == '/') {        /* Reached to end of str or directory separator */   
    450                          if (n == 0) break;   
    451                          dirname[11] = _USE_NTFLAG ? (a & b) : 0;   
    452                          return c;   
    453                      }   
    454                      if (c <= ' ' || c == 0x7F) break;        /* Reject invisible chars */   
    455                      if (c == '.') {   
    456                          if (!(a & 1) && n >= 1 && n <= 8) {   /* Enter extension part */   
   \                     ??make_dirfile_1: (+1)
   \   0000001A   0x07D8             LSLS     R0,R3,#+31
   \   0000001C   0xD457             BMI.N    ??make_dirfile_2
   \   0000001E   0x2A00             CMP      R2,#+0
   \   00000020   0xD055             BEQ.N    ??make_dirfile_2
   \   00000022   0x2A09             CMP      R2,#+9
   \   00000024   0xDA53             BGE.N    ??make_dirfile_2
    457                              n = 8; t = 11; continue;   
   \   00000026   0x2208             MOVS     R2,#+8
   \   00000028   0x260B             MOVS     R6,#+11
    458                          }   
    459                          break;   
    460                      }   
   \                     ??make_dirfile_0: (+1)
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x1C47             ADDS     R7,R0,#+1
   \   0000002E   0x6027             STR      R7,[R4, #+0]
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xBF18             IT       NE 
   \   00000036   0x282F             CMPNE    R0,#+47
   \   00000038   0xD104             BNE.N    ??make_dirfile_3
   \   0000003A   0x2A00             CMP      R2,#+0
   \   0000003C   0xD047             BEQ.N    ??make_dirfile_2
   \   0000003E   0x4019             ANDS     R1,R1,R3
   \   00000040   0x72E9             STRB     R1,[R5, #+11]
   \   00000042   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??make_dirfile_3: (+1)
   \   00000044   0x2821             CMP      R0,#+33
   \   00000046   0xDB42             BLT.N    ??make_dirfile_2
   \   00000048   0x287F             CMP      R0,#+127
   \   0000004A   0xD040             BEQ.N    ??make_dirfile_2
   \   0000004C   0x282E             CMP      R0,#+46
   \   0000004E   0xD0E4             BEQ.N    ??make_dirfile_1
    461                      if (_USE_SJIS &&   
    462                          ((c >= 0x81 && c <= 0x9F) ||  /* Accept S-JIS code */   
    463                          (c >= 0xE0 && c <= 0xFC))) {   
   \   00000050   0xF1A0 0x0781      SUB      R7,R0,#+129
   \   00000054   0x2F1F             CMP      R7,#+31
   \   00000056   0xBF24             ITT      CS 
   \   00000058   0xF1A0 0x07E0      SUBCS    R7,R0,#+224
   \   0000005C   0x2F1D             CMPCS    R7,#+29
   \   0000005E   0xD206             BCS.N    ??make_dirfile_4
    464                          if (n == 0 && c == 0xE5)        /* Change heading \xE5 to \x05 */   
   \   00000060   0x2A00             CMP      R2,#+0
   \   00000062   0xBF04             ITT      EQ 
   \   00000064   0x28E5             CMPEQ    R0,#+229
   \   00000066   0x2005             MOVEQ    R0,#+5
    465                              c = 0x05;   
    466                          a ^= 0x01; goto md_l2;   
   \   00000068   0xF083 0x0301      EOR      R3,R3,#0x1
   \   0000006C   0xE029             B.N      ??make_dirfile_5
    467                      }   
    468                      if (c == '"') break;                /* Reject " */   
   \                     ??make_dirfile_4: (+1)
   \   0000006E   0x2822             CMP      R0,#+34
   \   00000070   0xD02D             BEQ.N    ??make_dirfile_2
    469                      if (c <= ')') goto md_l1;            /* Accept ! # $ % & ' ( ) */   
   \   00000072   0x282A             CMP      R0,#+42
   \   00000074   0xDB23             BLT.N    ??make_dirfile_6
    470                      if (c <= ',') break;             /* Reject * + , */   
   \   00000076   0x282D             CMP      R0,#+45
   \   00000078   0xDB29             BLT.N    ??make_dirfile_2
    471                      if (c <= '9') goto md_l1;            /* Accept - 0-9 */   
   \   0000007A   0x283A             CMP      R0,#+58
   \   0000007C   0xDB1F             BLT.N    ??make_dirfile_6
    472                      if (c <= '?') break;             /* Reject : ; < = > ? */   
   \   0000007E   0x2840             CMP      R0,#+64
   \   00000080   0xDB25             BLT.N    ??make_dirfile_2
    473                      if (!(a & 1)) { /* These checks are not applied to S-JIS 2nd byte */   
   \   00000082   0x07DF             LSLS     R7,R3,#+31
   \   00000084   0xD41B             BMI.N    ??make_dirfile_6
    474                          if (c == '|') break;            /* Reject | */   
   \   00000086   0x287C             CMP      R0,#+124
   \   00000088   0xD021             BEQ.N    ??make_dirfile_2
    475                          if (c >= '[' && c <= ']') break;/* Reject [ \ ] */   
   \   0000008A   0xF1A0 0x075B      SUB      R7,R0,#+91
   \   0000008E   0x2F03             CMP      R7,#+3
   \   00000090   0xD31D             BCC.N    ??make_dirfile_2
    476                          if (_USE_NTFLAG && c >= 'A' && c <= 'Z')   
   \   00000092   0xF1A0 0x0741      SUB      R7,R0,#+65
   \   00000096   0x2F1A             CMP      R7,#+26
   \   00000098   0xD205             BCS.N    ??make_dirfile_7
    477                              (t == 8) ? (b &= 0xF7) : (b &= 0xEF);   
   \   0000009A   0x2E08             CMP      R6,#+8
   \   0000009C   0xBF0C             ITE      EQ 
   \   0000009E   0xF001 0x01F7      ANDEQ    R1,R1,#0xF7
   \   000000A2   0xF001 0x01EF      ANDNE    R1,R1,#0xEF
    478                          if (c >= 'a' && c <= 'z') {       /* Convert to upper case */   
   \                     ??make_dirfile_7: (+1)
   \   000000A6   0xF1A0 0x0761      SUB      R7,R0,#+97
   \   000000AA   0x2F1A             CMP      R7,#+26
   \   000000AC   0xD207             BCS.N    ??make_dirfile_6
    479                              c -= 0x20;   
   \   000000AE   0x3820             SUBS     R0,R0,#+32
    480                              if (_USE_NTFLAG) (t == 8) ? (a |= 0x08) : (a |= 0x10);   
   \   000000B0   0x2E08             CMP      R6,#+8
   \   000000B2   0xB2C0             UXTB     R0,R0
   \   000000B4   0xBF0C             ITE      EQ 
   \   000000B6   0xF043 0x0308      ORREQ    R3,R3,#0x8
   \   000000BA   0xF043 0x0310      ORRNE    R3,R3,#0x10
    481                          }   
    482                      }   
    483                  md_l1:   
    484                      a &= 0xFE;   
   \                     ??make_dirfile_6: (+1)
   \   000000BE   0xF003 0x03FE      AND      R3,R3,#0xFE
    485                  md_l2:   
    486                      if (n >= t) break;   
   \                     ??make_dirfile_5: (+1)
   \   000000C2   0x42B2             CMP      R2,R6
   \   000000C4   0xBFBE             ITTT     LT 
   \   000000C6   0x5550             STRBLT   R0,[R2, R5]
   \   000000C8   0x1C52             ADDLT    R2,R2,#+1
   \   000000CA   0xB2D2             UXTBLT   R2,R2
    487                      dirname[n++] = c;   
   \   000000CC   0xDBAD             BLT.N    ??make_dirfile_0
    488                  }   
    489                  return 1;   
   \                     ??make_dirfile_2: (+1)
   \   000000CE   0x2001             MOVS     R0,#+1
   \   000000D0   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    490              }   
    491                 
    492                 
    493                 
    494                 
    495              /*-----------------------------------------------------------------------*/   
    496              /* Trace a file path                                                     */   
    497              /*-----------------------------------------------------------------------*/   
    498                 

   \                                 In section .text, align 2, keep-with-next
    499              static   
    500              FRESULT trace_path (    /* FR_OK(0): successful, !=0: error code */   
    501                  DIR *dj,            /* Pointer to directory object to return last directory */   
    502                  char *fn,           /* Pointer to last segment name to return {file(8),ext(3),attr(1)} */   
    503                  const char *path,   /* Full-path string to trace a file or directory */   
    504                  BYTE **dir          /* Pointer to pointer to found entry to retutn */   
    505              )   
    506              {   
   \                     trace_path: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
    507                  DWORD clust;   
    508                  char ds;   
    509                  BYTE *dptr = NULL;   
    510                  FATFS *fs = dj->fs;   
   \   00000006   0xF8D4 0x9004      LDR      R9,[R4, #+4]
    511                 
    512                 
    513                  /* Initialize directory object */   
    514                  clust = fs->dirbase;   
    515                  if (fs->fs_type == FS_FAT32) {   
   \   0000000A   0xF109 0x072A      ADD      R7,R9,#+42
   \   0000000E   0xF109 0x0604      ADD      R6,R9,#+4
   \   00000012   0x783A             LDRB     R2,[R7, #+0]
   \   00000014   0x6930             LDR      R0,[R6, #+16]
   \   00000016   0x2A03             CMP      R2,#+3
   \   00000018   0x4601             MOV      R1,R0
   \   0000001A   0xD106             BNE.N    ??trace_path_0
    516                      dj->clust = dj->sclust = clust;   
   \   0000001C   0x60E0             STR      R0,[R4, #+12]
   \   0000001E   0x60A1             STR      R1,[R4, #+8]
    517                      dj->sect = clust2sect(fs, clust);   
   \   00000020   0x4648             MOV      R0,R9
   \   00000022   0x.... 0x....      BL       clust2sect
   \   00000026   0x6120             STR      R0,[R4, #+16]
   \   00000028   0xE003             B.N      ??trace_path_1
    518                  } else {   
    519                      dj->clust = dj->sclust = 0;   
   \                     ??trace_path_0: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x60A0             STR      R0,[R4, #+8]
   \   0000002E   0x60E0             STR      R0,[R4, #+12]
    520                      dj->sect = clust;   
   \   00000030   0x6121             STR      R1,[R4, #+16]
    521                  }   
    522                  dj->index = 0;   
   \                     ??trace_path_1: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x8060             STRH     R0,[R4, #+2]
    523                 
    524                  if (*path == '\0') {                    /* Null path means the root directory */   
   \   00000036   0x9801             LDR      R0,[SP, #+4]
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0xB928             CBNZ.N   R0,??trace_path_2
    525                      *dir = NULL; return FR_OK;   
   \   0000003C   0x9902             LDR      R1,[SP, #+8]
   \   0000003E   0x6008             STR      R0,[R1, #+0]
   \   00000040   0x....             B.N      ?Subroutine4
    526                  }   
    527                 
    528                  for (;;) {   
    529                      ds = make_dirfile(&path, fn);           /* Get a paragraph into fn[] */   
    530                      if (ds == 1) return FR_INVALID_NAME;   
    531                      for (;;) {   
    532                          if (!move_window(fs, dj->sect)) return FR_RW_ERROR;   
    533                          dptr = &fs->win[(dj->index & ((SS(fs) - 1) / 32)) * 32];  /* Pointer to the directory entry */   
    534                          if (dptr[DIR_Name] == 0)                        /* Has it reached to end of dir? */   
    535                              return !ds ? FR_NO_FILE : FR_NO_PATH;   
    536                          if (dptr[DIR_Name] != 0xE5                      /* Matched? */   
    537                              && !(dptr[DIR_Attr] & AM_VOL)   
    538                              && !memcmp(&dptr[DIR_Name], fn, 8+3) ) break;   
    539                          if (!next_dir_entry(dj))                        /* Next directory pointer */   
    540                              return !ds ? FR_NO_FILE : FR_NO_PATH;   
    541                      }   
    542                      if (!ds) { *dir = dptr; return FR_OK; }             /* Matched with end of path */   
    543                      if (!(dptr[DIR_Attr] & AM_DIR)) return FR_NO_PATH;  /* Cannot trace because it is a file */   
    544                      clust = ((DWORD)LD_WORD(&dptr[DIR_FstClusHI]) << 16) | LD_WORD(&dptr[DIR_FstClusLO]); /* Get cluster# of the directory */   
    545                      dj->clust = dj->sclust = clust;               /* Restart scanning at the new directory */   
    546                      dj->sect = clust2sect(fs, clust);   
   \                     ??trace_path_3: (+1)
   \   00000042   0x6120             STR      R0,[R4, #+16]
    547                      dj->index = 2;   
   \   00000044   0x2002             MOVS     R0,#+2
   \   00000046   0x8060             STRH     R0,[R4, #+2]
   \                     ??trace_path_2: (+1)
   \   00000048   0xA801             ADD      R0,SP,#+4
   \   0000004A   0x9900             LDR      R1,[SP, #+0]
   \   0000004C   0x.... 0x....      BL       make_dirfile
   \   00000050   0x4680             MOV      R8,R0
   \   00000052   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000056   0xD14D             BNE.N    ??trace_path_4
   \   00000058   0x2004             MOVS     R0,#+4
   \   0000005A   0x....             B.N      ?Subroutine4
   \                     ??trace_path_5: (+1)
   \   0000005C   0x6035             STR      R5,[R6, #+0]
   \                     ??trace_path_6: (+1)
   \   0000005E   0x8865             LDRH     R5,[R4, #+2]
   \   00000060   0xF005 0x000F      AND      R0,R5,#0xF
   \   00000064   0xEB09 0x1040      ADD      R0,R9,R0, LSL #+5
   \   00000068   0xF100 0x0A30      ADD      R10,R0,#+48
   \   0000006C   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   00000070   0xB930             CBNZ.N   R0,??trace_path_7
   \   00000072   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000076   0xD101             BNE.N    ??trace_path_8
   \                     ??trace_path_9: (+1)
   \   00000078   0x2002             MOVS     R0,#+2
   \   0000007A   0x....             B.N      ?Subroutine4
   \                     ??trace_path_8: (+1)
   \   0000007C   0x2003             MOVS     R0,#+3
   \   0000007E   0x....             B.N      ?Subroutine4
   \                     ??trace_path_7: (+1)
   \   00000080   0x28E5             CMP      R0,#+229
   \   00000082   0xD011             BEQ.N    ??trace_path_10
   \   00000084   0xF89A 0x000B      LDRB     R0,[R10, #+11]
   \   00000088   0x0700             LSLS     R0,R0,#+28
   \   0000008A   0xD40D             BMI.N    ??trace_path_10
   \   0000008C   0x9900             LDR      R1,[SP, #+0]
   \   0000008E   0x220B             MOVS     R2,#+11
   \   00000090   0x4650             MOV      R0,R10
   \   00000092   0x.... 0x....      BL       memcmp
   \   00000096   0xB938             CBNZ.N   R0,??trace_path_10
   \   00000098   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000009C   0xD15D             BNE.N    ??trace_path_11
   \   0000009E   0x9802             LDR      R0,[SP, #+8]
   \   000000A0   0xF8C0 0xA000      STR      R10,[R0, #+0]
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x....             B.N      ?Subroutine4
   \                     ??trace_path_10: (+1)
   \   000000A8   0x1C6D             ADDS     R5,R5,#+1
   \   000000AA   0xB2AD             UXTH     R5,R5
   \   000000AC   0xF015 0x0F0F      TST      R5,#0xF
   \   000000B0   0xD11F             BNE.N    ??trace_path_12
   \   000000B2   0x6920             LDR      R0,[R4, #+16]
   \   000000B4   0x68E1             LDR      R1,[R4, #+12]
   \   000000B6   0x1C40             ADDS     R0,R0,#+1
   \   000000B8   0x6120             STR      R0,[R4, #+16]
   \   000000BA   0x6860             LDR      R0,[R4, #+4]
   \   000000BC   0xB931             CBNZ.N   R1,??trace_path_13
   \   000000BE   0x8840             LDRH     R0,[R0, #+2]
   \   000000C0   0x4285             CMP      R5,R0
   \   000000C2   0xDB16             BLT.N    ??trace_path_12
   \                     ??trace_path_14: (+1)
   \   000000C4   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000C8   0xD1D8             BNE.N    ??trace_path_8
   \   000000CA   0xE7D5             B.N      ??trace_path_9
   \                     ??trace_path_13: (+1)
   \   000000CC   0xF890 0x202B      LDRB     R2,[R0, #+43]
   \   000000D0   0x1E52             SUBS     R2,R2,#+1
   \   000000D2   0xEA12 0x1F15      TST      R2,R5, LSR #+4
   \   000000D6   0xD10C             BNE.N    ??trace_path_12
   \   000000D8   0x.... 0x....      BL       get_cluster
   \   000000DC   0x4601             MOV      R1,R0
   \   000000DE   0x2902             CMP      R1,#+2
   \   000000E0   0xD3F0             BCC.N    ??trace_path_14
   \   000000E2   0x6860             LDR      R0,[R4, #+4]
   \   000000E4   0x68C2             LDR      R2,[R0, #+12]
   \   000000E6   0x4291             CMP      R1,R2
   \   000000E8   0xD2EC             BCS.N    ??trace_path_14
   \   000000EA   0x60E1             STR      R1,[R4, #+12]
   \   000000EC   0x.... 0x....      BL       clust2sect
   \   000000F0   0x6120             STR      R0,[R4, #+16]
   \                     ??trace_path_12: (+1)
   \   000000F2   0x8065             STRH     R5,[R4, #+2]
   \                     ??trace_path_4: (+1)
   \   000000F4   0x6925             LDR      R5,[R4, #+16]
   \   000000F6   0xF8D6 0xA000      LDR      R10,[R6, #+0]
   \   000000FA   0x45AA             CMP      R10,R5
   \   000000FC   0xD0AF             BEQ.N    ??trace_path_6
   \   000000FE   0x7938             LDRB     R0,[R7, #+4]
   \   00000100   0xB1F0             CBZ.N    R0,??trace_path_15
   \   00000102   0x78F8             LDRB     R0,[R7, #+3]
   \   00000104   0x2301             MOVS     R3,#+1
   \   00000106   0x4652             MOV      R2,R10
   \   00000108   0xF109 0x0130      ADD      R1,R9,#+48
   \   0000010C   0x.... 0x....      BL       disk_write
   \   00000110   0xBB08             CBNZ.N   R0,??trace_path_16
   \   00000112   0x7138             STRB     R0,[R7, #+4]
   \   00000114   0x6871             LDR      R1,[R6, #+4]
   \   00000116   0x68F0             LDR      R0,[R6, #+12]
   \   00000118   0x1808             ADDS     R0,R1,R0
   \   0000011A   0x4582             CMP      R10,R0
   \   0000011C   0xD210             BCS.N    ??trace_path_15
   \   0000011E   0x78B8             LDRB     R0,[R7, #+2]
   \   00000120   0x2802             CMP      R0,#+2
   \   00000122   0xDB0D             BLT.N    ??trace_path_15
   \   00000124   0xF1A0 0x0B01      SUB      R11,R0,#+1
   \                     ??trace_path_17: (+1)
   \   00000128   0x6870             LDR      R0,[R6, #+4]
   \   0000012A   0x4482             ADD      R10,R0,R10
   \   0000012C   0x78F8             LDRB     R0,[R7, #+3]
   \   0000012E   0x2301             MOVS     R3,#+1
   \   00000130   0x4652             MOV      R2,R10
   \   00000132   0xF109 0x0130      ADD      R1,R9,#+48
   \   00000136   0x.... 0x....      BL       disk_write
   \   0000013A   0xF1BB 0x0B01      SUBS     R11,R11,#+1
   \   0000013E   0xD1F3             BNE.N    ??trace_path_17
   \                     ??trace_path_15: (+1)
   \   00000140   0x2D00             CMP      R5,#+0
   \   00000142   0xD08C             BEQ.N    ??trace_path_6
   \   00000144   0x78F8             LDRB     R0,[R7, #+3]
   \   00000146   0x2301             MOVS     R3,#+1
   \   00000148   0x462A             MOV      R2,R5
   \   0000014A   0xF109 0x0130      ADD      R1,R9,#+48
   \   0000014E   0x.... 0x....      BL       disk_read
   \   00000152   0x2800             CMP      R0,#+0
   \   00000154   0xD082             BEQ.N    ??trace_path_5
   \                     ??trace_path_16: (+1)
   \   00000156   0x2008             MOVS     R0,#+8
   \   00000158   0x....             B.N      ?Subroutine4
   \                     ??trace_path_11: (+1)
   \   0000015A   0xF89A 0x000B      LDRB     R0,[R10, #+11]
   \   0000015E   0x06C0             LSLS     R0,R0,#+27
   \   00000160   0xD58C             BPL.N    ??trace_path_8
   \   00000162   0xF8BA 0x0014      LDRH     R0,[R10, #+20]
   \   00000166   0xF8BA 0x101A      LDRH     R1,[R10, #+26]
   \   0000016A   0xEA41 0x4100      ORR      R1,R1,R0, LSL #+16
   \   0000016E   0x60A1             STR      R1,[R4, #+8]
   \   00000170   0x60E1             STR      R1,[R4, #+12]
   \   00000172   0x1E88             SUBS     R0,R1,#+2
   \   00000174   0x68B1             LDR      R1,[R6, #+8]
   \   00000176   0x1E89             SUBS     R1,R1,#+2
   \   00000178   0x4288             CMP      R0,R1
   \   0000017A   0xBF2F             ITEEE    CS 
   \   0000017C   0x2000             MOVCS    R0,#+0
   \   0000017E   0x7879             LDRBCC   R1,[R7, #+1]
   \   00000180   0x6972             LDRCC    R2,[R6, #+20]
   \   00000182   0xFB01 0x2000      MLACC    R0,R1,R0,R2
   \   00000186   0xE75C             B.N      ??trace_path_3
    548                  }   
    549              }   

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0xB003             ADD      SP,SP,#+12
   \   00000002   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    550                 
    551                 
    552                 
    553                 
    554              /*-----------------------------------------------------------------------*/   
    555              /* Reserve a directory entry                                             */   
    556              /*-----------------------------------------------------------------------*/   
    557                 
    558              #if !_FS_READONLY   

   \                                 In section .text, align 2, keep-with-next
    559              static   
    560              FRESULT reserve_direntry (  /* FR_OK: successful, FR_DENIED: no free entry, FR_RW_ERROR: a disk error occured */   
    561                  DIR *dj,                /* Target directory to create new entry */   
    562                  BYTE **dir              /* Pointer to pointer to created entry to retutn */   
    563              )   
    564              {   
   \                     reserve_direntry: (+1)
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0x4607             MOV      R7,R0
    565                  DWORD clust, sector;   
    566                  BYTE c, n, *dptr;   
    567                  FATFS *fs = dj->fs;   
   \   00000006   0xF8D7 0x8004      LDR      R8,[R7, #+4]
    568                 
    569                 
    570                  /* Re-initialize directory object */   
    571                  clust = dj->sclust;   
   \   0000000A   0x68BC             LDR      R4,[R7, #+8]
    572                  if (clust != 0) {   /* Dyanmic directory table */   
   \   0000000C   0xB12C             CBZ.N    R4,??reserve_direntry_0
    573                      dj->clust = clust;   
   \   0000000E   0x60FC             STR      R4,[R7, #+12]
    574                      dj->sect = clust2sect(fs, clust);   
   \   00000010   0x4621             MOV      R1,R4
   \   00000012   0x4640             MOV      R0,R8
   \   00000014   0x.... 0x....      BL       clust2sect
   \   00000018   0xE002             B.N      ??reserve_direntry_1
    575                  } else {            /* Static directory table */   
    576                      dj->sect = fs->dirbase;   
   \                     ??reserve_direntry_0: (+1)
   \   0000001A   0xF108 0x0004      ADD      R0,R8,#+4
   \   0000001E   0x6900             LDR      R0,[R0, #+16]
   \                     ??reserve_direntry_1: (+1)
   \   00000020   0x6138             STR      R0,[R7, #+16]
    577                  }   
    578                  dj->index = 0;   
   \   00000022   0xF108 0x062B      ADD      R6,R8,#+43
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x8078             STRH     R0,[R7, #+2]
   \   0000002A   0xF108 0x0504      ADD      R5,R8,#+4
    579                 
    580                  do {   
    581                      if (!move_window(fs, dj->sect)) return FR_RW_ERROR;   
   \                     ??reserve_direntry_2: (+1)
   \   0000002E   0xF8D7 0x9010      LDR      R9,[R7, #+16]
   \   00000032   0xF8D5 0xA000      LDR      R10,[R5, #+0]
   \   00000036   0x45CA             CMP      R10,R9
   \   00000038   0xD02F             BEQ.N    ??reserve_direntry_3
   \   0000003A   0x78F0             LDRB     R0,[R6, #+3]
   \   0000003C   0xB1F8             CBZ.N    R0,??reserve_direntry_4
   \   0000003E   0x78B0             LDRB     R0,[R6, #+2]
   \   00000040   0x2301             MOVS     R3,#+1
   \   00000042   0x4652             MOV      R2,R10
   \   00000044   0xF108 0x0130      ADD      R1,R8,#+48
   \   00000048   0x.... 0x....      BL       disk_write
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD17B             BNE.N    ??reserve_direntry_5
   \   00000050   0x70F0             STRB     R0,[R6, #+3]
   \   00000052   0x6869             LDR      R1,[R5, #+4]
   \   00000054   0x68E8             LDR      R0,[R5, #+12]
   \   00000056   0x1808             ADDS     R0,R1,R0
   \   00000058   0x4582             CMP      R10,R0
   \   0000005A   0xD210             BCS.N    ??reserve_direntry_4
   \   0000005C   0x7870             LDRB     R0,[R6, #+1]
   \   0000005E   0x2802             CMP      R0,#+2
   \   00000060   0xDB0D             BLT.N    ??reserve_direntry_4
   \   00000062   0xF1A0 0x0B01      SUB      R11,R0,#+1
   \                     ??reserve_direntry_6: (+1)
   \   00000066   0x6868             LDR      R0,[R5, #+4]
   \   00000068   0x4482             ADD      R10,R0,R10
   \   0000006A   0x78B0             LDRB     R0,[R6, #+2]
   \   0000006C   0x2301             MOVS     R3,#+1
   \   0000006E   0x4652             MOV      R2,R10
   \   00000070   0xF108 0x0130      ADD      R1,R8,#+48
   \   00000074   0x.... 0x....      BL       disk_write
   \   00000078   0xF1BB 0x0B01      SUBS     R11,R11,#+1
   \   0000007C   0xD1F3             BNE.N    ??reserve_direntry_6
   \                     ??reserve_direntry_4: (+1)
   \   0000007E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000082   0xD00A             BEQ.N    ??reserve_direntry_3
   \   00000084   0x78B0             LDRB     R0,[R6, #+2]
   \   00000086   0x2301             MOVS     R3,#+1
   \   00000088   0x464A             MOV      R2,R9
   \   0000008A   0xF108 0x0130      ADD      R1,R8,#+48
   \   0000008E   0x.... 0x....      BL       disk_read
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD158             BNE.N    ??reserve_direntry_5
   \   00000096   0xF8C5 0x9000      STR      R9,[R5, #+0]
    582                      dptr = &fs->win[(dj->index & ((SS(dj->fs) - 1) / 32)) * 32];   /* Pointer to the directory entry */   
   \                     ??reserve_direntry_3: (+1)
   \   0000009A   0x78B8             LDRB     R0,[R7, #+2]
   \   0000009C   0xF000 0x000F      AND      R0,R0,#0xF
   \   000000A0   0xEB08 0x1040      ADD      R0,R8,R0, LSL #+5
    583                      c = dptr[DIR_Name];   
   \   000000A4   0xF810 0x1F30      LDRB     R1,[R0, #+48]!
    584                      if (c == 0 || c == 0xE5) {      /* Found an empty entry */   
   \   000000A8   0x2900             CMP      R1,#+0
   \   000000AA   0xBF18             IT       NE 
   \   000000AC   0x29E5             CMPNE    R1,#+229
   \   000000AE   0xD055             BEQ.N    ??reserve_direntry_7
    585                          *dir = dptr; return FR_OK;   
    586                      }   
    587                  } while (next_dir_entry(dj));       /* Next directory pointer */   
   \   000000B0   0x4638             MOV      R0,R7
   \   000000B2   0x.... 0x....      BL       next_dir_entry
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD1B9             BNE.N    ??reserve_direntry_2
    588                  /* Reached to end of the directory table */   
    589                 
    590                  /* Abort when it is a static table or could not stretch dynamic table */   
    591                  if (clust == 0 || !(clust = create_chain(fs, dj->clust))) return FR_DENIED;   
   \   000000BA   0xB12C             CBZ.N    R4,??reserve_direntry_8
   \   000000BC   0x68F9             LDR      R1,[R7, #+12]
   \   000000BE   0x4640             MOV      R0,R8
   \   000000C0   0x.... 0x....      BL       create_chain
   \   000000C4   0x0007             MOVS     R7,R0
   \   000000C6   0xD102             BNE.N    ??reserve_direntry_9
   \                     ??reserve_direntry_8: (+1)
   \   000000C8   0x2006             MOVS     R0,#+6
   \   000000CA   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    592                  if (clust == 1 || !move_window(fs, 0)) return FR_RW_ERROR;   
   \                     ??reserve_direntry_9: (+1)
   \   000000CE   0x2F01             CMP      R7,#+1
   \   000000D0   0xD03A             BEQ.N    ??reserve_direntry_5
   \   000000D2   0x682C             LDR      R4,[R5, #+0]
   \   000000D4   0x2C00             CMP      R4,#+0
   \   000000D6   0xBF1C             ITT      NE 
   \   000000D8   0x78F0             LDRBNE   R0,[R6, #+3]
   \   000000DA   0x2800             CMPNE    R0,#+0
   \   000000DC   0xD01E             BEQ.N    ??reserve_direntry_10
   \   000000DE   0x78B0             LDRB     R0,[R6, #+2]
   \   000000E0   0x2301             MOVS     R3,#+1
   \   000000E2   0x4622             MOV      R2,R4
   \   000000E4   0xF108 0x0130      ADD      R1,R8,#+48
   \   000000E8   0x.... 0x....      BL       disk_write
   \   000000EC   0xBB60             CBNZ.N   R0,??reserve_direntry_5
   \   000000EE   0x70F0             STRB     R0,[R6, #+3]
   \   000000F0   0x6869             LDR      R1,[R5, #+4]
   \   000000F2   0x68E8             LDR      R0,[R5, #+12]
   \   000000F4   0x1808             ADDS     R0,R1,R0
   \   000000F6   0x4284             CMP      R4,R0
   \   000000F8   0xD210             BCS.N    ??reserve_direntry_10
   \   000000FA   0x7870             LDRB     R0,[R6, #+1]
   \   000000FC   0x2802             CMP      R0,#+2
   \   000000FE   0xDB0D             BLT.N    ??reserve_direntry_10
   \   00000100   0xF1A0 0x0901      SUB      R9,R0,#+1
   \                     ??reserve_direntry_11: (+1)
   \   00000104   0x6868             LDR      R0,[R5, #+4]
   \   00000106   0x1904             ADDS     R4,R0,R4
   \   00000108   0x78B0             LDRB     R0,[R6, #+2]
   \   0000010A   0x2301             MOVS     R3,#+1
   \   0000010C   0x4622             MOV      R2,R4
   \   0000010E   0xF108 0x0130      ADD      R1,R8,#+48
   \   00000112   0x.... 0x....      BL       disk_write
   \   00000116   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \   0000011A   0xD1F3             BNE.N    ??reserve_direntry_11
    593                 
    594                  /* Cleanup the expanded table */   
    595                  fs->winsect = sector = clust2sect(fs, clust);   
   \                     ??reserve_direntry_10: (+1)
   \   0000011C   0x4639             MOV      R1,R7
   \   0000011E   0x4640             MOV      R0,R8
   \   00000120   0x.... 0x....      BL       clust2sect
   \   00000124   0x4607             MOV      R7,R0
   \   00000126   0x602F             STR      R7,[R5, #+0]
    596                  memset(fs->win, 0, SS(fs));   
   \   00000128   0xF44F 0x7100      MOV      R1,#+512
   \   0000012C   0xF108 0x0030      ADD      R0,R8,#+48
   \   00000130   0x.... 0x....      BL       __aeabi_memclr4
    597                  for (n = fs->csize; n; n--) {   
   \   00000134   0x7835             LDRB     R5,[R6, #+0]
   \   00000136   0xB16D             CBZ.N    R5,??reserve_direntry_12
    598                      if (disk_write(fs->drive, fs->win, sector, 1) != RES_OK)   
   \                     ??reserve_direntry_13: (+1)
   \   00000138   0x78B0             LDRB     R0,[R6, #+2]
   \   0000013A   0x2301             MOVS     R3,#+1
   \   0000013C   0x463A             MOV      R2,R7
   \   0000013E   0xF108 0x0130      ADD      R1,R8,#+48
   \   00000142   0x.... 0x....      BL       disk_write
   \   00000146   0xB110             CBZ.N    R0,??reserve_direntry_14
    599                          return FR_RW_ERROR;   
   \                     ??reserve_direntry_5: (+1)
   \   00000148   0x2008             MOVS     R0,#+8
   \   0000014A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    600                      sector++;   
   \                     ??reserve_direntry_14: (+1)
   \   0000014E   0x1C7F             ADDS     R7,R7,#+1
    601                  }   
   \   00000150   0x1E6D             SUBS     R5,R5,#+1
   \   00000152   0xD1F1             BNE.N    ??reserve_direntry_13
    602                  fs->winflag = 1;   
   \                     ??reserve_direntry_12: (+1)
   \   00000154   0x2001             MOVS     R0,#+1
   \   00000156   0x70F0             STRB     R0,[R6, #+3]
    603                  *dir = fs->win;   
   \   00000158   0xF108 0x0030      ADD      R0,R8,#+48
   \                     ??reserve_direntry_7: (+1)
   \   0000015C   0x9900             LDR      R1,[SP, #+0]
   \   0000015E   0x6008             STR      R0,[R1, #+0]
    604                 
    605                  return FR_OK;   
   \   00000160                      REQUIRE ?Subroutine3
   \   00000160                      ;; // Fall through to label ?Subroutine3
    606              }   
    607              #endif /* !_FS_READONLY */   
    608                 
    609                 
    610                 
    611                 
    612              /*-----------------------------------------------------------------------*/   
    613              /* Load boot record and check if it is an FAT boot record                */   
    614              /*-----------------------------------------------------------------------*/   
    615                 

   \                                 In section .text, align 2, keep-with-next
    616              static   
    617              BYTE check_fs ( /* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record or error */   
    618                  FATFS *fs,  /* File system object */   
    619                  DWORD sect  /* Sector# (lba) to check if it is an FAT boot record or not */   
    620              )   
    621              {   
   \                     check_fs: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    622                  if (disk_read(fs->drive, fs->win, sect, 1) != RES_OK) /* Load boot record */   
   \   00000004   0x460A             MOV      R2,R1
   \   00000006   0xF894 0x002D      LDRB     R0,[R4, #+45]
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0xF104 0x0130      ADD      R1,R4,#+48
   \   00000010   0x.... 0x....      BL       disk_read
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xBF02             ITTT     EQ 
   \   00000018   0xF8B4 0x022E      LDRHEQ   R0,[R4, #+558]
   \   0000001C   0xF64A 0x2155      MOVWEQ   R1,#+43605
   \   00000020   0x4288             CMPEQ    R0,R1
    623                      return 2;   
    624                  if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)                /* Check record signature (always placed at offset 510 even if the sector size is >512) */   
   \   00000022   0xD001             BEQ.N    ??check_fs_0
    625                      return 2;   
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xBD10             POP      {R4,PC}
    626                 
    627                  if (!memcmp(&fs->win[BS_FilSysType], "FAT", 3))          /* Check FAT signature */   
   \                     ??check_fs_0: (+1)
   \   00000028   0x2203             MOVS     R2,#+3
   \   0000002A   0x....             ADR.N    R1,??DataTable7_1  ;; "FAT"
   \   0000002C   0xF104 0x0066      ADD      R0,R4,#+102
   \   00000030   0x.... 0x....      BL       memcmp
   \   00000034   0xB158             CBZ.N    R0,??check_fs_1
    628                      return 0;   
    629                  if (!memcmp(&fs->win[BS_FilSysType32], "FAT32", 5) && !(fs->win[BPB_ExtFlags] & 0x80))   
   \   00000036   0x2205             MOVS     R2,#+5
   \   00000038   0x.... 0x....      ADR.W    R1,?_1
   \   0000003C   0xF104 0x0082      ADD      R0,R4,#+130
   \   00000040   0x.... 0x....      BL       memcmp
   \   00000044   0xB928             CBNZ.N   R0,??check_fs_2
   \   00000046   0xF894 0x0058      LDRB     R0,[R4, #+88]
   \   0000004A   0x0600             LSLS     R0,R0,#+24
   \   0000004C   0xD401             BMI.N    ??check_fs_2
    630                      return 0;   
   \                     ??check_fs_1: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xBD10             POP      {R4,PC}
    631                 
    632                  return 1;   
   \                     ??check_fs_2: (+1)
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xBD10             POP      {R4,PC}          ;; return
    633              }   
    634                 
    635                 
    636                 
    637                 
    638              /*-----------------------------------------------------------------------*/   
    639              /* Make sure that the file system is valid                               */   
    640              /*-----------------------------------------------------------------------*/   
    641                 

   \                                 In section .text, align 2, keep-with-next
    642              static   
    643              FRESULT auto_mount (    /* FR_OK(0): successful, !=0: any error occured */   
    644                  const char **path,  /* Pointer to pointer to the path name (drive number) */   
    645                  FATFS **rfs,        /* Pointer to pointer to the found file system object */   
    646                  BYTE chk_wp         /* !=0: Check media write protection for write access */   
    647              )   
    648              {   
   \                     auto_mount: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4617             MOV      R7,R2
    649                  BYTE drv, fmt, *tbl;   
    650                  DSTATUS stat;   
    651                  DWORD bootsect, fatsize, totalsect, maxclust;   
    652                  const char *p = *path;   
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0xE000             B.N      ??auto_mount_0
    653                  FATFS *fs;   
    654                 
    655                 
    656                  /* Get drive number from the path name */   
    657                  while (*p == ' ') p++;      /* Strip leading spaces */   
   \                     ??auto_mount_1: (+1)
   \   0000000A   0x1C52             ADDS     R2,R2,#+1
   \                     ??auto_mount_0: (+1)
   \   0000000C   0x7813             LDRB     R3,[R2, #+0]
   \   0000000E   0x2B20             CMP      R3,#+32
   \   00000010   0xD0FB             BEQ.N    ??auto_mount_1
    658                  drv = p[0] - '0';           /* Is there a drive number? */   
   \   00000012   0x3B30             SUBS     R3,R3,#+48
    659                  if (drv <= 9 && p[1] == ':')   
   \   00000014   0xB2DB             UXTB     R3,R3
   \   00000016   0x2B0A             CMP      R3,#+10
   \   00000018   0xDA04             BGE.N    ??auto_mount_2
   \   0000001A   0x7854             LDRB     R4,[R2, #+1]
   \   0000001C   0x2C3A             CMP      R4,#+58
   \   0000001E   0xBF08             IT       EQ 
   \   00000020   0x1C92             ADDEQ    R2,R2,#+2
    660                      p += 2;             /* Found a drive number, get and strip it */   
   \   00000022   0xD000             BEQ.N    ??auto_mount_3
    661                  else   
    662                      drv = 0;            /* No drive number is given, use drive number 0 as default */   
   \                     ??auto_mount_2: (+1)
   \   00000024   0x2300             MOVS     R3,#+0
    663                  if (*p == '/') p++;     /* Strip heading slash */   
   \                     ??auto_mount_3: (+1)
   \   00000026   0x7814             LDRB     R4,[R2, #+0]
   \   00000028   0x2C2F             CMP      R4,#+47
   \   0000002A   0xBF08             IT       EQ 
   \   0000002C   0x1C52             ADDEQ    R2,R2,#+1
    664                  *path = p;              /* Return pointer to the path name */   
   \   0000002E   0x6002             STR      R2,[R0, #+0]
    665                 
    666                  /* Check if the drive number is valid or not */   
    667                  if (drv >= _DRIVES) return FR_INVALID_DRIVE; /* Is the drive number valid? */   
   \   00000030   0xB113             CBZ.N    R3,??auto_mount_4
   \   00000032   0x2005             MOVS     R0,#+5
   \   00000034   0xE8BD 0x87F0      POP      {R4-R10,PC}
    668                  *rfs = fs = FatFs[drv];                 /* Returen pointer to the corresponding file system object */   
   \                     ??auto_mount_4: (+1)
   \   00000038   0x....             LDR.N    R4,??DataTable7_3
   \   0000003A   0x6865             LDR      R5,[R4, #+4]
   \   0000003C   0x600D             STR      R5,[R1, #+0]
    669                  if (!fs) return FR_NOT_ENABLED;         /* Is the file system object registered? */   
   \   0000003E   0xB915             CBNZ.N   R5,??auto_mount_5
   \   00000040   0x200A             MOVS     R0,#+10
   \   00000042   0xE8BD 0x87F0      POP      {R4-R10,PC}
    670                 
    671                  if (fs->fs_type) {                       /* If the logical drive has been mounted */   
   \                     ??auto_mount_5: (+1)
   \   00000046   0xF105 0x062A      ADD      R6,R5,#+42
   \   0000004A   0x7830             LDRB     R0,[R6, #+0]
   \   0000004C   0xB150             CBZ.N    R0,??auto_mount_6
    672                      stat = disk_status(fs->drive);   
   \   0000004E   0x78F0             LDRB     R0,[R6, #+3]
   \   00000050   0x.... 0x....      BL       disk_status
    673                      if (!(stat & STA_NOINIT)) {         /* and physical drive is kept initialized (has not been changed), */   
   \   00000054   0x07C1             LSLS     R1,R0,#+31
   \   00000056   0xD405             BMI.N    ??auto_mount_6
    674              #if !_FS_READONLY   
    675                          if (chk_wp && (stat & STA_PROTECT)) /* Check write protection if needed */   
   \   00000058   0x2F00             CMP      R7,#+0
   \   0000005A   0xF000 0x80BA      BEQ.W    ??auto_mount_7
   \   0000005E   0x0740             LSLS     R0,R0,#+29
   \   00000060   0xD411             BMI.N    ??auto_mount_8
    676                              return FR_WRITE_PROTECTED;   
    677              #endif   
    678                          return FR_OK;                   /* The file system object is valid */   
   \   00000062   0xE0B6             B.N      ??auto_mount_7
    679                      }   
    680                  }   
    681                 
    682                  /* The logical drive must be re-mounted. Following code attempts to mount the logical drive */   
    683                 
    684                  memset(fs, 0, sizeof(FATFS));       /* Clean-up the file system object */   
   \                     ??auto_mount_6: (+1)
   \   00000064   0xF44F 0x710C      MOV      R1,#+560
   \   00000068   0x4628             MOV      R0,R5
   \   0000006A   0x.... 0x....      BL       __aeabi_memclr4
    685                  fs->drive = LD2PD(drv);              /* Bind the logical drive and a physical drive */   
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x70F0             STRB     R0,[R6, #+3]
    686                  stat = disk_initialize(fs->drive);   /* Initialize low level disk I/O layer */   
   \   00000072   0x.... 0x....      BL       disk_initialize
    687                  if (stat & STA_NOINIT)              /* Check if the drive is ready */   
   \   00000076   0x07C1             LSLS     R1,R0,#+31
   \   00000078   0xBF48             IT       MI 
   \   0000007A   0x2001             MOVMI    R0,#+1
    688                      return FR_NOT_READY;   
   \   0000007C   0xF100 0x80AA      BMI.W    ??auto_mount_9
    689              #if S_MAX_SIZ > 512                      /* Get disk sector size if needed */   
    690                  if (disk_ioctl(drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > S_MAX_SIZ)   
    691                      return FR_NO_FILESYSTEM;   
    692              #endif   
    693              #if !_FS_READONLY   
    694                  if (chk_wp && (stat & STA_PROTECT)) /* Check write protection if needed */   
   \   00000080   0xB127             CBZ.N    R7,??auto_mount_10
   \   00000082   0x0740             LSLS     R0,R0,#+29
   \   00000084   0xD502             BPL.N    ??auto_mount_10
    695                      return FR_WRITE_PROTECTED;   
   \                     ??auto_mount_8: (+1)
   \   00000086   0x2009             MOVS     R0,#+9
   \   00000088   0xE8BD 0x87F0      POP      {R4-R10,PC}
    696              #endif   
    697                  /* Search FAT partition on the drive */   
    698                  fmt = check_fs(fs, bootsect = 0);   /* Check sector 0 as an SFD format */   
   \                     ??auto_mount_10: (+1)
   \   0000008C   0x78F0             LDRB     R0,[R6, #+3]
   \   0000008E   0x2301             MOVS     R3,#+1
   \   00000090   0x2200             MOVS     R2,#+0
   \   00000092   0xF105 0x0130      ADD      R1,R5,#+48
   \   00000096   0x.... 0x....      BL       disk_read
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xBF01             ITTTT    EQ 
   \   0000009E   0xF505 0x7805      ADDEQ    R8,R5,#+532
   \   000000A2   0xF64A 0x2955      MOVWEQ   R9,#+43605
   \   000000A6   0xF8B8 0x001A      LDRHEQ   R0,[R8, #+26]
   \   000000AA   0x4548             CMPEQ    R0,R9
   \   000000AC   0xF04F 0x0A00      MOV      R10,#+0
   \   000000B0   0xD124             BNE.N    ??auto_mount_11
   \   000000B2   0x2203             MOVS     R2,#+3
   \   000000B4   0x....             ADR.N    R1,??DataTable7_1  ;; "FAT"
   \   000000B6   0xF105 0x0066      ADD      R0,R5,#+102
   \   000000BA   0x.... 0x....      BL       memcmp
   \   000000BE   0xB1B8             CBZ.N    R0,??auto_mount_12
   \   000000C0   0x2205             MOVS     R2,#+5
   \   000000C2   0x.... 0x....      ADR.W    R1,?_1
   \   000000C6   0xF105 0x0082      ADD      R0,R5,#+130
   \   000000CA   0x.... 0x....      BL       memcmp
   \   000000CE   0xB920             CBNZ.N   R0,??auto_mount_13
   \   000000D0   0xF105 0x0050      ADD      R0,R5,#+80
   \   000000D4   0x7A00             LDRB     R0,[R0, #+8]
   \   000000D6   0x0600             LSLS     R0,R0,#+24
   \   000000D8   0xD50A             BPL.N    ??auto_mount_12
    699                  if (fmt == 1) {                     /* Not an FAT boot record, it may be patitioned */   
    700                      /* Check a partition listed in top of the partition table */   
    701                      tbl = &fs->win[MBR_Table + LD2PT(drv) * 16]; /* Partition table */   
   \                     ??auto_mount_13: (+1)
   \   000000DA   0xF505 0x70F7      ADD      R0,R5,#+494
    702                      if (tbl[4]) {                                   /* Is the partition existing? */   
   \   000000DE   0x7901             LDRB     R1,[R0, #+4]
   \   000000E0   0xB161             CBZ.N    R1,??auto_mount_11
    703                          bootsect = LD_DWORD(&tbl[8]);               /* Partition offset in LBA */   
   \   000000E2   0xF8D0 0xA008      LDR      R10,[R0, #+8]
    704                          fmt = check_fs(fs, bootsect);               /* Check the partition */   
    705                      }   
    706                  }   
    707                  if (fmt || LD_WORD(&fs->win[BPB_BytsPerSec]) != SS(fs))  /* No valid FAT patition is found */   
   \   000000E6   0x4651             MOV      R1,R10
   \   000000E8   0x4628             MOV      R0,R5
   \   000000EA   0x.... 0x....      BL       check_fs
   \   000000EE   0xB928             CBNZ.N   R0,??auto_mount_11
   \                     ??auto_mount_12: (+1)
   \   000000F0   0xF105 0x033B      ADD      R3,R5,#+59
   \   000000F4   0x8818             LDRH     R0,[R3, #+0]
   \   000000F6   0xF5B0 0x7F00      CMP      R0,#+512
   \   000000FA   0xD002             BEQ.N    ??auto_mount_14
    708                      return FR_NO_FILESYSTEM;   
   \                     ??auto_mount_11: (+1)
   \   000000FC   0x200B             MOVS     R0,#+11
   \   000000FE   0xE8BD 0x87F0      POP      {R4-R10,PC}
    709                 
    710                  /* Initialize the file system object */   
    711                  fatsize = LD_WORD(&fs->win[BPB_FATSz16]);            /* Number of sectors per FAT */   
   \                     ??auto_mount_14: (+1)
   \   00000102   0xF8B5 0x2046      LDRH     R2,[R5, #+70]
    712                  if (!fatsize) fatsize = LD_DWORD(&fs->win[BPB_FATSz32]);   
   \   00000106   0xF105 0x0050      ADD      R0,R5,#+80
   \   0000010A   0xB902             CBNZ.N   R2,??auto_mount_15
   \   0000010C   0x6842             LDR      R2,[R0, #+4]
    713                  fs->sects_fat = fatsize;   
    714                  fs->n_fats = fs->win[BPB_NumFATs];                    /* Number of FAT copies */   
   \                     ??auto_mount_15: (+1)
   \   0000010E   0xF105 0x013E      ADD      R1,R5,#+62
   \   00000112   0x60AA             STR      R2,[R5, #+8]
   \   00000114   0x788F             LDRB     R7,[R1, #+2]
   \   00000116   0x70B7             STRB     R7,[R6, #+2]
    715                  fatsize *= fs->n_fats;                               /* (Number of sectors in FAT area) */   
   \   00000118   0x437A             MULS     R2,R2,R7
    716                  fs->fatbase = bootsect + LD_WORD(&fs->win[BPB_RsvdSecCnt]); /* FAT start sector (lba) */   
   \   0000011A   0xF8B1 0xC000      LDRH     R12,[R1, #+0]
   \   0000011E   0x44D4             ADD      R12,R12,R10
   \   00000120   0xF8C5 0xC010      STR      R12,[R5, #+16]
    717                  fs->csize = fs->win[BPB_SecPerClus];              /* Number of sectors per cluster */   
   \   00000124   0xF893 0xC002      LDRB     R12,[R3, #+2]
   \   00000128   0xF886 0xC001      STRB     R12,[R6, #+1]
    718                  fs->n_rootdir = LD_WORD(&fs->win[BPB_RootEntCnt]);    /* Nmuber of root directory entries */   
   \   0000012C   0xF105 0x0341      ADD      R3,R5,#+65
   \   00000130   0xF8B3 0xE000      LDRH     LR,[R3, #+0]
   \   00000134   0xF8A5 0xE002      STRH     LR,[R5, #+2]
    719                  totalsect = LD_WORD(&fs->win[BPB_TotSec16]);     /* Number of sectors on the file system */   
   \   00000138   0x885F             LDRH     R7,[R3, #+2]
    720                  if (!totalsect) totalsect = LD_DWORD(&fs->win[BPB_TotSec32]);   
   \   0000013A   0xB907             CBNZ.N   R7,??auto_mount_16
   \   0000013C   0x6807             LDR      R7,[R0, #+0]
    721                  fs->max_clust = maxclust = (totalsect                /* max_clust = Last cluster# + 1 */   
    722                      - LD_WORD(&fs->win[BPB_RsvdSecCnt]) - fatsize - fs->n_rootdir / (SS(fs)/32)   
    723                      ) / fs->csize + 2;   
   \                     ??auto_mount_16: (+1)
   \   0000013E   0x8809             LDRH     R1,[R1, #+0]
   \   00000140   0x1A79             SUBS     R1,R7,R1
   \   00000142   0x1A89             SUBS     R1,R1,R2
   \   00000144   0xEBA1 0x111E      SUB      R1,R1,LR, LSR #+4
   \   00000148   0xFBB1 0xF1FC      UDIV     R1,R1,R12
   \   0000014C   0x1C89             ADDS     R1,R1,#+2
    724                 
    725                  fmt = FS_FAT12;                                     /* Determine the FAT sub type */   
   \   0000014E   0x2701             MOVS     R7,#+1
    726                  if (maxclust >= 0xFF7) fmt = FS_FAT16;   
   \   00000150   0xF640 0x73F7      MOVW     R3,#+4087
   \   00000154   0x60E9             STR      R1,[R5, #+12]
   \   00000156   0x4299             CMP      R1,R3
   \   00000158   0xBF28             IT       CS 
   \   0000015A   0x2702             MOVCS    R7,#+2
    727                  if (maxclust >= 0xFFF7) fmt = FS_FAT32;   
   \   0000015C   0xF64F 0x73F7      MOVW     R3,#+65527
   \   00000160   0x4299             CMP      R1,R3
   \   00000162   0xBF28             IT       CS 
   \   00000164   0x2703             MOVCS    R7,#+3
   \   00000166   0xD201             BCS.N    ??auto_mount_17
    728                 
    729                  if (fmt == FS_FAT32)   
   \   00000168   0x2F03             CMP      R7,#+3
   \   0000016A   0xD101             BNE.N    ??auto_mount_18
    730                      fs->dirbase = LD_DWORD(&fs->win[BPB_RootClus]);   /* Root directory start cluster */   
   \                     ??auto_mount_17: (+1)
   \   0000016C   0x68C1             LDR      R1,[R0, #+12]
   \   0000016E   0xE001             B.N      ??auto_mount_19
    731                  else   
    732                      fs->dirbase = fs->fatbase + fatsize;          /* Root directory start sector (lba) */   
   \                     ??auto_mount_18: (+1)
   \   00000170   0x6929             LDR      R1,[R5, #+16]
   \   00000172   0x1851             ADDS     R1,R2,R1
   \                     ??auto_mount_19: (+1)
   \   00000174   0x6169             STR      R1,[R5, #+20]
    733                  fs->database = fs->fatbase + fatsize + fs->n_rootdir / (SS(fs)/32);    /* Data start sector (lba) */   
   \   00000176   0x6929             LDR      R1,[R5, #+16]
   \   00000178   0x1851             ADDS     R1,R2,R1
   \   0000017A   0xEB01 0x111E      ADD      R1,R1,LR, LSR #+4
   \   0000017E   0x61A9             STR      R1,[R5, #+24]
    734                 
    735              #if !_FS_READONLY   
    736                  /* Initialize allocation information */   
    737                  fs->free_clust = 0xFFFFFFFF;   
    738              #if _USE_FSINFO   
    739                  /* Get fsinfo if needed */   
    740                  if (fmt == FS_FAT32) {   
   \   00000180   0x2F03             CMP      R7,#+3
   \   00000182   0xF04F 0x31FF      MOV      R1,#-1
   \   00000186   0x6229             STR      R1,[R5, #+32]
   \   00000188   0xD11E             BNE.N    ??auto_mount_20
    741                      fs->fsi_sector = bootsect + LD_WORD(&fs->win[BPB_FSInfo]);   
   \   0000018A   0x8A00             LDRH     R0,[R0, #+16]
   \   0000018C   0xEB00 0x020A      ADD      R2,R0,R10
   \   00000190   0x626A             STR      R2,[R5, #+36]
    742                      if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&   
    743                          LD_WORD(&fs->win[BS_55AA]) == 0xAA55 &&   
    744                          LD_DWORD(&fs->win[FSI_LeadSig]) == 0x41615252 &&   
    745                          LD_DWORD(&fs->win[FSI_StrucSig]) == 0x61417272) {   
   \   00000192   0x2301             MOVS     R3,#+1
   \   00000194   0x78F0             LDRB     R0,[R6, #+3]
   \   00000196   0xF105 0x0130      ADD      R1,R5,#+48
   \   0000019A   0x.... 0x....      BL       disk_read
   \   0000019E   0x2800             CMP      R0,#+0
   \   000001A0   0xBF04             ITT      EQ 
   \   000001A2   0xF8B8 0x001A      LDRHEQ   R0,[R8, #+26]
   \   000001A6   0x4548             CMPEQ    R0,R9
   \   000001A8   0xD10E             BNE.N    ??auto_mount_20
   \   000001AA   0x6B28             LDR      R0,[R5, #+48]
   \   000001AC   0x....             LDR.N    R1,??DataTable7  ;; 0x41615252
   \   000001AE   0x4288             CMP      R0,R1
   \   000001B0   0xBF02             ITTT     EQ 
   \   000001B2   0xF8D8 0x0000      LDREQ    R0,[R8, #+0]
   \   000001B6   0x....             LDREQ.N  R1,??DataTable7_2  ;; 0x61417272
   \   000001B8   0x4288             CMPEQ    R0,R1
   \   000001BA   0xD105             BNE.N    ??auto_mount_20
    746                          fs->last_clust = LD_DWORD(&fs->win[FSI_Nxt_Free]);   
   \   000001BC   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \   000001C0   0x61E8             STR      R0,[R5, #+28]
    747                          fs->free_clust = LD_DWORD(&fs->win[FSI_Free_Count]);   
   \   000001C2   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   000001C6   0x6228             STR      R0,[R5, #+32]
    748                      }   
    749                  }   
    750              #endif   
    751              #endif   
    752                 
    753                  fs->fs_type = fmt;           /* FAT syb-type */   
   \                     ??auto_mount_20: (+1)
   \   000001C8   0x7037             STRB     R7,[R6, #+0]
    754                  fs->id = ++fsid;         /* File system mount ID */   
   \   000001CA   0x8820             LDRH     R0,[R4, #+0]
   \   000001CC   0x1C40             ADDS     R0,R0,#+1
   \   000001CE   0x8020             STRH     R0,[R4, #+0]
   \   000001D0   0x8028             STRH     R0,[R5, #+0]
    755                  return FR_OK;   
   \                     ??auto_mount_7: (+1)
   \   000001D2   0x2000             MOVS     R0,#+0
   \                     ??auto_mount_9: (+1)
   \   000001D4   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    756              }   
    757                 
    758                 
    759                 
    760                 
    761              /*-----------------------------------------------------------------------*/   
    762              /* Check if the file/dir object is valid or not                          */   
    763              /*-----------------------------------------------------------------------*/   
    764                 

   \                                 In section .text, align 2, keep-with-next
    765              static   
    766              FRESULT validate (      /* FR_OK(0): The object is valid, !=0: Invalid */   
    767                  const FATFS *fs,    /* Pointer to the file system object */   
    768                  WORD id             /* Member id of the target object to be checked */   
    769              )   
    770              {   
   \                     validate: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    771                  if (!fs || !fs->fs_type || fs->id != id)   
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xBF1E             ITTT     NE 
   \   00000006   0xF100 0x022A      ADDNE    R2,R0,#+42
   \   0000000A   0x7813             LDRBNE   R3,[R2, #+0]
   \   0000000C   0x2B00             CMPNE    R3,#+0
   \   0000000E   0xD002             BEQ.N    ??validate_0
   \   00000010   0x8800             LDRH     R0,[R0, #+0]
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD001             BEQ.N    ??validate_1
    772                      return FR_INVALID_OBJECT;   
   \                     ??validate_0: (+1)
   \   00000016   0x200C             MOVS     R0,#+12
   \   00000018   0xBD02             POP      {R1,PC}
    773                  if (disk_status(fs->drive) & STA_NOINIT)   
   \                     ??validate_1: (+1)
   \   0000001A   0x78D0             LDRB     R0,[R2, #+3]
   \   0000001C   0x.... 0x....      BL       disk_status
   \   00000020   0xF000 0x0101      AND      R1,R0,#0x1
   \   00000024   0x1E48             SUBS     R0,R1,#+1
   \   00000026   0x4180             SBCS     R0,R0,R0
   \   00000028   0x43C0             MVNS     R0,R0
   \   0000002A   0x0FC0             LSRS     R0,R0,#+31
    774                      return FR_NOT_READY;   
    775                 
    776                  return FR_OK;   
   \   0000002C   0xBD02             POP      {R1,PC}          ;; return
    777              }   
    778                 
    779                 
    780                 
    781                 
    782              /*--------------------------------------------------------------------------  
    783                
    784                 Public Functions  
    785                
    786              --------------------------------------------------------------------------*/   
    787                 
    788                 
    789                 
    790              /*-----------------------------------------------------------------------*/   
    791              /* Mount/Unmount a Locical Drive                                         */   
    792              /*-----------------------------------------------------------------------*/   
    793                 

   \                                 In section .text, align 2, keep-with-next
    794              FRESULT f_mount (   
    795                  BYTE drv,       /* Logical drive number to be mounted/unmounted */   
    796                  FATFS *fs       /* Pointer to new file system object (NULL for unmount)*/   
    797              )   
    798              {   
    799                  if (drv >= _DRIVES) return FR_INVALID_DRIVE;   
   \                     f_mount: (+1)
   \   00000000   0xB108             CBZ.N    R0,??f_mount_0
   \   00000002   0x2005             MOVS     R0,#+5
   \   00000004   0x4770             BX       LR
    800                 
    801                  if (FatFs[drv]) FatFs[drv]->fs_type = 0; /* Clear old object */   
   \                     ??f_mount_0: (+1)
   \   00000006   0x....             LDR.N    R0,??DataTable7_3
   \   00000008   0x6842             LDR      R2,[R0, #+4]
   \   0000000A   0xB112             CBZ.N    R2,??f_mount_1
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0xF882 0x302A      STRB     R3,[R2, #+42]
    802                 
    803                  FatFs[drv] = fs;            /* Register and clear new object */   
   \                     ??f_mount_1: (+1)
   \   00000012   0x6041             STR      R1,[R0, #+4]
    804                  if (fs) fs->fs_type = 0;   
   \   00000014   0xB111             CBZ.N    R1,??f_mount_2
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF881 0x002A      STRB     R0,[R1, #+42]
    805                 
    806                  return FR_OK;   
   \                     ??f_mount_2: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x4770             BX       LR               ;; return
    807              }   
    808                 
    809                 
    810                 
    811                 
    812              /*-----------------------------------------------------------------------*/   
    813              /* Open or Create a File                                                 */   
    814              /*-----------------------------------------------------------------------*/   
    815                 

   \                                 In section .text, align 2, keep-with-next
    816              FRESULT f_open (   
    817                  FIL *fp,            /* Pointer to the blank file object */   
    818                  const char *path,   /* Pointer to the file name */   
    819                  BYTE mode           /* Access mode and file open mode flags */   
    820              )   
    821              {   
   \                     f_open: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB08A             SUB      SP,SP,#+40
    822                  FRESULT res;   
    823                  DIR dj;   
    824                  BYTE *dir;   
    825                  char fn[8+3+1];   
    826                 
    827                 
    828                  fp->fs = NULL;       /* Clear file object */   
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x6060             STR      R0,[R4, #+4]
    829              #if !_FS_READONLY   
    830                  mode &= (FA_READ|FA_WRITE|FA_CREATE_ALWAYS|FA_OPEN_ALWAYS|FA_CREATE_NEW);   
   \   0000000A   0xF002 0x051F      AND      R5,R2,#0x1F
    831                  res = auto_mount(&path, &dj.fs, (BYTE)(mode & (FA_WRITE|FA_CREATE_ALWAYS|FA_OPEN_ALWAYS|FA_CREATE_NEW)));   
   \   0000000E   0xF005 0x021E      AND      R2,R5,#0x1E
   \   00000012   0xA902             ADD      R1,SP,#+8
   \   00000014   0xA80A             ADD      R0,SP,#+40
   \   00000016   0x.... 0x....      BL       auto_mount
    832              #else   
    833                  mode &= FA_READ;   
    834                  res = auto_mount(&path, &dj.fs, 0);   
    835              #endif   
    836                  if (res != FR_OK) return res;   
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD17D             BNE.N    ??f_open_0
    837                  res = trace_path(&dj, fn, path, &dir);  /* Trace the file path */   
   \   0000001E   0x9A0A             LDR      R2,[SP, #+40]
   \   00000020   0x466B             MOV      R3,SP
   \   00000022   0xA906             ADD      R1,SP,#+24
   \   00000024   0xA801             ADD      R0,SP,#+4
   \   00000026   0x.... 0x....      BL       trace_path
    838                 
    839              #if !_FS_READONLY   
    840                  /* Create or Open a file */   
    841                  if (mode & (FA_CREATE_ALWAYS|FA_OPEN_ALWAYS|FA_CREATE_NEW)) {   
   \   0000002A   0x211C             MOVS     R1,#+28
   \   0000002C   0x420D             TST      R5,R1
   \   0000002E   0xD076             BEQ.N    ??f_open_1
    842                      DWORD ps, rs;   
    843                      if (res != FR_OK) {     /* No file, create new */   
   \   00000030   0xB1B8             CBZ.N    R0,??f_open_2
    844                          if (res != FR_NO_FILE) return res;   
   \   00000032   0x2802             CMP      R0,#+2
   \   00000034   0xD171             BNE.N    ??f_open_0
    845                          res = reserve_direntry(&dj, &dir);   
   \   00000036   0x4669             MOV      R1,SP
   \   00000038   0xA801             ADD      R0,SP,#+4
   \   0000003A   0x.... 0x....      BL       reserve_direntry
    846                          if (res != FR_OK) return res;   
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD16B             BNE.N    ??f_open_0
    847                          memset(dir, 0, 32);     /* Initialize the new entry with open name */   
   \   00000042   0x9800             LDR      R0,[SP, #+0]
   \   00000044   0x2120             MOVS     R1,#+32
   \   00000046   0x.... 0x....      BL       __aeabi_memclr
    848                          memcpy(&dir[DIR_Name], fn, 8+3);   
   \   0000004A   0x9800             LDR      R0,[SP, #+0]
   \   0000004C   0x220B             MOVS     R2,#+11
   \   0000004E   0xA906             ADD      R1,SP,#+24
   \   00000050   0x.... 0x....      BL       __aeabi_memcpy
    849                          dir[DIR_NTres] = fn[11];   
   \   00000054   0x9900             LDR      R1,[SP, #+0]
   \   00000056   0xF89D 0x0023      LDRB     R0,[SP, #+35]
   \   0000005A   0x7308             STRB     R0,[R1, #+12]
    850                          mode |= FA_CREATE_ALWAYS;   
   \   0000005C   0xF045 0x0508      ORR      R5,R5,#0x8
   \   00000060   0xE02E             B.N      ??f_open_3
    851                      }   
    852                      else {                  /* Any object is already existing */   
    853                          if (mode & FA_CREATE_NEW)           /* Cannot create new */   
   \                     ??f_open_2: (+1)
   \   00000062   0x0768             LSLS     R0,R5,#+29
   \   00000064   0xBF48             IT       MI 
   \   00000066   0x2007             MOVMI    R0,#+7
    854                              return FR_EXIST;   
   \   00000068   0xD457             BMI.N    ??f_open_0
    855                          if (!dir || (dir[DIR_Attr] & (AM_RDO|AM_DIR)))  /* Cannot overwrite it (R/O or DIR) */   
   \   0000006A   0x9800             LDR      R0,[SP, #+0]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD064             BEQ.N    ??f_open_4
   \   00000070   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000072   0x2111             MOVS     R1,#+17
   \   00000074   0x4208             TST      R0,R1
   \   00000076   0xD160             BNE.N    ??f_open_4
    856                              return FR_DENIED;   
    857                          if (mode & FA_CREATE_ALWAYS) {      /* Resize it to zero if needed */   
   \   00000078   0x0728             LSLS     R0,R5,#+28
   \   0000007A   0xD532             BPL.N    ??f_open_5
    858                              rs = ((DWORD)LD_WORD(&dir[DIR_FstClusHI]) << 16) | LD_WORD(&dir[DIR_FstClusLO]);  /* Get start cluster */   
   \   0000007C   0x9800             LDR      R0,[SP, #+0]
   \   0000007E   0x9900             LDR      R1,[SP, #+0]
   \   00000080   0x8A80             LDRH     R0,[R0, #+20]
   \   00000082   0x8B49             LDRH     R1,[R1, #+26]
   \   00000084   0xEA41 0x4600      ORR      R6,R1,R0, LSL #+16
    859                              ST_WORD(&dir[DIR_FstClusHI], 0);    /* cluster = 0 */   
   \   00000088   0x9900             LDR      R1,[SP, #+0]
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x8288             STRH     R0,[R1, #+20]
    860                              ST_WORD(&dir[DIR_FstClusLO], 0);   
   \   0000008E   0x9900             LDR      R1,[SP, #+0]
   \   00000090   0x8348             STRH     R0,[R1, #+26]
    861                              ST_DWORD(&dir[DIR_FileSize], 0);    /* size = 0 */   
   \   00000092   0x9900             LDR      R1,[SP, #+0]
   \   00000094   0x61C8             STR      R0,[R1, #+28]
    862                              dj.fs->winflag = 1;   
   \   00000096   0x2001             MOVS     R0,#+1
   \   00000098   0x9902             LDR      R1,[SP, #+8]
   \   0000009A   0xF881 0x002E      STRB     R0,[R1, #+46]
    863                              ps = dj.fs->winsect;         /* Remove the cluster chain */   
    864                              if (!remove_chain(dj.fs, rs) || !move_window(dj.fs, ps))   
   \   0000009E   0x4631             MOV      R1,R6
   \   000000A0   0x9802             LDR      R0,[SP, #+8]
   \   000000A2   0x6847             LDR      R7,[R0, #+4]
   \   000000A4   0x.... 0x....      BL       remove_chain
   \   000000A8   0xB120             CBZ.N    R0,??f_open_6
   \   000000AA   0x9802             LDR      R0,[SP, #+8]
   \   000000AC   0x4639             MOV      R1,R7
   \   000000AE   0x.... 0x....      BL       move_window
   \   000000B2   0xB910             CBNZ.N   R0,??f_open_7
    865                                  return FR_RW_ERROR;   
   \                     ??f_open_6: (+1)
   \   000000B4   0x2008             MOVS     R0,#+8
   \   000000B6   0xB00B             ADD      SP,SP,#+44
   \   000000B8   0xBDF0             POP      {R4-R7,PC}
    866                              dj.fs->last_clust = rs - 1;      /* Reuse the cluster hole */   
   \                     ??f_open_7: (+1)
   \   000000BA   0x9902             LDR      R1,[SP, #+8]
   \   000000BC   0x1E70             SUBS     R0,R6,#+1
   \   000000BE   0x61C8             STR      R0,[R1, #+28]
    867                          }   
    868                      }   
    869                      if (mode & FA_CREATE_ALWAYS) {   
   \                     ??f_open_3: (+1)
   \   000000C0   0x0728             LSLS     R0,R5,#+28
   \   000000C2   0xD50E             BPL.N    ??f_open_5
    870                          dir[DIR_Attr] = 0;                  /* Reset attribute */   
   \   000000C4   0x9900             LDR      R1,[SP, #+0]
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0x72C8             STRB     R0,[R1, #+11]
   \   000000CA   0xF045 0x0520      ORR      R5,R5,#0x20
    871                          ps = get_fattime();   
   \   000000CE   0x.... 0x....      BL       get_fattime
   \   000000D2   0x4607             MOV      R7,R0
    872                          ST_DWORD(&dir[DIR_CrtTime], ps);    /* Created time */   
   \   000000D4   0x9800             LDR      R0,[SP, #+0]
   \   000000D6   0xF8C0 0x700E      STR      R7,[R0, #+14]
    873                          dj.fs->winflag = 1;   
   \   000000DA   0x2001             MOVS     R0,#+1
   \   000000DC   0x9902             LDR      R1,[SP, #+8]
   \   000000DE   0xF881 0x002E      STRB     R0,[R1, #+46]
    874                          mode |= FA__WRITTEN;                /* Set file changed flag */   
    875                      }   
    876                  }   
    877                  /* Open an existing file */   
    878                  else {   
    879              #endif /* !_FS_READONLY */   
    880                      if (res != FR_OK) return res;           /* Trace failed */   
    881                      if (!dir || (dir[DIR_Attr] & AM_DIR))   /* It is a directory */   
    882                          return FR_NO_FILE;   
    883              #if !_FS_READONLY   
    884                      if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */   
    885                          return FR_DENIED;   
    886                  }   
    887                  fp->dir_sect = dj.fs->winsect;        /* Pointer to the directory entry */   
   \                     ??f_open_5: (+1)
   \   000000E2   0x9802             LDR      R0,[SP, #+8]
   \   000000E4   0x6840             LDR      R0,[R0, #+4]
   \   000000E6   0x61E0             STR      R0,[R4, #+28]
    888                  fp->dir_ptr = dir;   
   \   000000E8   0x9800             LDR      R0,[SP, #+0]
   \   000000EA   0x6220             STR      R0,[R4, #+32]
    889              #endif   
    890                  fp->flag = mode;                 /* File access mode */   
   \   000000EC   0x70A5             STRB     R5,[R4, #+2]
    891                  fp->org_clust =                      /* File start cluster */   
    892                      ((DWORD)LD_WORD(&dir[DIR_FstClusHI]) << 16) | LD_WORD(&dir[DIR_FstClusLO]);   
   \   000000EE   0x9800             LDR      R0,[SP, #+0]
   \   000000F0   0x9900             LDR      R1,[SP, #+0]
   \   000000F2   0x8A80             LDRH     R0,[R0, #+20]
   \   000000F4   0x8B49             LDRH     R1,[R1, #+26]
   \   000000F6   0xEA41 0x4000      ORR      R0,R1,R0, LSL #+16
   \   000000FA   0x6120             STR      R0,[R4, #+16]
    893                  fp->fsize = LD_DWORD(&dir[DIR_FileSize]);    /* File size */   
   \   000000FC   0x9800             LDR      R0,[SP, #+0]
   \   000000FE   0x69C0             LDR      R0,[R0, #+28]
   \   00000100   0x60E0             STR      R0,[R4, #+12]
    894                  fp->fptr = 0; fp->csect = 255;        /* File pointer */   
   \   00000102   0x2000             MOVS     R0,#+0
   \   00000104   0x60A0             STR      R0,[R4, #+8]
   \   00000106   0x20FF             MOVS     R0,#+255
   \   00000108   0x70E0             STRB     R0,[R4, #+3]
    895                  fp->curr_sect = 0;   
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0x61A0             STR      R0,[R4, #+24]
    896                  fp->fs = dj.fs; fp->id = dj.fs->id;    /* Owner file system object of the file */   
   \   0000010E   0x9802             LDR      R0,[SP, #+8]
   \   00000110   0x6060             STR      R0,[R4, #+4]
   \   00000112   0x9802             LDR      R0,[SP, #+8]
   \   00000114   0x8800             LDRH     R0,[R0, #+0]
   \   00000116   0x8020             STRH     R0,[R4, #+0]
    897                 
    898                  return FR_OK;   
   \   00000118   0x2000             MOVS     R0,#+0
   \                     ??f_open_0: (+1)
   \   0000011A   0xB00B             ADD      SP,SP,#+44
   \   0000011C   0xBDF0             POP      {R4-R7,PC}       ;; return
   \                     ??f_open_1: (+1)
   \   0000011E   0x2800             CMP      R0,#+0
   \   00000120   0xD1FB             BNE.N    ??f_open_0
   \   00000122   0x9800             LDR      R0,[SP, #+0]
   \   00000124   0xB110             CBZ.N    R0,??f_open_8
   \   00000126   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000128   0x06C1             LSLS     R1,R0,#+27
   \   0000012A   0xD502             BPL.N    ??f_open_9
   \                     ??f_open_8: (+1)
   \   0000012C   0x2002             MOVS     R0,#+2
   \   0000012E   0xB00B             ADD      SP,SP,#+44
   \   00000130   0xBDF0             POP      {R4-R7,PC}
   \                     ??f_open_9: (+1)
   \   00000132   0x07A9             LSLS     R1,R5,#+30
   \   00000134   0xD5D5             BPL.N    ??f_open_5
   \   00000136   0x07C0             LSLS     R0,R0,#+31
   \   00000138   0xD5D3             BPL.N    ??f_open_5
   \                     ??f_open_4: (+1)
   \   0000013A   0x2006             MOVS     R0,#+6
   \   0000013C   0xB00B             ADD      SP,SP,#+44
   \   0000013E   0xBDF0             POP      {R4-R7,PC}
    899              }   
    900                 
    901                 
    902                 
    903                 
    904              /*-----------------------------------------------------------------------*/   
    905              /* Read File                                                             */   
    906              /*-----------------------------------------------------------------------*/   
    907                 

   \                                 In section .text, align 2, keep-with-next
    908              FRESULT f_read (   
    909                  FIL *fp,        /* Pointer to the file object */   
    910                  void *buff,     /* Pointer to data buffer */   
    911                  UINT btr,       /* Number of bytes to read */   
    912                  UINT *br        /* Pointer to number of bytes read */   
    913              )   
    914              {   
   \                     f_read: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x4699             MOV      R9,R3
    915                  FRESULT res;   
    916                  DWORD clust, sect, remain;   
    917                  UINT rcnt, cc;   
    918                  BYTE *rbuff = buff;   
    919                 
    920                 
    921                  *br = 0;   
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x4688             MOV      R8,R1
   \   0000000C   0xF8A9 0x0000      STRH     R0,[R9, #+0]
   \   00000010   0x4617             MOV      R7,R2
    922                  res = validate(fp->fs, fp->id);                   /* Check validity of the object */   
   \   00000012   0x8829             LDRH     R1,[R5, #+0]
   \   00000014   0x6868             LDR      R0,[R5, #+4]
   \   00000016   0x.... 0x....      BL       validate
    923                  if (res != FR_OK) return res;   
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xF040 0x8096      BNE.W    ??f_read_0
    924                  if (fp->flag & FA__ERROR) return FR_RW_ERROR;    /* Check error flag */   
   \   00000020   0x78A8             LDRB     R0,[R5, #+2]
   \   00000022   0x0601             LSLS     R1,R0,#+24
   \   00000024   0xF100 0x8091      BMI.W    ??f_read_1
    925                  if (!(fp->flag & FA_READ)) return FR_DENIED; /* Check access mode */   
   \   00000028   0x07C0             LSLS     R0,R0,#+31
   \   0000002A   0xBF58             IT       PL 
   \   0000002C   0x2006             MOVPL    R0,#+6
   \   0000002E   0xF140 0x808D      BPL.W    ??f_read_0
    926                  remain = fp->fsize - fp->fptr;   
   \   00000032   0x68E8             LDR      R0,[R5, #+12]
   \   00000034   0x68A9             LDR      R1,[R5, #+8]
   \   00000036   0x1A40             SUBS     R0,R0,R1
    927                  if (btr > remain) btr = (UINT)remain;            /* Truncate btr by remaining bytes */   
   \   00000038   0x42B8             CMP      R0,R7
   \   0000003A   0xD23F             BCS.N    ??f_read_2
   \   0000003C   0x4607             MOV      R7,R0
   \   0000003E   0xE03D             B.N      ??f_read_2
    928                 
    929                  for ( ;  btr;                                   /* Repeat until all data transferred */   
    930                      rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {   
    931                      if ((fp->fptr % SS(fp->fs)) == 0) {           /* On the sector boundary? */   
    932                          if (fp->csect >= fp->fs->csize) {       /* On the cluster boundary? */   
    933                              clust = (fp->fptr == 0) ?            /* On the top of the file? */   
    934                                  fp->org_clust : get_cluster(fp->fs, fp->curr_clust);   
    935                              if (clust < 2 || clust >= fp->fs->max_clust) goto fr_error;   
    936                              fp->curr_clust = clust;              /* Update current cluster */   
    937                              fp->csect = 0;                       /* Reset sector address in the cluster */   
    938                          }   
    939                          sect = clust2sect(fp->fs, fp->curr_clust) + fp->csect; /* Get current sector */   
    940                          cc = btr / SS(fp->fs);                   /* When remaining bytes >= sector size, */   
    941                          if (cc) {                               /* Read maximum contiguous sectors directly */   
    942                              if (fp->csect + cc > fp->fs->csize) /* Clip at cluster boundary */   
    943                                  cc = fp->fs->csize - fp->csect;   
    944                              if (disk_read(fp->fs->drive, rbuff, sect, (BYTE)cc) != RES_OK)   
    945                                  goto fr_error;   
    946                              fp->csect += (BYTE)cc;               /* Next sector address in the cluster */   
    947                              rcnt = SS(fp->fs) * cc;              /* Number of bytes transferred */   
    948                              continue;   
    949                          }   
    950                          if (sect != fp->curr_sect) {         /* Is window offset changed? */   
   \                     ??f_read_3: (+1)
   \   00000040   0x69AA             LDR      R2,[R5, #+24]
   \   00000042   0x4294             CMP      R4,R2
   \   00000044   0xD01B             BEQ.N    ??f_read_4
    951              #if !_FS_READONLY   
    952                              if (fp->flag & FA__DIRTY) {          /* Write back file I/O buffer if needed */   
   \   00000046   0x78A9             LDRB     R1,[R5, #+2]
   \   00000048   0x0649             LSLS     R1,R1,#+25
   \   0000004A   0xD50C             BPL.N    ??f_read_5
    953                                  if (disk_write(fp->fs->drive, fp->buffer, fp->curr_sect, 1) != RES_OK)   
   \   0000004C   0x302B             ADDS     R0,R0,#+43
   \   0000004E   0x2301             MOVS     R3,#+1
   \   00000050   0x7880             LDRB     R0,[R0, #+2]
   \   00000052   0xF105 0x0124      ADD      R1,R5,#+36
   \   00000056   0x.... 0x....      BL       disk_write
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD171             BNE.N    ??f_read_6
    954                                      goto fr_error;   
    955                                  fp->flag &= (BYTE)~FA__DIRTY;   
   \   0000005E   0x78A8             LDRB     R0,[R5, #+2]
   \   00000060   0xF000 0x00BF      AND      R0,R0,#0xBF
   \   00000064   0x70A8             STRB     R0,[R5, #+2]
    956                              }   
    957              #endif   
    958                              if (disk_read(fp->fs->drive, fp->buffer, sect, 1) != RES_OK)   /* Fill file I/O buffer with file data */   
   \                     ??f_read_5: (+1)
   \   00000066   0x2301             MOVS     R3,#+1
   \   00000068   0x6868             LDR      R0,[R5, #+4]
   \   0000006A   0xF890 0x002D      LDRB     R0,[R0, #+45]
   \   0000006E   0x4622             MOV      R2,R4
   \   00000070   0xF105 0x0124      ADD      R1,R5,#+36
   \   00000074   0x.... 0x....      BL       disk_read
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD162             BNE.N    ??f_read_6
    959                                  goto fr_error;   
    960                              fp->curr_sect = sect;   
   \   0000007C   0x61AC             STR      R4,[R5, #+24]
    961                          }   
    962                          fp->csect++;                         /* Next sector address in the cluster */   
   \                     ??f_read_4: (+1)
   \   0000007E   0x78E8             LDRB     R0,[R5, #+3]
   \   00000080   0x1C40             ADDS     R0,R0,#+1
   \   00000082   0x70E8             STRB     R0,[R5, #+3]
    963                      }   
    964                      rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));   /* Get partial sector from file I/O buffer */   
   \                     ??f_read_7: (+1)
   \   00000084   0x68A8             LDR      R0,[R5, #+8]
   \   00000086   0x05C1             LSLS     R1,R0,#+23
   \   00000088   0x0DC9             LSRS     R1,R1,#+23
   \   0000008A   0xF5C1 0x7400      RSB      R4,R1,#+512
   \   0000008E   0xB2A4             UXTH     R4,R4
    965                      if (rcnt > btr) rcnt = btr;   
   \   00000090   0x42A7             CMP      R7,R4
   \   00000092   0xBFB8             IT       LT 
   \   00000094   0x463C             MOVLT    R4,R7
    966                      memcpy(rbuff, &fp->buffer[fp->fptr % SS(fp->fs)], rcnt);   
   \   00000096   0x05C0             LSLS     R0,R0,#+23
   \   00000098   0xEB15 0x50D0      ADDS     R0,R5,R0, LSR #+23
   \   0000009C   0xF100 0x0124      ADD      R1,R0,#+36
   \   000000A0   0x4622             MOV      R2,R4
   \   000000A2   0x4640             MOV      R0,R8
   \   000000A4   0x.... 0x....      BL       __aeabi_memcpy
   \                     ??f_read_8: (+1)
   \   000000A8   0x68A8             LDR      R0,[R5, #+8]
   \   000000AA   0x1820             ADDS     R0,R4,R0
   \   000000AC   0x60A8             STR      R0,[R5, #+8]
   \   000000AE   0x44A0             ADD      R8,R4,R8
   \   000000B0   0xF8B9 0x0000      LDRH     R0,[R9, #+0]
   \   000000B4   0x1820             ADDS     R0,R4,R0
   \   000000B6   0xF8A9 0x0000      STRH     R0,[R9, #+0]
   \   000000BA   0x1B3F             SUBS     R7,R7,R4
   \                     ??f_read_2: (+1)
   \   000000BC   0xB2BF             UXTH     R7,R7
   \   000000BE   0x2F00             CMP      R7,#+0
   \   000000C0   0xD03D             BEQ.N    ??f_read_9
   \   000000C2   0x68A9             LDR      R1,[R5, #+8]
   \   000000C4   0x05C8             LSLS     R0,R1,#+23
   \   000000C6   0xD1DD             BNE.N    ??f_read_7
   \   000000C8   0x6868             LDR      R0,[R5, #+4]
   \   000000CA   0x78EA             LDRB     R2,[R5, #+3]
   \   000000CC   0xF890 0x302B      LDRB     R3,[R0, #+43]
   \   000000D0   0x429A             CMP      R2,R3
   \   000000D2   0xD30E             BCC.N    ??f_read_10
   \   000000D4   0x2900             CMP      R1,#+0
   \   000000D6   0xBF0E             ITEE     EQ 
   \   000000D8   0x6928             LDREQ    R0,[R5, #+16]
   \   000000DA   0x6969             LDRNE    R1,[R5, #+20]
   \   000000DC   0x.... 0x....      BLNE     get_cluster
   \   000000E0   0x2802             CMP      R0,#+2
   \   000000E2   0xD32E             BCC.N    ??f_read_6
   \   000000E4   0x6869             LDR      R1,[R5, #+4]
   \   000000E6   0x68C9             LDR      R1,[R1, #+12]
   \   000000E8   0x4288             CMP      R0,R1
   \   000000EA   0xD22A             BCS.N    ??f_read_6
   \   000000EC   0x6168             STR      R0,[R5, #+20]
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x70E8             STRB     R0,[R5, #+3]
   \                     ??f_read_10: (+1)
   \   000000F2   0x6868             LDR      R0,[R5, #+4]
   \   000000F4   0x6969             LDR      R1,[R5, #+20]
   \   000000F6   0xF100 0x020C      ADD      R2,R0,#+12
   \   000000FA   0x1E89             SUBS     R1,R1,#+2
   \   000000FC   0x6813             LDR      R3,[R2, #+0]
   \   000000FE   0x1E9B             SUBS     R3,R3,#+2
   \   00000100   0x4299             CMP      R1,R3
   \   00000102   0xBF2F             ITEEE    CS 
   \   00000104   0x2100             MOVCS    R1,#+0
   \   00000106   0x7FD3             LDRBCC   R3,[R2, #+31]
   \   00000108   0x68D2             LDRCC    R2,[R2, #+12]
   \   0000010A   0xFB03 0x2101      MLACC    R1,R3,R1,R2
   \   0000010E   0x78EA             LDRB     R2,[R5, #+3]
   \   00000110   0x1854             ADDS     R4,R2,R1
   \   00000112   0x0A7E             LSRS     R6,R7,#+9
   \   00000114   0xD094             BEQ.N    ??f_read_3
   \   00000116   0xF810 0x1F2B      LDRB     R1,[R0, #+43]!
   \   0000011A   0x18B3             ADDS     R3,R6,R2
   \   0000011C   0x4299             CMP      R1,R3
   \   0000011E   0xBFBC             ITT      LT 
   \   00000120   0x1A8E             SUBLT    R6,R1,R2
   \   00000122   0xB2B6             UXTHLT   R6,R6
   \   00000124   0x7880             LDRB     R0,[R0, #+2]
   \   00000126   0xB2F3             UXTB     R3,R6
   \   00000128   0x4622             MOV      R2,R4
   \   0000012A   0x4641             MOV      R1,R8
   \   0000012C   0x.... 0x....      BL       disk_read
   \   00000130   0xB938             CBNZ.N   R0,??f_read_6
   \   00000132   0x78E8             LDRB     R0,[R5, #+3]
   \   00000134   0x1830             ADDS     R0,R6,R0
   \   00000136   0x0274             LSLS     R4,R6,#+9
   \   00000138   0x70E8             STRB     R0,[R5, #+3]
   \   0000013A   0xB2A4             UXTH     R4,R4
   \   0000013C   0xE7B4             B.N      ??f_read_8
    967                  }   
    968                 
    969                  return FR_OK;   
   \                     ??f_read_9: (+1)
   \   0000013E   0x.... 0x....      B.W      ?Subroutine1
    970                 
    971              fr_error:   /* Abort this file due to an unrecoverable error */   
    972                  fp->flag |= FA__ERROR;   
   \                     ??f_read_6: (+1)
   \   00000142   0x78A8             LDRB     R0,[R5, #+2]
   \   00000144   0xF040 0x0080      ORR      R0,R0,#0x80
   \   00000148   0x70A8             STRB     R0,[R5, #+2]
    973                  return FR_RW_ERROR;   
   \                     ??f_read_1: (+1)
   \   0000014A   0x2008             MOVS     R0,#+8
   \                     ??f_read_0: (+1)
   \   0000014C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    974              }   
    975                 
    976                 
    977                 
    978                 
    979              #if !_FS_READONLY   
    980              /*-----------------------------------------------------------------------*/   
    981              /* Write File                                                            */   
    982              /*-----------------------------------------------------------------------*/   
    983                 

   \                                 In section .text, align 2, keep-with-next
    984              FRESULT f_write (   
    985                  FIL *fp,            /* Pointer to the file object */   
    986                  const void *buff,   /* Pointer to the data to be written */   
    987                  UINT btw,           /* Number of bytes to write */   
    988                  UINT *bw            /* Pointer to number of bytes written */   
    989              )   
    990              {   
   \                     f_write: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x4699             MOV      R9,R3
    991                  FRESULT res;   
    992                  DWORD clust, sect;   
    993                  UINT wcnt, cc;   
    994                  const BYTE *wbuff = buff;   
    995                 
    996                 
    997                  *bw = 0;   
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x4688             MOV      R8,R1
   \   0000000C   0xF8A9 0x0000      STRH     R0,[R9, #+0]
   \   00000010   0x4616             MOV      R6,R2
    998                  res = validate(fp->fs, fp->id);                   /* Check validity of the object */   
   \   00000012   0x8829             LDRH     R1,[R5, #+0]
   \   00000014   0x6868             LDR      R0,[R5, #+4]
   \   00000016   0x.... 0x....      BL       validate
    999                  if (res != FR_OK) return res;   
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xF040 0x80AE      BNE.W    ??f_write_0
   1000                  if (fp->flag & FA__ERROR) return FR_RW_ERROR;    /* Check error flag */   
   \   00000020   0x78A8             LDRB     R0,[R5, #+2]
   \   00000022   0x0601             LSLS     R1,R0,#+24
   \   00000024   0xF100 0x80A9      BMI.W    ??f_write_1
   1001                  if (!(fp->flag & FA_WRITE)) return FR_DENIED;    /* Check access mode */   
   \   00000028   0x0780             LSLS     R0,R0,#+30
   \   0000002A   0xBF58             IT       PL 
   \   0000002C   0x2006             MOVPL    R0,#+6
   \   0000002E   0xF140 0x80A5      BPL.W    ??f_write_0
   1002                  if (fp->fsize + btw < fp->fsize) return FR_OK; /* File size cannot reach 4GB */   
   \   00000032   0x68E8             LDR      R0,[R5, #+12]
   \   00000034   0x1831             ADDS     R1,R6,R0
   \   00000036   0x4281             CMP      R1,R0
   \   00000038   0xD246             BCS.N    ??f_write_2
   \   0000003A   0xE098             B.N      ??f_write_3
   1003                 
   1004                  for ( ;  btw;                                   /* Repeat until all data transferred */   
   1005                      wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {   
   1006                      if ((fp->fptr % SS(fp->fs)) == 0) {           /* On the sector boundary? */   
   1007                          if (fp->csect >= fp->fs->csize) {       /* On the cluster boundary? */   
   1008                              if (fp->fptr == 0) {             /* On the top of the file? */   
   1009                                  clust = fp->org_clust;           /* Follow from the origin */   
   1010                                  if (clust == 0)                 /* When there is no cluster chain, */   
   1011                                      fp->org_clust = clust = create_chain(fp->fs, 0);  /* Create a new cluster chain */   
   1012                              } else {                            /* Middle or end of the file */   
   1013                                  clust = create_chain(fp->fs, fp->curr_clust);         /* Trace or streach cluster chain */   
   1014                              }   
   1015                              if (clust == 0) break;              /* Could not allocate a new cluster (disk full) */   
   1016                              if (clust == 1 || clust >= fp->fs->max_clust) goto fw_error;   
   1017                              fp->curr_clust = clust;              /* Update current cluster */   
   1018                              fp->csect = 0;                       /* Reset sector address in the cluster */   
   1019                          }   
   1020                          sect = clust2sect(fp->fs, fp->curr_clust) + fp->csect; /* Get current sector */   
   1021                          cc = btw / SS(fp->fs);                   /* When remaining bytes >= sector size, */   
   1022                          if (cc) {                               /* Write maximum contiguous sectors directly */   
   1023                              if (fp->csect + cc > fp->fs->csize) /* Clip at cluster boundary */   
   1024                                  cc = fp->fs->csize - fp->csect;   
   1025                              if (disk_write(fp->fs->drive, wbuff, sect, (BYTE)cc) != RES_OK)   
   1026                                  goto fw_error;   
   1027                              fp->csect += (BYTE)cc;               /* Next sector address in the cluster */   
   1028                              wcnt = SS(fp->fs) * cc;              /* Number of bytes transferred */   
   1029                              continue;   
   1030                          }   
   1031                          if (sect != fp->curr_sect) {         /* Is window offset changed? */   
   \                     ??f_write_4: (+1)
   \   0000003C   0x69AA             LDR      R2,[R5, #+24]
   \   0000003E   0x4294             CMP      R4,R2
   \   00000040   0xD020             BEQ.N    ??f_write_5
   1032                              if (fp->flag & FA__DIRTY) {          /* Write back file I/O buffer if needed */   
   \   00000042   0x78A9             LDRB     R1,[R5, #+2]
   \   00000044   0x0649             LSLS     R1,R1,#+25
   \   00000046   0xD50D             BPL.N    ??f_write_6
   1033                                  if (disk_write(fp->fs->drive, fp->buffer, fp->curr_sect, 1) != RES_OK)   
   \   00000048   0x302B             ADDS     R0,R0,#+43
   \   0000004A   0x2301             MOVS     R3,#+1
   \   0000004C   0x7880             LDRB     R0,[R0, #+2]
   \   0000004E   0xF105 0x0124      ADD      R1,R5,#+36
   \   00000052   0x.... 0x....      BL       disk_write
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xF040 0x808B      BNE.W    ??f_write_7
   1034                                      goto fw_error;   
   1035                                  fp->flag &= (BYTE)~FA__DIRTY;   
   \   0000005C   0x78A8             LDRB     R0,[R5, #+2]
   \   0000005E   0xF000 0x00BF      AND      R0,R0,#0xBF
   \   00000062   0x70A8             STRB     R0,[R5, #+2]
   1036                              }   
   1037                              if (fp->fptr < fp->fsize &&        /* Fill file I/O buffer with file data */   
   1038                                  disk_read(fp->fs->drive, fp->buffer, sect, 1) != RES_OK)   
   \                     ??f_write_6: (+1)
   \   00000064   0x68A8             LDR      R0,[R5, #+8]
   \   00000066   0x68E9             LDR      R1,[R5, #+12]
   \   00000068   0x4288             CMP      R0,R1
   \   0000006A   0xD20A             BCS.N    ??f_write_8
   \   0000006C   0x6868             LDR      R0,[R5, #+4]
   \   0000006E   0xF890 0x002D      LDRB     R0,[R0, #+45]
   \   00000072   0x2301             MOVS     R3,#+1
   \   00000074   0x4622             MOV      R2,R4
   \   00000076   0xF105 0x0124      ADD      R1,R5,#+36
   \   0000007A   0x.... 0x....      BL       disk_read
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD177             BNE.N    ??f_write_7
   1039                                      goto fw_error;   
   1040                              fp->curr_sect = sect;   
   \                     ??f_write_8: (+1)
   \   00000082   0x61AC             STR      R4,[R5, #+24]
   1041                          }   
   1042                          fp->csect++;                         /* Next sector address in the cluster */   
   \                     ??f_write_5: (+1)
   \   00000084   0x78E8             LDRB     R0,[R5, #+3]
   \   00000086   0x1C40             ADDS     R0,R0,#+1
   \   00000088   0x70E8             STRB     R0,[R5, #+3]
   1043                      }   
   1044                      wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));   /* Put partial sector into file I/O buffer */   
   \                     ??f_write_9: (+1)
   \   0000008A   0x68A8             LDR      R0,[R5, #+8]
   \   0000008C   0x05C1             LSLS     R1,R0,#+23
   \   0000008E   0x0DC9             LSRS     R1,R1,#+23
   \   00000090   0xF5C1 0x7400      RSB      R4,R1,#+512
   \   00000094   0xB2A4             UXTH     R4,R4
   1045                      if (wcnt > btw) wcnt = btw;   
   \   00000096   0x42A6             CMP      R6,R4
   \   00000098   0xBFB8             IT       LT 
   \   0000009A   0x4634             MOVLT    R4,R6
   1046                      memcpy(&fp->buffer[fp->fptr % SS(fp->fs)], wbuff, wcnt);   
   \   0000009C   0x05C0             LSLS     R0,R0,#+23
   \   0000009E   0xEB15 0x50D0      ADDS     R0,R5,R0, LSR #+23
   \   000000A2   0x4622             MOV      R2,R4
   \   000000A4   0x4641             MOV      R1,R8
   \   000000A6   0x3024             ADDS     R0,R0,#+36
   \   000000A8   0x.... 0x....      BL       __aeabi_memcpy
   1047                      fp->flag |= FA__DIRTY;   
   \   000000AC   0x78A8             LDRB     R0,[R5, #+2]
   \   000000AE   0xF040 0x0040      ORR      R0,R0,#0x40
   \   000000B2   0x70A8             STRB     R0,[R5, #+2]
   \                     ??f_write_10: (+1)
   \   000000B4   0x44A0             ADD      R8,R4,R8
   \   000000B6   0x68A8             LDR      R0,[R5, #+8]
   \   000000B8   0x1820             ADDS     R0,R4,R0
   \   000000BA   0x60A8             STR      R0,[R5, #+8]
   \   000000BC   0x1B36             SUBS     R6,R6,R4
   \   000000BE   0xF8B9 0x0000      LDRH     R0,[R9, #+0]
   \   000000C2   0x1820             ADDS     R0,R4,R0
   \   000000C4   0xF8A9 0x0000      STRH     R0,[R9, #+0]
   \                     ??f_write_2: (+1)
   \   000000C8   0xB2B6             UXTH     R6,R6
   \   000000CA   0x2E00             CMP      R6,#+0
   \   000000CC   0xD045             BEQ.N    ??f_write_11
   \   000000CE   0x68A8             LDR      R0,[R5, #+8]
   \   000000D0   0x05C1             LSLS     R1,R0,#+23
   \   000000D2   0xD1DA             BNE.N    ??f_write_9
   \   000000D4   0x686A             LDR      R2,[R5, #+4]
   \   000000D6   0x78E9             LDRB     R1,[R5, #+3]
   \   000000D8   0xF892 0x302B      LDRB     R3,[R2, #+43]
   \   000000DC   0x4299             CMP      R1,R3
   \   000000DE   0xD316             BCC.N    ??f_write_12
   \   000000E0   0xB938             CBNZ.N   R0,??f_write_13
   \   000000E2   0x6928             LDR      R0,[R5, #+16]
   \   000000E4   0xB948             CBNZ.N   R0,??f_write_14
   \   000000E6   0x2100             MOVS     R1,#+0
   \   000000E8   0x4610             MOV      R0,R2
   \   000000EA   0x.... 0x....      BL       create_chain
   \   000000EE   0x6128             STR      R0,[R5, #+16]
   \   000000F0   0xE003             B.N      ??f_write_14
   \                     ??f_write_13: (+1)
   \   000000F2   0x6969             LDR      R1,[R5, #+20]
   \   000000F4   0x4610             MOV      R0,R2
   \   000000F6   0x.... 0x....      BL       create_chain
   \                     ??f_write_14: (+1)
   \   000000FA   0xB370             CBZ.N    R0,??f_write_11
   \   000000FC   0x2801             CMP      R0,#+1
   \   000000FE   0xD038             BEQ.N    ??f_write_7
   \   00000100   0x6869             LDR      R1,[R5, #+4]
   \   00000102   0x68C9             LDR      R1,[R1, #+12]
   \   00000104   0x4288             CMP      R0,R1
   \   00000106   0xD234             BCS.N    ??f_write_7
   \   00000108   0x6168             STR      R0,[R5, #+20]
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0x70E8             STRB     R0,[R5, #+3]
   \                     ??f_write_12: (+1)
   \   0000010E   0x6868             LDR      R0,[R5, #+4]
   \   00000110   0x6969             LDR      R1,[R5, #+20]
   \   00000112   0xF100 0x020C      ADD      R2,R0,#+12
   \   00000116   0x1E89             SUBS     R1,R1,#+2
   \   00000118   0x6813             LDR      R3,[R2, #+0]
   \   0000011A   0x1E9B             SUBS     R3,R3,#+2
   \   0000011C   0x4299             CMP      R1,R3
   \   0000011E   0xBF2F             ITEEE    CS 
   \   00000120   0x2100             MOVCS    R1,#+0
   \   00000122   0x7FD3             LDRBCC   R3,[R2, #+31]
   \   00000124   0x68D2             LDRCC    R2,[R2, #+12]
   \   00000126   0xFB03 0x2101      MLACC    R1,R3,R1,R2
   \   0000012A   0x78EA             LDRB     R2,[R5, #+3]
   \   0000012C   0x1854             ADDS     R4,R2,R1
   \   0000012E   0x0A77             LSRS     R7,R6,#+9
   \   00000130   0xD084             BEQ.N    ??f_write_4
   \   00000132   0xF810 0x1F2B      LDRB     R1,[R0, #+43]!
   \   00000136   0x18BB             ADDS     R3,R7,R2
   \   00000138   0x4299             CMP      R1,R3
   \   0000013A   0xBFBC             ITT      LT 
   \   0000013C   0x1A8F             SUBLT    R7,R1,R2
   \   0000013E   0xB2BF             UXTHLT   R7,R7
   \   00000140   0x7880             LDRB     R0,[R0, #+2]
   \   00000142   0xB2FB             UXTB     R3,R7
   \   00000144   0x4622             MOV      R2,R4
   \   00000146   0x4641             MOV      R1,R8
   \   00000148   0x.... 0x....      BL       disk_write
   \   0000014C   0xB988             CBNZ.N   R0,??f_write_7
   \   0000014E   0x78E8             LDRB     R0,[R5, #+3]
   \   00000150   0x1838             ADDS     R0,R7,R0
   \   00000152   0x027C             LSLS     R4,R7,#+9
   \   00000154   0x70E8             STRB     R0,[R5, #+3]
   \   00000156   0xB2A4             UXTH     R4,R4
   \   00000158   0xE7AC             B.N      ??f_write_10
   1048                  }   
   1049                 
   1050                  if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;  /* Update file size if needed */   
   \                     ??f_write_11: (+1)
   \   0000015A   0x68E8             LDR      R0,[R5, #+12]
   \   0000015C   0x68A9             LDR      R1,[R5, #+8]
   \   0000015E   0x4288             CMP      R0,R1
   \   00000160   0xBF38             IT       CC 
   \   00000162   0x4608             MOVCC    R0,R1
   \   00000164   0x60E8             STR      R0,[R5, #+12]
   1051                  fp->flag |= FA__WRITTEN;                     /* Set file changed flag */   
   \   00000166   0x78A8             LDRB     R0,[R5, #+2]
   \   00000168   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000016C   0x70A8             STRB     R0,[R5, #+2]
   1052                  return FR_OK;   
   \                     ??f_write_3: (+1)
   \   0000016E   0x.... 0x....      B.W      ?Subroutine1
   1053                 
   1054              fw_error:   /* Abort this file due to an unrecoverable error */   
   1055                  fp->flag |= FA__ERROR;   
   \                     ??f_write_7: (+1)
   \   00000172   0x78A8             LDRB     R0,[R5, #+2]
   \   00000174   0xF040 0x0080      ORR      R0,R0,#0x80
   \   00000178   0x70A8             STRB     R0,[R5, #+2]
   1056                  return FR_RW_ERROR;   
   \                     ??f_write_1: (+1)
   \   0000017A   0x2008             MOVS     R0,#+8
   \                     ??f_write_0: (+1)
   \   0000017C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1057              }   
   1058                 
   1059                 
   1060                 
   1061                 
   1062              /*-----------------------------------------------------------------------*/   
   1063              /* Synchronize the file object                                           */   
   1064              /*-----------------------------------------------------------------------*/   
   1065                 

   \                                 In section .text, align 2, keep-with-next
   1066              FRESULT f_sync (   
   1067                  FIL *fp     /* Pointer to the file object */   
   1068              )   
   1069              {   
   \                     f_sync: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1070                  FRESULT res;   
   1071                  DWORD tim;   
   1072                  BYTE *dir;   
   1073                 
   1074                 
   1075                  res = validate(fp->fs, fp->id);       /* Check validity of the object */   
   \   00000004   0x8821             LDRH     R1,[R4, #+0]
   \   00000006   0x6860             LDR      R0,[R4, #+4]
   \   00000008   0x.... 0x....      BL       validate
   1076                  if (res == FR_OK) {   
   \   0000000C   0xBB88             CBNZ.N   R0,??f_sync_0
   1077                      if (fp->flag & FA__WRITTEN) {    /* Has the file been written? */   
   \   0000000E   0x78A1             LDRB     R1,[R4, #+2]
   \   00000010   0x068A             LSLS     R2,R1,#+26
   \   00000012   0xD52E             BPL.N    ??f_sync_0
   1078                          /* Write back data buffer if needed */   
   1079                          if (fp->flag & FA__DIRTY) {   
   \   00000014   0x0648             LSLS     R0,R1,#+25
   \   00000016   0xD50D             BPL.N    ??f_sync_1
   1080                              if (disk_write(fp->fs->drive, fp->buffer, fp->curr_sect, 1) != RES_OK)   
   \   00000018   0x6860             LDR      R0,[R4, #+4]
   \   0000001A   0x69A2             LDR      R2,[R4, #+24]
   \   0000001C   0xF890 0x002D      LDRB     R0,[R0, #+45]
   \   00000020   0x2301             MOVS     R3,#+1
   \   00000022   0xF104 0x0124      ADD      R1,R4,#+36
   \   00000026   0x.... 0x....      BL       disk_write
   \   0000002A   0xB940             CBNZ.N   R0,??f_sync_2
   1081                                  return FR_RW_ERROR;   
   1082                              fp->flag &= (BYTE)~FA__DIRTY;   
   \   0000002C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000002E   0xF000 0x00BF      AND      R0,R0,#0xBF
   \   00000032   0x70A0             STRB     R0,[R4, #+2]
   1083                          }   
   1084                          /* Update the directory entry */   
   1085                          if (!move_window(fp->fs, fp->dir_sect))   
   \                     ??f_sync_1: (+1)
   \   00000034   0x69E1             LDR      R1,[R4, #+28]
   \   00000036   0x6860             LDR      R0,[R4, #+4]
   \   00000038   0x.... 0x....      BL       move_window
   \   0000003C   0xB908             CBNZ.N   R0,??f_sync_3
   1086                              return FR_RW_ERROR;   
   \                     ??f_sync_2: (+1)
   \   0000003E   0x2008             MOVS     R0,#+8
   \   00000040   0xBD32             POP      {R1,R4,R5,PC}
   1087                          dir = fp->dir_ptr;   
   \                     ??f_sync_3: (+1)
   \   00000042   0x6A25             LDR      R5,[R4, #+32]
   1088                          dir[DIR_Attr] |= AM_ARC;                        /* Set archive bit */   
   \   00000044   0x7AE8             LDRB     R0,[R5, #+11]
   \   00000046   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000004A   0x72E8             STRB     R0,[R5, #+11]
   1089                          ST_DWORD(&dir[DIR_FileSize], fp->fsize);     /* Update file size */   
   \   0000004C   0x68E0             LDR      R0,[R4, #+12]
   \   0000004E   0x61E8             STR      R0,[R5, #+28]
   1090                          ST_WORD(&dir[DIR_FstClusLO], fp->org_clust); /* Update start cluster */   
   \   00000050   0x6920             LDR      R0,[R4, #+16]
   \   00000052   0x8368             STRH     R0,[R5, #+26]
   1091                          ST_WORD(&dir[DIR_FstClusHI], fp->org_clust >> 16);   
   \   00000054   0x0C00             LSRS     R0,R0,#+16
   \   00000056   0x82A8             STRH     R0,[R5, #+20]
   1092                          tim = get_fattime();                    /* Updated time */   
   1093                          ST_DWORD(&dir[DIR_WrtTime], tim);   
   \   00000058   0x.... 0x....      BL       get_fattime
   \   0000005C   0xF8C5 0x0016      STR      R0,[R5, #+22]
   1094                          fp->flag &= (BYTE)~FA__WRITTEN;   
   \   00000060   0x78A0             LDRB     R0,[R4, #+2]
   \   00000062   0xF000 0x00DF      AND      R0,R0,#0xDF
   \   00000066   0x70A0             STRB     R0,[R4, #+2]
   1095                          res = sync(fp->fs);   
   \   00000068   0x6860             LDR      R0,[R4, #+4]
   \   0000006A   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000006E   0x.... 0x....      B.W      sync
   1096                      }   
   1097                  }   
   1098                  return res;   
   \                     ??f_sync_0: (+1)
   \   00000072   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1099              }   
   1100                 
   1101              #endif /* !_FS_READONLY */   
   1102                 
   1103                 
   1104                 
   1105                 
   1106              /*-----------------------------------------------------------------------*/   
   1107              /* Close File                                                            */   
   1108              /*-----------------------------------------------------------------------*/   
   1109                 

   \                                 In section .text, align 2, keep-with-next
   1110              FRESULT f_close (   
   1111                  FIL *fp     /* Pointer to the file object to be closed */   
   1112              )   
   1113              {   
   \                     f_close: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1114                  FRESULT res;   
   1115                 
   1116                 
   1117              #if !_FS_READONLY   
   1118                  res = f_sync(fp);   
   \   00000004   0x.... 0x....      BL       f_sync
   1119              #else   
   1120                  res = validate(fp->fs, fp->id);   
   1121              #endif   
   1122                  if (res == FR_OK) fp->fs = NULL;   
   \   00000008   0xB908             CBNZ.N   R0,??f_close_0
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6061             STR      R1,[R4, #+4]
   1123                  return res;   
   \                     ??f_close_0: (+1)
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
   1124              }   
   1125                 
   1126                 
   1127                 
   1128                 
   1129              #if _FS_MINIMIZE <= 2   
   1130              /*-----------------------------------------------------------------------*/   
   1131              /* Seek File R/W Pointer                                                 */   
   1132              /*-----------------------------------------------------------------------*/   
   1133                 

   \                                 In section .text, align 2, keep-with-next
   1134              FRESULT f_lseek (   
   1135                  FIL *fp,        /* Pointer to the file object */   
   1136                  DWORD ofs       /* File pointer from top of file */   
   1137              )   
   1138              {   
   \                     f_lseek: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1139                  FRESULT res;   
   1140                  DWORD clust, csize, nsect, ifptr;   
   1141                 
   1142                 
   1143                  res = validate(fp->fs, fp->id);       /* Check validity of the object */   
   \   00000006   0x8821             LDRH     R1,[R4, #+0]
   \   00000008   0x6860             LDR      R0,[R4, #+4]
   \   0000000A   0x.... 0x....      BL       validate
   1144                  if (res != FR_OK) return res;   
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xF040 0x8089      BNE.W    ??f_lseek_0
   1145                  if (fp->flag & FA__ERROR) return FR_RW_ERROR;   
   \   00000014   0x78A0             LDRB     R0,[R4, #+2]
   \   00000016   0x0601             LSLS     R1,R0,#+24
   \   00000018   0xF100 0x8084      BMI.W    ??f_lseek_1
   1146                  if (ofs > fp->fsize                   /* In read-only mode, clip offset with the file size */   
   1147              #if !_FS_READONLY   
   1148                       && !(fp->flag & FA_WRITE)   
   1149              #endif   
   1150                      ) ofs = fp->fsize;   
   \   0000001C   0x68E1             LDR      R1,[R4, #+12]
   \   0000001E   0x42A9             CMP      R1,R5
   \   00000020   0xD202             BCS.N    ??f_lseek_2
   \   00000022   0x0780             LSLS     R0,R0,#+30
   \   00000024   0xBF58             IT       PL 
   \   00000026   0x460D             MOVPL    R5,R1
   1151                 
   1152                  ifptr = fp->fptr;   
   \                     ??f_lseek_2: (+1)
   \   00000028   0x68A0             LDR      R0,[R4, #+8]
   1153                  fp->fptr = 0; fp->csect = 255;   
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x60A1             STR      R1,[R4, #+8]
   \   0000002E   0x21FF             MOVS     R1,#+255
   1154                  nsect = 0;   
   1155                  if (ofs > 0) {   
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0x70E1             STRB     R1,[R4, #+3]
   \   00000034   0xD067             BEQ.N    ??f_lseek_3
   1156                      csize = (DWORD)fp->fs->csize * SS(fp->fs); /* Cluster size (byte) */   
   \   00000036   0x6862             LDR      R2,[R4, #+4]
   \   00000038   0xF892 0x102B      LDRB     R1,[R2, #+43]
   \   0000003C   0x024E             LSLS     R6,R1,#+9
   1157                      if (ifptr > 0 &&   
   1158                          (ofs - 1) / csize >= (ifptr - 1) / csize) {/* When seek to same or following cluster, */   
   \   0000003E   0xB168             CBZ.N    R0,??f_lseek_4
   \   00000040   0x1E40             SUBS     R0,R0,#+1
   \   00000042   0x1E6B             SUBS     R3,R5,#+1
   \   00000044   0xFBB0 0xF1F6      UDIV     R1,R0,R6
   \   00000048   0xFBB3 0xF3F6      UDIV     R3,R3,R6
   \   0000004C   0x428B             CMP      R3,R1
   \   0000004E   0xD305             BCC.N    ??f_lseek_4
   1159                          fp->fptr = (ifptr - 1) & ~(csize - 1);   /* start from the current cluster */   
   \   00000050   0x1E71             SUBS     R1,R6,#+1
   \   00000052   0x4388             BICS     R0,R0,R1
   \   00000054   0x60A0             STR      R0,[R4, #+8]
   1160                          ofs -= fp->fptr;   
   \   00000056   0x1A2D             SUBS     R5,R5,R0
   1161                          clust = fp->curr_clust;   
   \   00000058   0x6960             LDR      R0,[R4, #+20]
   \   0000005A   0xE009             B.N      ??f_lseek_5
   1162                      } else {                                    /* When seek to back cluster, */   
   1163                          clust = fp->org_clust;                   /* start from the first cluster */   
   \                     ??f_lseek_4: (+1)
   \   0000005C   0x6920             LDR      R0,[R4, #+16]
   1164              #if !_FS_READONLY   
   1165                          if (clust == 0) {                       /* If no cluster chain, create a new chain */   
   \   0000005E   0xB930             CBNZ.N   R0,??f_lseek_6
   1166                              clust = create_chain(fp->fs, 0);   
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x4610             MOV      R0,R2
   \   00000064   0x.... 0x....      BL       create_chain
   1167                              if (clust == 1) goto fk_error;   
   \   00000068   0x2801             CMP      R0,#+1
   \   0000006A   0xD057             BEQ.N    ??f_lseek_7
   1168                              fp->org_clust = clust;   
   \   0000006C   0x6120             STR      R0,[R4, #+16]
   1169                          }   
   1170              #endif   
   1171                          fp->curr_clust = clust;   
   \                     ??f_lseek_6: (+1)
   \   0000006E   0x6160             STR      R0,[R4, #+20]
   1172                      }   
   1173                      if (clust != 0) {   
   \                     ??f_lseek_5: (+1)
   \   00000070   0xB968             CBNZ.N   R0,??f_lseek_8
   \   00000072   0xE048             B.N      ??f_lseek_3
   1174                          while (ofs > csize) {                    /* Cluster following loop */   
   1175              #if !_FS_READONLY   
   1176                              if (fp->flag & FA_WRITE) {           /* Check if in write mode or not */   
   1177                                  clust = create_chain(fp->fs, clust); /* Force streached if in write mode */   
   1178                                  if (clust == 0) {               /* When disk gets full, clip file size */   
   1179                                      ofs = csize; break;   
   1180                                  }   
   1181                              } else   
   1182              #endif   
   1183                                  clust = get_cluster(fp->fs, clust);  /* Follow cluster chain if not in write mode */   
   \                     ??f_lseek_9: (+1)
   \   00000074   0x.... 0x....      BL       get_cluster
   1184                              if (clust < 2 || clust >= fp->fs->max_clust) goto fk_error;   
   \                     ??f_lseek_10: (+1)
   \   00000078   0x2802             CMP      R0,#+2
   \   0000007A   0xD34F             BCC.N    ??f_lseek_7
   \   0000007C   0x6861             LDR      R1,[R4, #+4]
   \   0000007E   0x68C9             LDR      R1,[R1, #+12]
   \   00000080   0x4288             CMP      R0,R1
   \   00000082   0xD24B             BCS.N    ??f_lseek_7
   1185                              fp->curr_clust = clust;   
   1186                              fp->fptr += csize;   
   \   00000084   0x68A1             LDR      R1,[R4, #+8]
   \   00000086   0x6160             STR      R0,[R4, #+20]
   \   00000088   0x1871             ADDS     R1,R6,R1
   \   0000008A   0x60A1             STR      R1,[R4, #+8]
   1187                              ofs -= csize;   
   \   0000008C   0x1BAD             SUBS     R5,R5,R6
   \                     ??f_lseek_8: (+1)
   \   0000008E   0x42AE             CMP      R6,R5
   \   00000090   0xD20A             BCS.N    ??f_lseek_11
   \   00000092   0x78A1             LDRB     R1,[R4, #+2]
   \   00000094   0x6862             LDR      R2,[R4, #+4]
   \   00000096   0x0789             LSLS     R1,R1,#+30
   \   00000098   0x4601             MOV      R1,R0
   \   0000009A   0x4610             MOV      R0,R2
   \   0000009C   0xD5EA             BPL.N    ??f_lseek_9
   \   0000009E   0x.... 0x....      BL       create_chain
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD1E8             BNE.N    ??f_lseek_10
   \   000000A6   0x4635             MOV      R5,R6
   1188                          }   
   1189                          fp->fptr += ofs;   
   \                     ??f_lseek_11: (+1)
   \   000000A8   0x68A1             LDR      R1,[R4, #+8]
   \   000000AA   0x1869             ADDS     R1,R5,R1
   \   000000AC   0x60A1             STR      R1,[R4, #+8]
   1190                          fp->csect = (BYTE)(ofs / SS(fp->fs)); /* Sector offset in the cluster */   
   \   000000AE   0x0A69             LSRS     R1,R5,#+9
   \   000000B0   0x70E1             STRB     R1,[R4, #+3]
   1191                          if (ofs & (SS(fp->fs) - 1)) {   
   \   000000B2   0x05E9             LSLS     R1,R5,#+23
   \   000000B4   0xD027             BEQ.N    ??f_lseek_3
   1192                              nsect = clust2sect(fp->fs, clust) + fp->csect;    /* Current sector */   
   \   000000B6   0x4601             MOV      R1,R0
   \   000000B8   0x6860             LDR      R0,[R4, #+4]
   \   000000BA   0x.... 0x....      BL       clust2sect
   \   000000BE   0x78E1             LDRB     R1,[R4, #+3]
   \   000000C0   0x180D             ADDS     R5,R1,R0
   1193                              fp->csect++;   
   \   000000C2   0x1C48             ADDS     R0,R1,#+1
   \   000000C4   0x70E0             STRB     R0,[R4, #+3]
   1194                          }   
   1195                      }   
   1196                  }   
   1197                  if (nsect && nsect != fp->curr_sect) {   
   \   000000C6   0x2D00             CMP      R5,#+0
   \   000000C8   0xBF1C             ITT      NE 
   \   000000CA   0x69A2             LDRNE    R2,[R4, #+24]
   \   000000CC   0x4295             CMPNE    R5,R2
   \   000000CE   0xD01A             BEQ.N    ??f_lseek_3
   1198              #if !_FS_READONLY   
   1199                      if (fp->flag & FA__DIRTY) {          /* Write-back dirty buffer if needed */   
   \   000000D0   0x78A0             LDRB     R0,[R4, #+2]
   \   000000D2   0x0640             LSLS     R0,R0,#+25
   \   000000D4   0xD50C             BPL.N    ??f_lseek_12
   1200                          if (disk_write(fp->fs->drive, fp->buffer, fp->curr_sect, 1) != RES_OK)   
   \   000000D6   0x6860             LDR      R0,[R4, #+4]
   \   000000D8   0xF890 0x002D      LDRB     R0,[R0, #+45]
   \   000000DC   0x2301             MOVS     R3,#+1
   \   000000DE   0xF104 0x0124      ADD      R1,R4,#+36
   \   000000E2   0x.... 0x....      BL       disk_write
   \   000000E6   0xB9C8             CBNZ.N   R0,??f_lseek_7
   1201                              goto fk_error;   
   1202                          fp->flag &= (BYTE)~FA__DIRTY;   
   \   000000E8   0x78A0             LDRB     R0,[R4, #+2]
   \   000000EA   0xF000 0x00BF      AND      R0,R0,#0xBF
   \   000000EE   0x70A0             STRB     R0,[R4, #+2]
   1203                      }   
   1204              #endif   
   1205                      if (disk_read(fp->fs->drive, fp->buffer, nsect, 1) != RES_OK)   
   \                     ??f_lseek_12: (+1)
   \   000000F0   0x2301             MOVS     R3,#+1
   \   000000F2   0x6860             LDR      R0,[R4, #+4]
   \   000000F4   0xF890 0x002D      LDRB     R0,[R0, #+45]
   \   000000F8   0x462A             MOV      R2,R5
   \   000000FA   0xF104 0x0124      ADD      R1,R4,#+36
   \   000000FE   0x.... 0x....      BL       disk_read
   \   00000102   0xB958             CBNZ.N   R0,??f_lseek_7
   1206                          goto fk_error;   
   1207                      fp->curr_sect = nsect;   
   \   00000104   0x61A5             STR      R5,[R4, #+24]
   1208                  }   
   1209                 
   1210              #if !_FS_READONLY   
   1211                  if (fp->fptr > fp->fsize) {            /* Set changed flag if the file was extended */   
   \                     ??f_lseek_3: (+1)
   \   00000106   0x68A0             LDR      R0,[R4, #+8]
   \   00000108   0x68E1             LDR      R1,[R4, #+12]
   \   0000010A   0x4281             CMP      R1,R0
   \   0000010C   0xD204             BCS.N    ??f_lseek_13
   1212                      fp->fsize = fp->fptr;   
   \   0000010E   0x60E0             STR      R0,[R4, #+12]
   1213                      fp->flag |= FA__WRITTEN;   
   \   00000110   0x78A0             LDRB     R0,[R4, #+2]
   \   00000112   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000116   0x70A0             STRB     R0,[R4, #+2]
   1214                  }   
   1215              #endif   
   1216                 
   1217                  return FR_OK;   
   \                     ??f_lseek_13: (+1)
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0xBD70             POP      {R4-R6,PC}
   1218                 
   1219              fk_error:   /* Abort this file due to an unrecoverable error */   
   1220                  fp->flag |= FA__ERROR;   
   \                     ??f_lseek_7: (+1)
   \   0000011C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000011E   0xF040 0x0080      ORR      R0,R0,#0x80
   \   00000122   0x70A0             STRB     R0,[R4, #+2]
   1221                  return FR_RW_ERROR;   
   \                     ??f_lseek_1: (+1)
   \   00000124   0x2008             MOVS     R0,#+8
   \                     ??f_lseek_0: (+1)
   \   00000126   0xBD70             POP      {R4-R6,PC}       ;; return
   1222              }   
   1223                 
   1224                 
   1225                 
   1226                 
   1227              #if _FS_MINIMIZE <= 1   
   1228              /*-----------------------------------------------------------------------*/   
   1229              /* Create a directroy object                                             */   
   1230              /*-----------------------------------------------------------------------*/   
   1231                 

   \                                 In section .text, align 2, keep-with-next
   1232              FRESULT f_opendir (   
   1233                  DIR *dj,            /* Pointer to directory object to create */   
   1234                  const char *path    /* Pointer to the directory path */   
   1235              )   
   1236              {   
   \                     f_opendir: (+1)
   \   00000000   0xB532             PUSH     {R1,R4,R5,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x4604             MOV      R4,R0
   1237                  FRESULT res;   
   1238                  BYTE *dir;   
   1239                  char fn[8+3+1];   
   1240                 
   1241                 
   1242                  res = auto_mount(&path, &dj->fs, 0);   
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x1D21             ADDS     R1,R4,#+4
   \   0000000A   0xA804             ADD      R0,SP,#+16
   \   0000000C   0x.... 0x....      BL       auto_mount
   \   00000010   0x0005             MOVS     R5,R0
   1243                  if (res == FR_OK) {   
   \   00000012   0xD11E             BNE.N    ??f_opendir_0
   1244                      res = trace_path(dj, fn, path, &dir);   /* Trace the directory path */   
   \   00000014   0x9A04             LDR      R2,[SP, #+16]
   \   00000016   0x466B             MOV      R3,SP
   \   00000018   0xA901             ADD      R1,SP,#+4
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       trace_path
   \   00000020   0x0005             MOVS     R5,R0
   1245                      if (res == FR_OK) {                     /* Trace completed */   
   \   00000022   0xD116             BNE.N    ??f_opendir_0
   1246                          if (dir) {                          /* It is not the root dir */   
   \   00000024   0x9800             LDR      R0,[SP, #+0]
   \   00000026   0xB188             CBZ.N    R0,??f_opendir_1
   1247                              if (dir[DIR_Attr] & AM_DIR) {   /* The entry is a directory */   
   \   00000028   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000002A   0x06C0             LSLS     R0,R0,#+27
   \   0000002C   0xD50D             BPL.N    ??f_opendir_2
   1248                                  dj->clust = ((DWORD)LD_WORD(&dir[DIR_FstClusHI]) << 16) | LD_WORD(&dir[DIR_FstClusLO]);   
   \   0000002E   0x9800             LDR      R0,[SP, #+0]
   \   00000030   0x9900             LDR      R1,[SP, #+0]
   \   00000032   0x8A80             LDRH     R0,[R0, #+20]
   \   00000034   0x8B49             LDRH     R1,[R1, #+26]
   \   00000036   0xEA41 0x4100      ORR      R1,R1,R0, LSL #+16
   \   0000003A   0x60E1             STR      R1,[R4, #+12]
   1249                                  dj->sect = clust2sect(dj->fs, dj->clust);   
   \   0000003C   0x6860             LDR      R0,[R4, #+4]
   \   0000003E   0x.... 0x....      BL       clust2sect
   \   00000042   0x6120             STR      R0,[R4, #+16]
   1250                                  dj->index = 2;   
   \   00000044   0x2002             MOVS     R0,#+2
   \   00000046   0x8060             STRH     R0,[R4, #+2]
   \   00000048   0xE000             B.N      ??f_opendir_1
   1251                              } else {                        /* The entry is not a directory */   
   1252                                  res = FR_NO_FILE;   
   \                     ??f_opendir_2: (+1)
   \   0000004A   0x2502             MOVS     R5,#+2
   1253                              }   
   1254                          }   
   1255                          dj->id = dj->fs->id;   
   \                     ??f_opendir_1: (+1)
   \   0000004C   0x6860             LDR      R0,[R4, #+4]
   \   0000004E   0x8800             LDRH     R0,[R0, #+0]
   \   00000050   0x8020             STRH     R0,[R4, #+0]
   1256                      }   
   1257                  }   
   1258                 
   1259                  return res;   
   \                     ??f_opendir_0: (+1)
   \   00000052   0x4628             MOV      R0,R5
   \   00000054   0xB005             ADD      SP,SP,#+20
   \   00000056   0xBD30             POP      {R4,R5,PC}       ;; return
   1260              }   
   1261                 
   1262                 
   1263                 
   1264                 
   1265              /*-----------------------------------------------------------------------*/   
   1266              /* Read Directory Entry in Sequense                                      */   
   1267              /*-----------------------------------------------------------------------*/   
   1268                 

   \                                 In section .text, align 2, keep-with-next
   1269              FRESULT f_readdir (   
   1270                  DIR *dj,            /* Pointer to the directory object */   
   1271                  FILINFO *finfo      /* Pointer to file information to return */   
   1272              )   
   1273              {   
   \                     f_readdir: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1274                  BYTE *dir, c;   
   1275                      FRESULT res;   
   1276                 
   1277                 
   1278                  res = validate(dj->fs, dj->id);           /* Check validity of the object */   
   \   00000006   0x8821             LDRH     R1,[R4, #+0]
   \   00000008   0x6860             LDR      R0,[R4, #+4]
   \   0000000A   0x.... 0x....      BL       validate
   1279                  if (res != FR_OK) return res;   
   \   0000000E   0xBB20             CBNZ.N   R0,??f_readdir_0
   1280                 
   1281                  finfo->fname[0] = 0;   
   \   00000010   0x7268             STRB     R0,[R5, #+9]
   1282                  while (dj->sect) {   
   \                     ??f_readdir_1: (+1)
   \   00000012   0x6921             LDR      R1,[R4, #+16]
   \   00000014   0xB301             CBZ.N    R1,??f_readdir_2
   1283                      if (!move_window(dj->fs, dj->sect))   
   \   00000016   0x6860             LDR      R0,[R4, #+4]
   \   00000018   0x.... 0x....      BL       move_window
   \   0000001C   0xB908             CBNZ.N   R0,??f_readdir_3
   1284                          return FR_RW_ERROR;   
   \   0000001E   0x2008             MOVS     R0,#+8
   \   00000020   0xBD32             POP      {R1,R4,R5,PC}
   1285                      dir = &dj->fs->win[(dj->index & ((SS(dj->fs) - 1) >> 5)) * 32];   /* pointer to the directory entry */   
   \                     ??f_readdir_3: (+1)
   \   00000022   0x78A1             LDRB     R1,[R4, #+2]
   \   00000024   0x6860             LDR      R0,[R4, #+4]
   \   00000026   0xF001 0x010F      AND      R1,R1,#0xF
   \   0000002A   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   0000002E   0xF100 0x0130      ADD      R1,R0,#+48
   1286                      c = dir[DIR_Name];   
   \   00000032   0x7808             LDRB     R0,[R1, #+0]
   1287                      if (c == 0) break;                          /* Has it reached to end of dir? */   
   \   00000034   0xB180             CBZ.N    R0,??f_readdir_2
   1288                      if (c != 0xE5 && !(dir[DIR_Attr] & AM_VOL)) /* Is it a valid entry? */   
   \   00000036   0x28E5             CMP      R0,#+229
   \   00000038   0xD005             BEQ.N    ??f_readdir_4
   \   0000003A   0x7AC8             LDRB     R0,[R1, #+11]
   \   0000003C   0x0700             LSLS     R0,R0,#+28
   \   0000003E   0xBF5C             ITT      PL 
   1289                          get_fileinfo(finfo, dir);   
   \   00000040   0x4628             MOVPL    R0,R5
   \   00000042   0x.... 0x....      BLPL     get_fileinfo
   1290                      if (!next_dir_entry(dj)) dj->sect = 0;       /* Next entry */   
   \                     ??f_readdir_4: (+1)
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       next_dir_entry
   \   0000004C   0xB908             CBNZ.N   R0,??f_readdir_5
   \   0000004E   0x6120             STR      R0,[R4, #+16]
   \   00000050   0xE002             B.N      ??f_readdir_2
   1291                      if (finfo->fname[0]) break;                  /* Found valid entry */   
   \                     ??f_readdir_5: (+1)
   \   00000052   0x7A68             LDRB     R0,[R5, #+9]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD0DC             BEQ.N    ??f_readdir_1
   1292                  }   
   1293                 
   1294                  return FR_OK;   
   \                     ??f_readdir_2: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??f_readdir_0: (+1)
   \   0000005A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1295              }   
   1296                 
   1297                 
   1298                 
   1299                 
   1300              #if _FS_MINIMIZE == 0   
   1301              /*-----------------------------------------------------------------------*/   
   1302              /* Get File Status                                                       */   
   1303              /*-----------------------------------------------------------------------*/   
   1304                 

   \                                 In section .text, align 2, keep-with-next
   1305              FRESULT f_stat (   
   1306                  const char *path,   /* Pointer to the file path */   
   1307                  FILINFO *finfo      /* Pointer to file information to return */   
   1308              )   
   1309              {   
   \                     f_stat: (+1)
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x460C             MOV      R4,R1
   1310                  FRESULT res;   
   1311                  DIR dj;   
   1312                  BYTE *dir;   
   1313                  char fn[8+3+1];   
   1314                 
   1315                 
   1316                  res = auto_mount(&path, &dj.fs, 0);   
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0xA905             ADD      R1,SP,#+20
   \   0000000A   0xA80A             ADD      R0,SP,#+40
   \   0000000C   0x.... 0x....      BL       auto_mount
   \   00000010   0x0005             MOVS     R5,R0
   1317                  if (res == FR_OK) {   
   \   00000012   0xD10F             BNE.N    ??f_stat_0
   1318                      res = trace_path(&dj, fn, path, &dir);  /* Trace the file path */   
   \   00000014   0x9A0A             LDR      R2,[SP, #+40]
   \   00000016   0x466B             MOV      R3,SP
   \   00000018   0xA901             ADD      R1,SP,#+4
   \   0000001A   0xA804             ADD      R0,SP,#+16
   \   0000001C   0x.... 0x....      BL       trace_path
   \   00000020   0x0005             MOVS     R5,R0
   1319                      if (res == FR_OK) {                     /* Trace completed */   
   \   00000022   0xD107             BNE.N    ??f_stat_0
   1320                          if (dir)    /* Found an object */   
   \   00000024   0x9800             LDR      R0,[SP, #+0]
   \   00000026   0xB120             CBZ.N    R0,??f_stat_1
   1321                              get_fileinfo(finfo, dir);   
   \   00000028   0x4601             MOV      R1,R0
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       get_fileinfo
   \   00000030   0xE000             B.N      ??f_stat_0
   1322                          else        /* It is root dir */   
   1323                              res = FR_INVALID_NAME;   
   \                     ??f_stat_1: (+1)
   \   00000032   0x2504             MOVS     R5,#+4
   1324                      }   
   1325                  }   
   1326                 
   1327                  return res;   
   \                     ??f_stat_0: (+1)
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0xB00B             ADD      SP,SP,#+44
   \   00000038   0xBD30             POP      {R4,R5,PC}       ;; return
   1328              }   
   1329                 
   1330                 
   1331                 
   1332              #if !_FS_READONLY   
   1333              /*-----------------------------------------------------------------------*/   
   1334              /* Truncate File                                                         */   
   1335              /*-----------------------------------------------------------------------*/   
   1336                 

   \                                 In section .text, align 2, keep-with-next
   1337              FRESULT f_truncate (   
   1338                  FIL *fp     /* Pointer to the file object */   
   1339              )   
   1340              {   
   \                     f_truncate: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1341                  FRESULT res;   
   1342                  DWORD ncl;   
   1343                 
   1344                 
   1345                  res = validate(fp->fs, fp->id);       /* Check validity of the object */   
   \   00000004   0x8821             LDRH     R1,[R4, #+0]
   \   00000006   0x6860             LDR      R0,[R4, #+4]
   \   00000008   0x.... 0x....      BL       validate
   1346                  if (res != FR_OK) return res;   
   \   0000000C   0xBB98             CBNZ.N   R0,??f_truncate_0
   1347                  if (fp->flag & FA__ERROR) return FR_RW_ERROR;    /* Check error flag */   
   \   0000000E   0x78A0             LDRB     R0,[R4, #+2]
   \   00000010   0x0601             LSLS     R1,R0,#+24
   \   00000012   0xD42F             BMI.N    ??f_truncate_1
   1348                  if (!(fp->flag & FA_WRITE)) return FR_DENIED;    /* Check access mode */   
   \   00000014   0x0781             LSLS     R1,R0,#+30
   \   00000016   0xD401             BMI.N    ??f_truncate_2
   \   00000018   0x2006             MOVS     R0,#+6
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}
   1349                 
   1350                  if (fp->fsize > fp->fptr) {   
   \                     ??f_truncate_2: (+1)
   \   0000001C   0x68A1             LDR      R1,[R4, #+8]
   \   0000001E   0x68E2             LDR      R2,[R4, #+12]
   \   00000020   0x4291             CMP      R1,R2
   \   00000022   0xD221             BCS.N    ??f_truncate_3
   1351                      fp->fsize = fp->fptr; /* Set file size to current R/W point */   
   1352                      fp->flag |= FA__WRITTEN;   
   \   00000024   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000028   0x70A0             STRB     R0,[R4, #+2]
   \   0000002A   0x60E1             STR      R1,[R4, #+12]
   1353                      if (fp->fptr == 0) { /* When set file size to zero, remove entire cluster chain */   
   \   0000002C   0x6860             LDR      R0,[R4, #+4]
   \   0000002E   0xB931             CBNZ.N   R1,??f_truncate_4
   1354                          if (!remove_chain(fp->fs, fp->org_clust)) goto ft_error;   
   \   00000030   0x6921             LDR      R1,[R4, #+16]
   \   00000032   0x.... 0x....      BL       remove_chain
   \   00000036   0xB1C8             CBZ.N    R0,??f_truncate_5
   1355                          fp->org_clust = 0;   
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x6120             STR      R0,[R4, #+16]
   \   0000003C   0xE014             B.N      ??f_truncate_3
   1356                      } else {                /* When truncate a part of the file, remove remaining clusters */   
   1357                          ncl = get_cluster(fp->fs, fp->curr_clust);   
   \                     ??f_truncate_4: (+1)
   \   0000003E   0x6961             LDR      R1,[R4, #+20]
   \   00000040   0x.... 0x....      BL       get_cluster
   \   00000044   0x4605             MOV      R5,R0
   1358                          if (ncl < 2) goto ft_error;   
   \   00000046   0x2D02             CMP      R5,#+2
   \   00000048   0xD310             BCC.N    ??f_truncate_5
   1359                          if (ncl < fp->fs->max_clust) {   
   \   0000004A   0x6860             LDR      R0,[R4, #+4]
   \   0000004C   0x68C1             LDR      R1,[R0, #+12]
   \   0000004E   0x428D             CMP      R5,R1
   \   00000050   0xD20A             BCS.N    ??f_truncate_3
   1360                              if (!put_cluster(fp->fs, fp->curr_clust, 0x0FFFFFFF)) goto ft_error;   
   \   00000052   0x6961             LDR      R1,[R4, #+20]
   \   00000054   0xF06F 0x4270      MVN      R2,#-268435456
   \   00000058   0x.... 0x....      BL       put_cluster
   \   0000005C   0xB130             CBZ.N    R0,??f_truncate_5
   1361                              if (!remove_chain(fp->fs, ncl)) goto ft_error;   
   \   0000005E   0x6860             LDR      R0,[R4, #+4]
   \   00000060   0x4629             MOV      R1,R5
   \   00000062   0x.... 0x....      BL       remove_chain
   \   00000066   0xB108             CBZ.N    R0,??f_truncate_5
   1362                          }   
   1363                      }   
   1364                  }   
   1365                 
   1366                  return FR_OK;   
   \                     ??f_truncate_3: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xBD32             POP      {R1,R4,R5,PC}
   1367                 
   1368              ft_error:   /* Abort this file due to an unrecoverable error */   
   1369                  fp->flag |= FA__ERROR;   
   \                     ??f_truncate_5: (+1)
   \   0000006C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000006E   0xF040 0x0080      ORR      R0,R0,#0x80
   \   00000072   0x70A0             STRB     R0,[R4, #+2]
   1370                  return FR_RW_ERROR;   
   \                     ??f_truncate_1: (+1)
   \   00000074   0x2008             MOVS     R0,#+8
   \                     ??f_truncate_0: (+1)
   \   00000076   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1371              }   
   1372                 
   1373                 
   1374                 
   1375                 
   1376              /*-----------------------------------------------------------------------*/   
   1377              /* Get Number of Free Clusters                                           */   
   1378              /*-----------------------------------------------------------------------*/   
   1379                 

   \                                 In section .text, align 2, keep-with-next
   1380              FRESULT f_getfree (   
   1381                  const char *drv,    /* Pointer to the logical drive number (root dir) */   
   1382                  DWORD *nclust,      /* Pointer to the variable to return number of free clusters */   
   1383                  FATFS **fatfs       /* Pointer to pointer to corresponding file system object to return */   
   1384              )   
   1385              {   
   \                     f_getfree: (+1)
   \   00000000   0xE92D 0x47F1      PUSH     {R0,R4-R10,LR}
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4615             MOV      R5,R2
   1386                  FRESULT res;   
   1387                  DWORD n, clust, sect;   
   1388                  BYTE fat, f, *p;   
   1389                 
   1390                 
   1391                  /* Get drive number */   
   1392                  res = auto_mount(&drv, fatfs, 0);   
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x4629             MOV      R1,R5
   \   0000000E   0xA801             ADD      R0,SP,#+4
   \   00000010   0x.... 0x....      BL       auto_mount
   1393                  if (res != FR_OK) return res;   
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD14A             BNE.N    ??f_getfree_0
   1394                 
   1395                  /* If number of free cluster is valid, return it without cluster scan. */   
   1396                  if ((*fatfs)->free_clust <= (*fatfs)->max_clust - 2) {   
   \   00000018   0x6828             LDR      R0,[R5, #+0]
   \   0000001A   0x300C             ADDS     R0,R0,#+12
   \   0000001C   0x6806             LDR      R6,[R0, #+0]
   \   0000001E   0x6941             LDR      R1,[R0, #+20]
   \   00000020   0x1EB2             SUBS     R2,R6,#+2
   \   00000022   0x428A             CMP      R2,R1
   \   00000024   0xBF28             IT       CS 
   \   00000026   0xF8C8 0x1000      STRCS    R1,[R8, #+0]
   1397                      *nclust = (*fatfs)->free_clust;   
   1398                      return FR_OK;   
   \   0000002A   0xD23F             BCS.N    ??f_getfree_1
   1399                  }   
   1400                 
   1401                  /* Get number of free clusters */   
   1402                  fat = (*fatfs)->fs_type;   
   \   0000002C   0xF890 0xA01E      LDRB     R10,[R0, #+30]
   1403                  n = 0;   
   \   00000030   0x2400             MOVS     R4,#+0
   1404                  if (fat == FS_FAT12) {   
   \   00000032   0xF1BA 0x0F01      CMP      R10,#+1
   \   00000036   0xD10D             BNE.N    ??f_getfree_2
   1405                      clust = 2;   
   \   00000038   0x2602             MOVS     R6,#+2
   1406                      do {   
   1407                          if ((WORD)get_cluster(*fatfs, clust) == 0) n++;   
   \                     ??f_getfree_3: (+1)
   \   0000003A   0x6828             LDR      R0,[R5, #+0]
   \   0000003C   0x4631             MOV      R1,R6
   \   0000003E   0x.... 0x....      BL       get_cluster
   \   00000042   0xB280             UXTH     R0,R0
   \   00000044   0xB900             CBNZ.N   R0,??f_getfree_4
   \   00000046   0x1C64             ADDS     R4,R4,#+1
   1408                      } while (++clust < (*fatfs)->max_clust);   
   \                     ??f_getfree_4: (+1)
   \   00000048   0x6828             LDR      R0,[R5, #+0]
   \   0000004A   0x68C0             LDR      R0,[R0, #+12]
   \   0000004C   0x1C76             ADDS     R6,R6,#+1
   \   0000004E   0x4286             CMP      R6,R0
   \   00000050   0xD3F3             BCC.N    ??f_getfree_3
   \   00000052   0xE021             B.N      ??f_getfree_5
   1409                  } else {   
   1410                      clust = (*fatfs)->max_clust;   
   1411                      sect = (*fatfs)->fatbase;   
   \                     ??f_getfree_2: (+1)
   \   00000054   0xF8D0 0x9004      LDR      R9,[R0, #+4]
   1412                      f = 0; p = 0;   
   \   00000058   0x2700             MOVS     R7,#+0
   \   0000005A   0xE000             B.N      ??f_getfree_6
   1413                      do {   
   1414                          if (!f) {   
   \                     ??f_getfree_7: (+1)
   \   0000005C   0xB95F             CBNZ.N   R7,??f_getfree_8
   1415                              if (!move_window(*fatfs, sect++)) return FR_RW_ERROR;   
   \                     ??f_getfree_6: (+1)
   \   0000005E   0x6828             LDR      R0,[R5, #+0]
   \   00000060   0x4649             MOV      R1,R9
   \   00000062   0x.... 0x....      BL       move_window
   \   00000066   0xF109 0x0901      ADD      R9,R9,#+1
   \   0000006A   0xB910             CBNZ.N   R0,??f_getfree_9
   \   0000006C   0x2008             MOVS     R0,#+8
   \   0000006E   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
   1416                              p = (*fatfs)->win;   
   \                     ??f_getfree_9: (+1)
   \   00000072   0x6828             LDR      R0,[R5, #+0]
   \   00000074   0x3030             ADDS     R0,R0,#+48
   1417                          }   
   1418                          if (fat == FS_FAT16) {   
   \                     ??f_getfree_8: (+1)
   \   00000076   0xF1BA 0x0F02      CMP      R10,#+2
   \   0000007A   0xD105             BNE.N    ??f_getfree_10
   1419                              if (LD_WORD(p) == 0) n++;   
   \   0000007C   0x8801             LDRH     R1,[R0, #+0]
   \   0000007E   0xB901             CBNZ.N   R1,??f_getfree_11
   \   00000080   0x1C64             ADDS     R4,R4,#+1
   1420                              p += 2; f += 1;   
   \                     ??f_getfree_11: (+1)
   \   00000082   0x1C80             ADDS     R0,R0,#+2
   \   00000084   0x1C7F             ADDS     R7,R7,#+1
   \   00000086   0xE004             B.N      ??f_getfree_12
   1421                          } else {   
   1422                              if (LD_DWORD(p) == 0) n++;   
   \                     ??f_getfree_10: (+1)
   \   00000088   0x6801             LDR      R1,[R0, #+0]
   \   0000008A   0xB901             CBNZ.N   R1,??f_getfree_13
   \   0000008C   0x1C64             ADDS     R4,R4,#+1
   1423                              p += 4; f += 2;   
   \                     ??f_getfree_13: (+1)
   \   0000008E   0x1D00             ADDS     R0,R0,#+4
   \   00000090   0x1CBF             ADDS     R7,R7,#+2
   1424                          }   
   1425                      } while (--clust);   
   \                     ??f_getfree_12: (+1)
   \   00000092   0x1E76             SUBS     R6,R6,#+1
   \   00000094   0xB2FF             UXTB     R7,R7
   \   00000096   0xD1E1             BNE.N    ??f_getfree_7
   1426                  }   
   1427                  (*fatfs)->free_clust = n;   
   \                     ??f_getfree_5: (+1)
   \   00000098   0x6828             LDR      R0,[R5, #+0]
   \   0000009A   0xF840 0x4F20      STR      R4,[R0, #+32]!
   1428              #if _USE_FSINFO   
   1429                  if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;   
   \   0000009E   0xF1BA 0x0F03      CMP      R10,#+3
   \   000000A2   0xBF04             ITT      EQ 
   \   000000A4   0x2101             MOVEQ    R1,#+1
   \   000000A6   0x7201             STRBEQ   R1,[R0, #+8]
   1430              #endif   
   1431                 
   1432                  *nclust = n;   
   \   000000A8   0xF8C8 0x4000      STR      R4,[R8, #+0]
   1433                  return FR_OK;   
   \                     ??f_getfree_1: (+1)
   \   000000AC   0x2000             MOVS     R0,#+0
   \                     ??f_getfree_0: (+1)
   \   000000AE   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   1434              }   
   1435                 
   1436                 
   1437                 
   1438                 
   1439              /*-----------------------------------------------------------------------*/   
   1440              /* Delete a File or Directory                                            */   
   1441              /*-----------------------------------------------------------------------*/   
   1442                 

   \                                 In section .text, align 2, keep-with-next
   1443              FRESULT f_unlink (   
   1444                  const char *path        /* Pointer to the file or directory path */   
   1445              )   
   1446              {   
   \                     f_unlink: (+1)
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   1447                  FRESULT res;   
   1448                  DIR dj;   
   1449                  BYTE *dir, *sdir;   
   1450                  DWORD dclust, dsect;   
   1451                  char fn[8+3+1];   
   1452                 
   1453                 
   1454                  res = auto_mount(&path, &dj.fs, 1);   
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xA902             ADD      R1,SP,#+8
   \   00000008   0xA80A             ADD      R0,SP,#+40
   \   0000000A   0x.... 0x....      BL       auto_mount
   1455                  if (res != FR_OK) return res;   
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD153             BNE.N    ??f_unlink_0
   1456                  res = trace_path(&dj, fn, path, &dir);  /* Trace the file path */   
   \   00000012   0x9A0A             LDR      R2,[SP, #+40]
   \   00000014   0x466B             MOV      R3,SP
   \   00000016   0xA906             ADD      R1,SP,#+24
   \   00000018   0xA801             ADD      R0,SP,#+4
   \   0000001A   0x.... 0x....      BL       trace_path
   1457                  if (res != FR_OK) return res;           /* Trace failed */   
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD14B             BNE.N    ??f_unlink_0
   1458                  if (!dir) return FR_INVALID_NAME;       /* It is the root directory */   
   \   00000022   0x9800             LDR      R0,[SP, #+0]
   \   00000024   0xB900             CBNZ.N   R0,??f_unlink_1
   \   00000026   0x....             B.N      ?Subroutine6
   1459                  if (dir[DIR_Attr] & AM_RDO) return FR_DENIED;   /* It is a R/O object */   
   \                     ??f_unlink_1: (+1)
   \   00000028   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000002A   0x07C1             LSLS     R1,R0,#+31
   \   0000002C   0xD426             BMI.N    ??f_unlink_2
   1460                  dsect = dj.fs->winsect;   
   \   0000002E   0x9902             LDR      R1,[SP, #+8]
   \   00000030   0x684C             LDR      R4,[R1, #+4]
   1461                  dclust = ((DWORD)LD_WORD(&dir[DIR_FstClusHI]) << 16) | LD_WORD(&dir[DIR_FstClusLO]);   
   \   00000032   0x9900             LDR      R1,[SP, #+0]
   \   00000034   0x9A00             LDR      R2,[SP, #+0]
   \   00000036   0x8A89             LDRH     R1,[R1, #+20]
   \   00000038   0x8B52             LDRH     R2,[R2, #+26]
   1462                 
   1463                  if (dir[DIR_Attr] & AM_DIR) {           /* It is a sub-directory */   
   \   0000003A   0x06C0             LSLS     R0,R0,#+27
   \   0000003C   0xEA42 0x4501      ORR      R5,R2,R1, LSL #+16
   \   00000040   0xD524             BPL.N    ??f_unlink_3
   1464                      dj.clust = dclust;                  /* Check if the sub-dir is empty or not */   
   1465                      dj.sect = clust2sect(dj.fs, dclust);   
   \   00000042   0x9802             LDR      R0,[SP, #+8]
   \   00000044   0x9504             STR      R5,[SP, #+16]
   \   00000046   0x4629             MOV      R1,R5
   \   00000048   0x.... 0x....      BL       clust2sect
   \   0000004C   0x9005             STR      R0,[SP, #+20]
   1466                      dj.index = 2;   
   \   0000004E   0x2002             MOVS     R0,#+2
   \   00000050   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1467                      do {   
   1468                          if (!move_window(dj.fs, dj.sect)) return FR_RW_ERROR;   
   \                     ??f_unlink_4: (+1)
   \   00000054   0x9905             LDR      R1,[SP, #+20]
   \   00000056   0x9802             LDR      R0,[SP, #+8]
   \   00000058   0x.... 0x....      BL       move_window
   \   0000005C   0xB338             CBZ.N    R0,??f_unlink_5
   1469                          sdir = &dj.fs->win[(dj.index & ((SS(dj.fs) - 1) >> 5)) * 32];   
   \   0000005E   0xF89D 0x1006      LDRB     R1,[SP, #+6]
   \   00000062   0x9802             LDR      R0,[SP, #+8]
   \   00000064   0xF001 0x010F      AND      R1,R1,#0xF
   \   00000068   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   1470                          if (sdir[DIR_Name] == 0) break;   
   \   0000006C   0xF810 0x1F30      LDRB     R1,[R0, #+48]!
   \   00000070   0xB161             CBZ.N    R1,??f_unlink_3
   1471                          if (sdir[DIR_Name] != 0xE5 && !(sdir[DIR_Attr] & AM_VOL))   
   \   00000072   0x29E5             CMP      R1,#+229
   \   00000074   0xD005             BEQ.N    ??f_unlink_6
   \   00000076   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000078   0x0700             LSLS     R0,R0,#+28
   \   0000007A   0xD402             BMI.N    ??f_unlink_6
   1472                              return FR_DENIED;   /* The directory is not empty */   
   \                     ??f_unlink_2: (+1)
   \   0000007C   0x2006             MOVS     R0,#+6
   \   0000007E   0xB00B             ADD      SP,SP,#+44
   \   00000080   0xBD30             POP      {R4,R5,PC}
   1473                      } while (next_dir_entry(&dj));   
   \                     ??f_unlink_6: (+1)
   \   00000082   0xA801             ADD      R0,SP,#+4
   \   00000084   0x.... 0x....      BL       next_dir_entry
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD1E3             BNE.N    ??f_unlink_4
   1474                  }   
   1475                 
   1476                  if (!move_window(dj.fs, dsect)) return FR_RW_ERROR; /* Mark the directory entry 'deleted' */   
   \                     ??f_unlink_3: (+1)
   \   0000008C   0x9802             LDR      R0,[SP, #+8]
   \   0000008E   0x4621             MOV      R1,R4
   \   00000090   0x.... 0x....      BL       move_window
   \   00000094   0xB158             CBZ.N    R0,??f_unlink_5
   1477                  dir[DIR_Name] = 0xE5;   
   \   00000096   0x9900             LDR      R1,[SP, #+0]
   \   00000098   0x20E5             MOVS     R0,#+229
   \   0000009A   0x7008             STRB     R0,[R1, #+0]
   1478                  dj.fs->winflag = 1;   
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0x9902             LDR      R1,[SP, #+8]
   \   000000A0   0xF881 0x002E      STRB     R0,[R1, #+46]
   1479                  if (!remove_chain(dj.fs, dclust)) return FR_RW_ERROR;   /* Remove the cluster chain */   
   \   000000A4   0x4629             MOV      R1,R5
   \   000000A6   0x9802             LDR      R0,[SP, #+8]
   \   000000A8   0x.... 0x....      BL       remove_chain
   \   000000AC   0xB910             CBNZ.N   R0,??f_unlink_7
   \                     ??f_unlink_5: (+1)
   \   000000AE   0x2008             MOVS     R0,#+8
   \   000000B0   0xB00B             ADD      SP,SP,#+44
   \   000000B2   0xBD30             POP      {R4,R5,PC}
   1480                 
   1481                  return sync(dj.fs);   
   \                     ??f_unlink_7: (+1)
   \   000000B4   0x9802             LDR      R0,[SP, #+8]
   \   000000B6   0x.... 0x....      BL       sync
   \                     ??f_unlink_0: (+1)
   \   000000BA   0xB00B             ADD      SP,SP,#+44
   \   000000BC   0xBD30             POP      {R4,R5,PC}       ;; return
   1482              }   

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x2004             MOVS     R0,#+4
   \   00000002   0xB00B             ADD      SP,SP,#+44
   \   00000004   0xBD30             POP      {R4,R5,PC}
   1483                 
   1484                 
   1485                 
   1486                 
   1487              /*-----------------------------------------------------------------------*/   
   1488              /* Create a Directory                                                    */   
   1489              /*-----------------------------------------------------------------------*/   
   1490                 

   \                                 In section .text, align 2, keep-with-next
   1491              FRESULT f_mkdir (   
   1492                  const char *path        /* Pointer to the directory path */   
   1493              )   
   1494              {   
   \                     f_mkdir: (+1)
   \   00000000   0xE92D 0x41F1      PUSH     {R0,R4-R8,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   1495                  FRESULT res;   
   1496                  DIR dj;   
   1497                  BYTE *dir, *fw, n;   
   1498                  char fn[8+3+1];   
   1499                  DWORD sect, dsect, dclust, pclust, tim;   
   1500                 
   1501                 
   1502                  res = auto_mount(&path, &dj.fs, 1);   
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA902             ADD      R1,SP,#+8
   \   0000000A   0xA809             ADD      R0,SP,#+36
   \   0000000C   0x.... 0x....      BL       auto_mount
   1503                  if (res != FR_OK) return res;   
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xF040 0x8097      BNE.W    ??f_mkdir_0
   1504                  res = trace_path(&dj, fn, path, &dir);  /* Trace the file path */   
   \   00000016   0x9A09             LDR      R2,[SP, #+36]
   \   00000018   0x466B             MOV      R3,SP
   \   0000001A   0xA906             ADD      R1,SP,#+24
   \   0000001C   0xA801             ADD      R0,SP,#+4
   \   0000001E   0x.... 0x....      BL       trace_path
   1505                  if (res == FR_OK) return FR_EXIST;      /* Any file or directory is already existing */   
   \   00000022   0xB908             CBNZ.N   R0,??f_mkdir_1
   \   00000024   0x2007             MOVS     R0,#+7
   \   00000026   0x....             B.N      ?Subroutine2
   1506                  if (res != FR_NO_FILE) return res;   
   \                     ??f_mkdir_1: (+1)
   \   00000028   0x2802             CMP      R0,#+2
   \   0000002A   0xF040 0x808B      BNE.W    ??f_mkdir_0
   1507                 
   1508                  res = reserve_direntry(&dj, &dir);      /* Reserve a directory entry */   
   \   0000002E   0x4669             MOV      R1,SP
   \   00000030   0xA801             ADD      R0,SP,#+4
   \   00000032   0x.... 0x....      BL       reserve_direntry
   1509                  if (res != FR_OK) return res;   
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xF040 0x8084      BNE.W    ??f_mkdir_0
   1510                  sect = dj.fs->winsect;   
   \   0000003C   0x9802             LDR      R0,[SP, #+8]
   \   0000003E   0xF8D0 0x8004      LDR      R8,[R0, #+4]
   1511                  dclust = create_chain(dj.fs, 0);        /* Allocate a cluster for new directory table */   
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x.... 0x....      BL       create_chain
   \   00000048   0x4605             MOV      R5,R0
   1512                  if (dclust == 1) return FR_RW_ERROR;   
   \   0000004A   0x2D01             CMP      R5,#+1
   \   0000004C   0xD05E             BEQ.N    ??f_mkdir_2
   1513                  dsect = clust2sect(dj.fs, dclust);   
   \   0000004E   0x9802             LDR      R0,[SP, #+8]
   \   00000050   0xF100 0x020C      ADD      R2,R0,#+12
   \   00000054   0x1EA9             SUBS     R1,R5,#+2
   \   00000056   0x6813             LDR      R3,[R2, #+0]
   \   00000058   0x1E9B             SUBS     R3,R3,#+2
   \   0000005A   0x4299             CMP      R1,R3
   \   0000005C   0xBF2F             ITEEE    CS 
   \   0000005E   0x2700             MOVCS    R7,#+0
   \   00000060   0x7FD3             LDRBCC   R3,[R2, #+31]
   \   00000062   0x68D2             LDRCC    R2,[R2, #+12]
   \   00000064   0xFB03 0x2701      MLACC    R7,R3,R1,R2
   1514                  if (!dsect) return FR_DENIED;   
   \   00000068   0xB90F             CBNZ.N   R7,??f_mkdir_3
   \   0000006A   0x2006             MOVS     R0,#+6
   \   0000006C   0x....             B.N      ?Subroutine2
   1515                  if (!move_window(dj.fs, dsect)) return FR_RW_ERROR;   
   \                     ??f_mkdir_3: (+1)
   \   0000006E   0x4639             MOV      R1,R7
   \   00000070   0x.... 0x....      BL       move_window
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD049             BEQ.N    ??f_mkdir_2
   1516                 
   1517                  fw = dj.fs->win;   
   \   00000078   0x9802             LDR      R0,[SP, #+8]
   \   0000007A   0xF100 0x0630      ADD      R6,R0,#+48
   1518                  memset(fw, 0, SS(dj.fs));               /* Clear the new directory table */   
   \   0000007E   0xF44F 0x7100      MOV      R1,#+512
   \   00000082   0x4630             MOV      R0,R6
   \   00000084   0x.... 0x....      BL       __aeabi_memclr
   1519                  for (n = 1; n < dj.fs->csize; n++) {   
   \   00000088   0x2401             MOVS     R4,#+1
   \   0000008A   0xE000             B.N      ??f_mkdir_4
   \                     ??f_mkdir_5: (+1)
   \   0000008C   0x1C64             ADDS     R4,R4,#+1
   \                     ??f_mkdir_4: (+1)
   \   0000008E   0x9802             LDR      R0,[SP, #+8]
   \   00000090   0xF810 0x1F2B      LDRB     R1,[R0, #+43]!
   \   00000094   0xB2E4             UXTB     R4,R4
   \   00000096   0x428C             CMP      R4,R1
   \   00000098   0xD209             BCS.N    ??f_mkdir_6
   1520                      if (disk_write(dj.fs->drive, fw, ++dsect, 1) != RES_OK)   
   \   0000009A   0x1C7F             ADDS     R7,R7,#+1
   \   0000009C   0x7880             LDRB     R0,[R0, #+2]
   \   0000009E   0x2301             MOVS     R3,#+1
   \   000000A0   0x463A             MOV      R2,R7
   \   000000A2   0x4631             MOV      R1,R6
   \   000000A4   0x.... 0x....      BL       disk_write
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD0EF             BEQ.N    ??f_mkdir_5
   1521                          return FR_RW_ERROR;   
   \   000000AC   0xE02E             B.N      ??f_mkdir_2
   1522                  }   
   1523                  memset(&fw[DIR_Name], ' ', 8+3);        /* Create "." entry */   
   \                     ??f_mkdir_6: (+1)
   \   000000AE   0x2220             MOVS     R2,#+32
   \   000000B0   0x210B             MOVS     R1,#+11
   \   000000B2   0x4630             MOV      R0,R6
   \   000000B4   0x.... 0x....      BL       __aeabi_memset
   1524                  fw[DIR_Name] = '.';   
   \   000000B8   0x202E             MOVS     R0,#+46
   \   000000BA   0x7030             STRB     R0,[R6, #+0]
   1525                  fw[DIR_Attr] = AM_DIR;   
   \   000000BC   0x0C2C             LSRS     R4,R5,#+16
   \   000000BE   0x2010             MOVS     R0,#+16
   \   000000C0   0x72F0             STRB     R0,[R6, #+11]
   1526                  tim = get_fattime();   
   \   000000C2   0x.... 0x....      BL       get_fattime
   \   000000C6   0x4607             MOV      R7,R0
   1527                  ST_DWORD(&fw[DIR_WrtTime], tim);   
   \   000000C8   0xF8C6 0x7016      STR      R7,[R6, #+22]
   1528                  memcpy(&fw[32], &fw[0], 32); fw[33] = '.';  /* Create ".." entry */   
   \   000000CC   0x2220             MOVS     R2,#+32
   \   000000CE   0x4631             MOV      R1,R6
   \   000000D0   0xF106 0x0020      ADD      R0,R6,#+32
   \   000000D4   0x.... 0x....      BL       __aeabi_memcpy
   \   000000D8   0x202E             MOVS     R0,#+46
   \   000000DA   0xF886 0x0021      STRB     R0,[R6, #+33]
   1529                  ST_WORD(&fw[   DIR_FstClusLO], dclust);   
   \   000000DE   0x8375             STRH     R5,[R6, #+26]
   \   000000E0   0x82B4             STRH     R4,[R6, #+20]
   1530                  ST_WORD(&fw[   DIR_FstClusHI], dclust >> 16);   
   1531                  pclust = dj.sclust;   
   1532                  if (dj.fs->fs_type == FS_FAT32 && pclust == dj.fs->dirbase) pclust = 0;   
   \   000000E2   0x9902             LDR      R1,[SP, #+8]
   \   000000E4   0x9803             LDR      R0,[SP, #+12]
   \   000000E6   0x3114             ADDS     R1,R1,#+20
   \   000000E8   0x7D8A             LDRB     R2,[R1, #+22]
   \   000000EA   0x2A03             CMP      R2,#+3
   \   000000EC   0xBF02             ITTT     EQ 
   \   000000EE   0x680A             LDREQ    R2,[R1, #+0]
   \   000000F0   0x4290             CMPEQ    R0,R2
   \   000000F2   0x2000             MOVEQ    R0,#+0
   1533                  ST_WORD(&fw[32+DIR_FstClusLO], pclust);   
   \   000000F4   0xF106 0x0234      ADD      R2,R6,#+52
   \   000000F8   0x80D0             STRH     R0,[R2, #+6]
   1534                  ST_WORD(&fw[32+DIR_FstClusHI], pclust >> 16);   
   \   000000FA   0x0C00             LSRS     R0,R0,#+16
   \   000000FC   0x8010             STRH     R0,[R2, #+0]
   1535                  dj.fs->winflag = 1;   
   \   000000FE   0x2001             MOVS     R0,#+1
   \   00000100   0x7688             STRB     R0,[R1, #+26]
   1536                 
   1537                  if (!move_window(dj.fs, sect)) return FR_RW_ERROR;   
   \   00000102   0x4641             MOV      R1,R8
   \   00000104   0x9802             LDR      R0,[SP, #+8]
   \   00000106   0x.... 0x....      BL       move_window
   \   0000010A   0xB908             CBNZ.N   R0,??f_mkdir_7
   \                     ??f_mkdir_2: (+1)
   \   0000010C   0x2008             MOVS     R0,#+8
   \   0000010E   0x....             B.N      ?Subroutine2
   1538                  memset(&dir[0], 0, 32);                     /* Initialize the new entry */   
   \                     ??f_mkdir_7: (+1)
   \   00000110   0x9800             LDR      R0,[SP, #+0]
   \   00000112   0x2120             MOVS     R1,#+32
   \   00000114   0x.... 0x....      BL       __aeabi_memclr
   1539                  memcpy(&dir[DIR_Name], fn, 8+3);            /* Name */   
   \   00000118   0x9800             LDR      R0,[SP, #+0]
   \   0000011A   0x220B             MOVS     R2,#+11
   \   0000011C   0xA906             ADD      R1,SP,#+24
   \   0000011E   0x.... 0x....      BL       __aeabi_memcpy
   1540                  dir[DIR_NTres] = fn[11];   
   \   00000122   0x9900             LDR      R1,[SP, #+0]
   \   00000124   0xF89D 0x0023      LDRB     R0,[SP, #+35]
   \   00000128   0x7308             STRB     R0,[R1, #+12]
   1541                  dir[DIR_Attr] = AM_DIR;                     /* Attribute */   
   \   0000012A   0x2010             MOVS     R0,#+16
   \   0000012C   0x9900             LDR      R1,[SP, #+0]
   \   0000012E   0x72C8             STRB     R0,[R1, #+11]
   1542                  ST_DWORD(&dir[DIR_WrtTime], tim);           /* Crated time */   
   \   00000130   0x9800             LDR      R0,[SP, #+0]
   \   00000132   0xF8C0 0x7016      STR      R7,[R0, #+22]
   1543                  ST_WORD(&dir[DIR_FstClusLO], dclust);       /* Table start cluster */   
   \   00000136   0x9800             LDR      R0,[SP, #+0]
   \   00000138   0x8345             STRH     R5,[R0, #+26]
   1544                  ST_WORD(&dir[DIR_FstClusHI], dclust >> 16);   
   \   0000013A   0x9800             LDR      R0,[SP, #+0]
   \   0000013C   0x8284             STRH     R4,[R0, #+20]
   1545                 
   1546                  return sync(dj.fs);   
   \   0000013E   0x9802             LDR      R0,[SP, #+8]
   \   00000140   0x.... 0x....      BL       sync
   \                     ??f_mkdir_0: (+1)
   \   00000144                      REQUIRE ?Subroutine2
   \   00000144                      ;; // Fall through to label ?Subroutine2
   1547              }   

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0xB00A             ADD      SP,SP,#+40
   \   00000002   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1548                 
   1549                 
   1550                 
   1551                 
   1552              /*-----------------------------------------------------------------------*/   
   1553              /* Change File Attribute                                                 */   
   1554              /*-----------------------------------------------------------------------*/   
   1555                 

   \                                 In section .text, align 2, keep-with-next
   1556              FRESULT f_chmod (   
   1557                  const char *path,   /* Pointer to the file path */   
   1558                  BYTE value,         /* Attribute bits */   
   1559                  BYTE mask           /* Attribute mask to change */   
   1560              )   
   1561              {   
   \                     f_chmod: (+1)
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0x4615             MOV      R5,R2
   1562                  FRESULT res;   
   1563                  DIR dj;   
   1564                  BYTE *dir;   
   1565                  char fn[8+3+1];   
   1566                 
   1567                 
   1568                  res = auto_mount(&path, &dj.fs, 1);   
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0xA905             ADD      R1,SP,#+20
   \   0000000C   0xA80A             ADD      R0,SP,#+40
   \   0000000E   0x.... 0x....      BL       auto_mount
   1569                  if (res == FR_OK) {   
   \   00000012   0xB9B0             CBNZ.N   R0,??f_chmod_0
   1570                      res = trace_path(&dj, fn, path, &dir);  /* Trace the file path */   
   \   00000014   0x9A0A             LDR      R2,[SP, #+40]
   \   00000016   0x466B             MOV      R3,SP
   \   00000018   0xA901             ADD      R1,SP,#+4
   \   0000001A   0xA804             ADD      R0,SP,#+16
   \   0000001C   0x.... 0x....      BL       trace_path
   1571                      if (res == FR_OK) {             /* Trace completed */   
   \   00000020   0xB978             CBNZ.N   R0,??f_chmod_0
   1572                          if (!dir) {   
   \   00000022   0x9800             LDR      R0,[SP, #+0]
   \   00000024   0xB900             CBNZ.N   R0,??f_chmod_1
   1573                              res = FR_INVALID_NAME;  /* Root directory */   
   \   00000026   0x....             B.N      ?Subroutine6
   1574                          } else {   
   1575                              mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;    /* Valid attribute mask */   
   1576                              dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask); /* Apply attribute change */   
   \                     ??f_chmod_1: (+1)
   \   00000028   0x9900             LDR      R1,[SP, #+0]
   \   0000002A   0x7AC9             LDRB     R1,[R1, #+11]
   \   0000002C   0xF005 0x0527      AND      R5,R5,#0x27
   \   00000030   0xEA05 0x0004      AND      R0,R5,R4
   \   00000034   0x43A9             BICS     R1,R1,R5
   \   00000036   0x4308             ORRS     R0,R1,R0
   \   00000038   0x9900             LDR      R1,[SP, #+0]
   \   0000003A   0x72C8             STRB     R0,[R1, #+11]
   1577                              res = sync(dj.fs);   
   \   0000003C   0x9805             LDR      R0,[SP, #+20]
   \   0000003E   0x.... 0x....      BL       sync
   1578                          }   
   1579                      }   
   1580                  }   
   1581                  return res;   
   \                     ??f_chmod_0: (+1)
   \   00000042   0xB00B             ADD      SP,SP,#+44
   \   00000044   0xBD30             POP      {R4,R5,PC}       ;; return
   1582              }   
   1583                 
   1584                 
   1585                 
   1586                 
   1587              /*-----------------------------------------------------------------------*/   
   1588              /* Change Timestamp                                                      */   
   1589              /*-----------------------------------------------------------------------*/   
   1590                 

   \                                 In section .text, align 2, keep-with-next
   1591              FRESULT f_utime (   
   1592                  const char *path,       /* Pointer to the file/directory name */   
   1593                  const FILINFO *finfo    /* Pointer to the timestamp to be set */   
   1594              )   
   1595              {   
   \                     f_utime: (+1)
   \   00000000   0xB511             PUSH     {R0,R4,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x460C             MOV      R4,R1
   1596                  FRESULT res;   
   1597                  DIR dj;   
   1598                  BYTE *dir;   
   1599                  char fn[8+3+1];   
   1600                 
   1601                 
   1602                  res = auto_mount(&path, &dj.fs, 1);   
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA905             ADD      R1,SP,#+20
   \   0000000A   0xA809             ADD      R0,SP,#+36
   \   0000000C   0x.... 0x....      BL       auto_mount
   1603                  if (res == FR_OK) {   
   \   00000010   0xB9A0             CBNZ.N   R0,??f_utime_0
   1604                      res = trace_path(&dj, fn, path, &dir);  /* Trace the file path */   
   \   00000012   0x9A09             LDR      R2,[SP, #+36]
   \   00000014   0x466B             MOV      R3,SP
   \   00000016   0xA901             ADD      R1,SP,#+4
   \   00000018   0xA804             ADD      R0,SP,#+16
   \   0000001A   0x.... 0x....      BL       trace_path
   1605                      if (res == FR_OK) {             /* Trace completed */   
   \   0000001E   0xB968             CBNZ.N   R0,??f_utime_0
   1606                          if (!dir) {   
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0xB910             CBNZ.N   R0,??f_utime_1
   1607                              res = FR_INVALID_NAME;  /* Root directory */   
   \   00000024   0x2004             MOVS     R0,#+4
   1608                          } else {   
   1609                              ST_WORD(&dir[DIR_WrtTime], finfo->ftime);   
   1610                              ST_WORD(&dir[DIR_WrtDate], finfo->fdate);   
   1611                              res = sync(dj.fs);   
   1612                          }   
   1613                      }   
   1614                  }   
   1615                  return res;   
   \   00000026   0xB00A             ADD      SP,SP,#+40
   \   00000028   0xBD10             POP      {R4,PC}
   \                     ??f_utime_1: (+1)
   \   0000002A   0x9900             LDR      R1,[SP, #+0]
   \   0000002C   0x88E0             LDRH     R0,[R4, #+6]
   \   0000002E   0x82C8             STRH     R0,[R1, #+22]
   \   00000030   0x9900             LDR      R1,[SP, #+0]
   \   00000032   0x88A0             LDRH     R0,[R4, #+4]
   \   00000034   0x8308             STRH     R0,[R1, #+24]
   \   00000036   0x9805             LDR      R0,[SP, #+20]
   \   00000038   0x.... 0x....      BL       sync
   \                     ??f_utime_0: (+1)
   \   0000003C   0xB00A             ADD      SP,SP,#+40
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
   1616              }   
   1617                 
   1618                 
   1619                 
   1620                 
   1621              /*-----------------------------------------------------------------------*/   
   1622              /* Rename File/Directory                                                 */   
   1623              /*-----------------------------------------------------------------------*/   
   1624                 

   \                                 In section .text, align 2, keep-with-next
   1625              FRESULT f_rename (   
   1626                  const char *path_old,   /* Pointer to the old name */   
   1627                  const char *path_new    /* Pointer to the new name */   
   1628              )   
   1629              {   
   \                     f_rename: (+1)
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB090             SUB      SP,SP,#+64
   \   00000004   0x460C             MOV      R4,R1
   1630                  FRESULT res;   
   1631                  DIR dj;   
   1632                  DWORD sect_old;   
   1633                  BYTE *dir_old, *dir_new, direntry[32-11];   
   1634                  char fn[8+3+1];   
   1635                 
   1636                 
   1637                  res = auto_mount(&path_old, &dj.fs, 1);   
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA906             ADD      R1,SP,#+24
   \   0000000A   0xA810             ADD      R0,SP,#+64
   \   0000000C   0x.... 0x....      BL       auto_mount
   1638                  if (res != FR_OK) return res;   
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD147             BNE.N    ??f_rename_0
   1639                 
   1640                  res = trace_path(&dj, fn, path_old, &dir_old);  /* Check old object */   
   \   00000014   0x9A10             LDR      R2,[SP, #+64]
   \   00000016   0xAB01             ADD      R3,SP,#+4
   \   00000018   0xA902             ADD      R1,SP,#+8
   \   0000001A   0xA805             ADD      R0,SP,#+20
   \   0000001C   0x.... 0x....      BL       trace_path
   1641                  if (res != FR_OK) return res;               /* The old object is not found */   
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD13F             BNE.N    ??f_rename_0
   1642                  if (!dir_old) return FR_NO_FILE;   
   \   00000024   0x9801             LDR      R0,[SP, #+4]
   \   00000026   0xB910             CBNZ.N   R0,??f_rename_1
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xB011             ADD      SP,SP,#+68
   \   0000002C   0xBD30             POP      {R4,R5,PC}
   1643                  sect_old = dj.fs->winsect;                   /* Save the object information */   
   \                     ??f_rename_1: (+1)
   \   0000002E   0x9806             LDR      R0,[SP, #+24]
   \   00000030   0x6845             LDR      R5,[R0, #+4]
   1644                  memcpy(direntry, &dir_old[DIR_Attr], 32-11);   
   \   00000032   0x9801             LDR      R0,[SP, #+4]
   \   00000034   0xF100 0x010B      ADD      R1,R0,#+11
   \   00000038   0x2215             MOVS     R2,#+21
   \   0000003A   0xA80A             ADD      R0,SP,#+40
   \   0000003C   0x.... 0x....      BL       __aeabi_memcpy
   1645                 
   1646                  res = trace_path(&dj, fn, path_new, &dir_new);  /* Check new object */   
   \   00000040   0x466B             MOV      R3,SP
   \   00000042   0x4622             MOV      R2,R4
   \   00000044   0xA902             ADD      R1,SP,#+8
   \   00000046   0xA805             ADD      R0,SP,#+20
   \   00000048   0x.... 0x....      BL       trace_path
   1647                  if (res == FR_OK) return FR_EXIST;          /* The new object name is already existing */   
   \   0000004C   0xB910             CBNZ.N   R0,??f_rename_2
   \   0000004E   0x2007             MOVS     R0,#+7
   \   00000050   0xB011             ADD      SP,SP,#+68
   \   00000052   0xBD30             POP      {R4,R5,PC}
   1648                  if (res != FR_NO_FILE) return res;          /* Is there no old name? */   
   \                     ??f_rename_2: (+1)
   \   00000054   0x2802             CMP      R0,#+2
   \   00000056   0xD125             BNE.N    ??f_rename_0
   1649                  res = reserve_direntry(&dj, &dir_new);      /* Reserve a directory entry */   
   \   00000058   0x4669             MOV      R1,SP
   \   0000005A   0xA805             ADD      R0,SP,#+20
   \   0000005C   0x.... 0x....      BL       reserve_direntry
   1650                  if (res != FR_OK) return res;   
   \   00000060   0xBB00             CBNZ.N   R0,??f_rename_0
   1651                 
   1652                  memcpy(&dir_new[DIR_Attr], direntry, 32-11);    /* Create new entry */   
   \   00000062   0x9800             LDR      R0,[SP, #+0]
   \   00000064   0x2215             MOVS     R2,#+21
   \   00000066   0xA90A             ADD      R1,SP,#+40
   \   00000068   0x300B             ADDS     R0,R0,#+11
   \   0000006A   0x.... 0x....      BL       __aeabi_memcpy
   1653                  memcpy(&dir_new[DIR_Name], fn, 8+3);   
   \   0000006E   0x9800             LDR      R0,[SP, #+0]
   \   00000070   0x220B             MOVS     R2,#+11
   \   00000072   0xA902             ADD      R1,SP,#+8
   \   00000074   0x.... 0x....      BL       __aeabi_memcpy
   1654                  dir_new[DIR_NTres] = fn[11];   
   \   00000078   0x9900             LDR      R1,[SP, #+0]
   \   0000007A   0xF89D 0x0013      LDRB     R0,[SP, #+19]
   \   0000007E   0x7308             STRB     R0,[R1, #+12]
   1655                  dj.fs->winflag = 1;   
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0x9906             LDR      R1,[SP, #+24]
   \   00000084   0xF881 0x002E      STRB     R0,[R1, #+46]
   1656                 
   1657                  if (!move_window(dj.fs, sect_old)) return FR_RW_ERROR;  /* Delete old entry */   
   \   00000088   0x4629             MOV      R1,R5
   \   0000008A   0x9806             LDR      R0,[SP, #+24]
   \   0000008C   0x.... 0x....      BL       move_window
   \   00000090   0xB910             CBNZ.N   R0,??f_rename_3
   \   00000092   0x2008             MOVS     R0,#+8
   \   00000094   0xB011             ADD      SP,SP,#+68
   \   00000096   0xBD30             POP      {R4,R5,PC}
   1658                  dir_old[DIR_Name] = 0xE5;   
   \                     ??f_rename_3: (+1)
   \   00000098   0x9901             LDR      R1,[SP, #+4]
   \   0000009A   0x20E5             MOVS     R0,#+229
   \   0000009C   0x7008             STRB     R0,[R1, #+0]
   1659                 
   1660                  return sync(dj.fs);   
   \   0000009E   0x9806             LDR      R0,[SP, #+24]
   \   000000A0   0x.... 0x....      BL       sync
   \                     ??f_rename_0: (+1)
   \   000000A4   0xB011             ADD      SP,SP,#+68
   \   000000A6   0xBD30             POP      {R4,R5,PC}       ;; return
   1661              }   
   1662                 
   1663              #endif /* !_FS_READONLY */   
   1664              #endif /* _FS_MINIMIZE == 0 */   
   1665              #endif /* _FS_MINIMIZE <= 1 */   
   1666              #endif /* _FS_MINIMIZE <= 2 */   
   1667                 
   1668                 
   1669                 
   1670              #if _USE_MKFS && !_FS_READONLY   
   1671              /*-----------------------------------------------------------------------*/   
   1672              /* Create File System on the Drive                                       */   
   1673              /*-----------------------------------------------------------------------*/   
   1674              #define N_ROOTDIR   512         /* Multiple of 32 and <= 2048 */   
   1675              #define N_FATS      1           /* 1 or 2 */   
   1676              #define MAX_SECTOR  64000000UL  /* Maximum partition size */   
   1677              #define MIN_SECTOR  2000UL      /* Minimum partition size */   
   1678                 
   1679                 
   1680                 

   \                                 In section .text, align 4, keep-with-next
   1681              FRESULT f_mkfs (   
   1682                  BYTE drv,           /* Logical drive number */   
   1683                  BYTE partition,     /* Partitioning rule 0:FDISK, 1:SFD */   
   1684                  WORD allocsize      /* Allocation unit size [bytes] */   
   1685              )   
   1686              {   
   \                     f_mkfs: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x4615             MOV      R5,R2
   1687                  BYTE fmt, m, *tbl;   
   1688                  DWORD b_part, b_fat, b_dir, b_data;     /* Area offset (LBA) */   
   1689                  DWORD n_part, n_rsv, n_fat, n_dir;      /* Area size */   
   1690                  DWORD n_clust, n;   
   1691                  FATFS *fs;   
   1692                  DSTATUS stat;   
   1693                 
   1694                 
   1695                  /* Check validity of the parameters */   
   1696                  if (drv >= _DRIVES) return FR_INVALID_DRIVE;   
   \   0000000A   0xB108             CBZ.N    R0,??f_mkfs_0
   \   0000000C   0x2005             MOVS     R0,#+5
   \   0000000E   0x....             B.N      ?Subroutine5
   1697                  if (partition >= 2) return FR_MKFS_ABORTED;   
   \                     ??f_mkfs_0: (+1)
   \   00000010   0x2C02             CMP      R4,#+2
   \   00000012   0xF280 0x8081      BGE.W    ??f_mkfs_1
   \   00000016   0xF44F 0x7000      MOV      R0,#+512
   \   0000001A   0x9000             STR      R0,[SP, #+0]
   \   0000001C   0xF248 0x0001      MOVW     R0,#+32769
   \                     ??f_mkfs_2: (+1)
   \   00000020   0x9900             LDR      R1,[SP, #+0]
   \   00000022   0x42A9             CMP      R1,R5
   \   00000024   0xD003             BEQ.N    ??f_mkfs_3
   1698                  for (n = 512; n <= 32768U && n != allocsize; n <<= 1);   
   \   00000026   0x0049             LSLS     R1,R1,#+1
   \   00000028   0x4281             CMP      R1,R0
   \   0000002A   0x9100             STR      R1,[SP, #+0]
   \   0000002C   0xD3F8             BCC.N    ??f_mkfs_2
   1699                  if (n != allocsize) return FR_MKFS_ABORTED;   
   \                     ??f_mkfs_3: (+1)
   \   0000002E   0x9800             LDR      R0,[SP, #+0]
   \   00000030   0x42A8             CMP      R0,R5
   \   00000032   0xD171             BNE.N    ??f_mkfs_1
   1700                 
   1701                  /* Check mounted drive and clear work area */   
   1702                  fs = FatFs[drv];   
   \   00000034   0x489D             LDR.N    R0,??f_mkfs_4
   \   00000036   0x6840             LDR      R0,[R0, #+4]
   \   00000038   0x9003             STR      R0,[SP, #+12]
   1703                  if (!fs) return FR_NOT_ENABLED;   
   \   0000003A   0xB908             CBNZ.N   R0,??f_mkfs_5
   \   0000003C   0x200A             MOVS     R0,#+10
   \   0000003E   0x....             B.N      ?Subroutine5
   1704                  fs->fs_type = 0;   
   \                     ??f_mkfs_5: (+1)
   \   00000040   0x9903             LDR      R1,[SP, #+12]
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xF881 0x002A      STRB     R0,[R1, #+42]
   1705                  drv = LD2PD(drv);   
   1706                 
   1707                  /* Get disk statics */   
   1708                  stat = disk_initialize(drv);   
   \   00000048   0x.... 0x....      BL       disk_initialize
   1709                  if (stat & STA_NOINIT) return FR_NOT_READY;   
   \   0000004C   0x07C1             LSLS     R1,R0,#+31
   \   0000004E   0xBF48             IT       MI 
   \   00000050   0x2001             MOVMI    R0,#+1
   \   00000052   0xF100 0x81A0      BMI.W    ??f_mkfs_6
   1710                  if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;   
   \   00000056   0x0740             LSLS     R0,R0,#+29
   \   00000058   0xBF48             IT       MI 
   \   0000005A   0x2009             MOVMI    R0,#+9
   \   0000005C   0xF100 0x819B      BMI.W    ??f_mkfs_6
   1711                  if (disk_ioctl(drv, GET_SECTOR_COUNT, &n_part) != RES_OK || n_part < MIN_SECTOR)   
   \   00000060   0xAA01             ADD      R2,SP,#+4
   \   00000062   0x2101             MOVS     R1,#+1
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x.... 0x....      BL       disk_ioctl
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD154             BNE.N    ??f_mkfs_1
   \   0000006E   0x9801             LDR      R0,[SP, #+4]
   \   00000070   0xF5B0 0x6FFA      CMP      R0,#+2000
   \   00000074   0xD350             BCC.N    ??f_mkfs_1
   1712                      return FR_MKFS_ABORTED;   
   1713                  if (n_part > MAX_SECTOR) n_part = MAX_SECTOR;   
   \   00000076   0x498E             LDR.N    R1,??f_mkfs_4+0x4  ;; 0x3d09001
   \   00000078   0x4288             CMP      R0,R1
   \   0000007A   0xBF24             ITT      CS 
   \   0000007C   0x488D             LDRCS.N  R0,??f_mkfs_4+0x8  ;; 0x3d09000
   \   0000007E   0x9001             STRCS    R0,[SP, #+4]
   1714                  b_part = (!partition) ? 63 : 0;     /* Boot sector */   
   \   00000080   0x2C00             CMP      R4,#+0
   \   00000082   0xBF0C             ITE      EQ 
   \   00000084   0x263F             MOVEQ    R6,#+63
   \   00000086   0x2600             MOVNE    R6,#+0
   1715                  n_part -= b_part;   
   \   00000088   0x9801             LDR      R0,[SP, #+4]
   \   0000008A   0x1B80             SUBS     R0,R0,R6
   \   0000008C   0x9001             STR      R0,[SP, #+4]
   1716              #if S_MAX_SIZ > 512                      /* Check disk sector size */   
   1717                  if (disk_ioctl(drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK   
   1718                      || SS(fs) > S_MAX_SIZ   
   1719                      || SS(fs) > allocsize)   
   1720                      return FR_MKFS_ABORTED;   
   1721              #endif   
   1722                  allocsize /= SS(fs);        /* Number of sectors per cluster */   
   \   0000008E   0xEA4F 0x2A55      LSR      R10,R5,#+9
   \   00000092   0xFBB0 0xF9FA      UDIV     R9,R0,R10
   1723                 
   1724                  /* Pre-compute number of clusters and FAT type */   
   1725                  n_clust = n_part / allocsize;   
   1726                  fmt = FS_FAT12;   
   \   00000096   0x2701             MOVS     R7,#+1
   \   00000098   0xF640 0x70F5      MOVW     R0,#+4085
   \   0000009C   0x4581             CMP      R9,R0
   \   0000009E   0xBF28             IT       CS 
   \   000000A0   0x2702             MOVCS    R7,#+2
   1727                  if (n_clust >= 0xFF5) fmt = FS_FAT16;   
   \   000000A2   0xF64F 0x70F5      MOVW     R0,#+65525
   \   000000A6   0x4581             CMP      R9,R0
   \   000000A8   0xD338             BCC.N    ??f_mkfs_7
   1728                  if (n_clust >= 0xFFF5) fmt = FS_FAT32;   
   \   000000AA   0x2703             MOVS     R7,#+3
   1729                 
   1730                  /* Determine offset and size of FAT structure */   
   1731                  switch (fmt) {   
   1732                  case FS_FAT12:   
   1733                      n_fat = ((n_clust * 3 + 1) / 2 + 3 + SS(fs) - 1) / SS(fs);   
   1734                      n_rsv = 1 + partition;   
   1735                      n_dir = N_ROOTDIR * 32 / SS(fs);   
   1736                      break;   
   1737                  case FS_FAT16:   
   1738                      n_fat = ((n_clust * 2) + 4 + SS(fs) - 1) / SS(fs);   
   1739                      n_rsv = 1 + partition;   
   1740                      n_dir = N_ROOTDIR * 32 / SS(fs);   
   1741                      break;   
   1742                  default:   
   1743                      n_fat = ((n_clust * 4) + 8 + SS(fs) - 1) / SS(fs);   
   \                     ??f_mkfs_8: (+1)
   \   000000AC   0xEA4F 0x0089      LSL      R0,R9,#+2
   \   000000B0   0xF200 0x2007      ADDW     R0,R0,#+519
   \   000000B4   0x0A45             LSRS     R5,R0,#+9
   1744                      n_rsv = 33 - partition;   
   \   000000B6   0xF1C4 0x0021      RSB      R0,R4,#+33
   \   000000BA   0x9002             STR      R0,[SP, #+8]
   1745                      n_dir = 0;   
   \   000000BC   0xF04F 0x0B00      MOV      R11,#+0
   1746                  }   
   1747                  b_fat = b_part + n_rsv;         /* FATs start sector */   
   \                     ??f_mkfs_9: (+1)
   \   000000C0   0x9802             LDR      R0,[SP, #+8]
   \   000000C2   0xEB00 0x0806      ADD      R8,R0,R6
   1748                  b_dir = b_fat + n_fat * N_FATS; /* Directory start sector */   
   1749                  b_data = b_dir + n_dir;         /* Data start sector */   
   \   000000C6   0xEB05 0x0008      ADD      R0,R5,R8
   \   000000CA   0xEB0B 0x0900      ADD      R9,R11,R0
   1750                 
   1751                  /* Align data start sector to erase block boundary (for flash memory media) */   
   1752                  if (disk_ioctl(drv, GET_BLOCK_SIZE, &n) != RES_OK) return FR_MKFS_ABORTED;   
   \   000000CE   0x466A             MOV      R2,SP
   \   000000D0   0x2103             MOVS     R1,#+3
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0x.... 0x....      BL       disk_ioctl
   \   000000D8   0xB9F0             CBNZ.N   R0,??f_mkfs_1
   1753                  n = (b_data + n - 1) & ~(n - 1);   
   \   000000DA   0x9800             LDR      R0,[SP, #+0]
   \   000000DC   0x9900             LDR      R1,[SP, #+0]
   \   000000DE   0x4448             ADD      R0,R0,R9
   \   000000E0   0x1E40             SUBS     R0,R0,#+1
   \   000000E2   0x1E49             SUBS     R1,R1,#+1
   \   000000E4   0x4388             BICS     R0,R0,R1
   \   000000E6   0x9000             STR      R0,[SP, #+0]
   1754                  n_fat += (n - b_data) / N_FATS;   
   \   000000E8   0x9800             LDR      R0,[SP, #+0]
   1755                  /* b_dir and b_data are no longer used below */   
   1756                 
   1757                  /* Determine number of cluster and final check of validity of the FAT type */   
   1758                  n_clust = (n_part - n_rsv - n_fat * N_FATS - n_dir) / allocsize;   
   \   000000EA   0x9902             LDR      R1,[SP, #+8]
   \   000000EC   0x1940             ADDS     R0,R0,R5
   \   000000EE   0xEBA0 0x0509      SUB      R5,R0,R9
   \   000000F2   0x9801             LDR      R0,[SP, #+4]
   \   000000F4   0x1A40             SUBS     R0,R0,R1
   \   000000F6   0x1B40             SUBS     R0,R0,R5
   \   000000F8   0xEBA0 0x000B      SUB      R0,R0,R11
   1759                  if (   (fmt == FS_FAT16 && n_clust < 0xFF5)   
   1760                      || (fmt == FS_FAT32 && n_clust < 0xFFF5))   
   \   000000FC   0x2F02             CMP      R7,#+2
   \   000000FE   0xFBB0 0xF9FA      UDIV     R9,R0,R10
   \   00000102   0xD103             BNE.N    ??f_mkfs_10
   \   00000104   0xF640 0x70F5      MOVW     R0,#+4085
   \   00000108   0x4581             CMP      R9,R0
   \   0000010A   0xD305             BCC.N    ??f_mkfs_1
   \                     ??f_mkfs_10: (+1)
   \   0000010C   0x2F03             CMP      R7,#+3
   \   0000010E   0xD11B             BNE.N    ??f_mkfs_11
   \   00000110   0xF64F 0x70F5      MOVW     R0,#+65525
   \   00000114   0x4581             CMP      R9,R0
   \   00000116   0xD217             BCS.N    ??f_mkfs_11
   1761                      return FR_MKFS_ABORTED;   
   \                     ??f_mkfs_1: (+1)
   \   00000118   0x200D             MOVS     R0,#+13
   \   0000011A   0x....             B.N      ?Subroutine5
   \                     ??f_mkfs_7: (+1)
   \   0000011C   0x2F01             CMP      R7,#+1
   \   0000011E   0xD002             BEQ.N    ??f_mkfs_12
   \   00000120   0x2F02             CMP      R7,#+2
   \   00000122   0xD00C             BEQ.N    ??f_mkfs_13
   \   00000124   0xE7C2             B.N      ??f_mkfs_8
   \                     ??f_mkfs_12: (+1)
   \   00000126   0xEB09 0x0049      ADD      R0,R9,R9, LSL #+1
   \   0000012A   0x1C40             ADDS     R0,R0,#+1
   \   0000012C   0x0840             LSRS     R0,R0,#+1
   \   0000012E   0xF200 0x2002      ADDW     R0,R0,#+514
   \                     ??f_mkfs_14: (+1)
   \   00000132   0x0A45             LSRS     R5,R0,#+9
   \   00000134   0x1C60             ADDS     R0,R4,#+1
   \   00000136   0x9002             STR      R0,[SP, #+8]
   \   00000138   0xF04F 0x0B20      MOV      R11,#+32
   \   0000013C   0xE7C0             B.N      ??f_mkfs_9
   \                     ??f_mkfs_13: (+1)
   \   0000013E   0xEA4F 0x0049      LSL      R0,R9,#+1
   \   00000142   0xF200 0x2003      ADDW     R0,R0,#+515
   \   00000146   0xE7F4             B.N      ??f_mkfs_14
   1762                 
   1763                  /* Create partition table if needed */   
   1764                  if (!partition) {   
   \                     ??f_mkfs_11: (+1)
   \   00000148   0x2C00             CMP      R4,#+0
   \   0000014A   0xD138             BNE.N    ??f_mkfs_15
   1765                      DWORD n_disk = b_part + n_part;   
   1766                 
   1767                      tbl = &fs->win[MBR_Table];   
   \   0000014C   0x9903             LDR      R1,[SP, #+12]
   \   0000014E   0x9801             LDR      R0,[SP, #+4]
   \   00000150   0xF501 0x74F7      ADD      R4,R1,#+494
   1768                      ST_DWORD(&tbl[0], 0x00010180);  /* Partition start in CHS */   
   \   00000154   0x4958             LDR.N    R1,??f_mkfs_4+0xC  ;; 0x10180
   \   00000156   0x6021             STR      R1,[R4, #+0]
   \   00000158   0x1980             ADDS     R0,R0,R6
   1769                      if (n_disk < 63UL * 255 * 1024) {    /* Partition end in CHS */   
   \   0000015A   0x4958             LDR.N    R1,??f_mkfs_4+0x10  ;; 0xfb0400
   \   0000015C   0x4288             CMP      R0,R1
   \   0000015E   0xD20B             BCS.N    ??f_mkfs_16
   1770                          n_disk = n_disk / 63 / 255;   
   \   00000160   0x213F             MOVS     R1,#+63
   \   00000162   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000166   0x21FF             MOVS     R1,#+255
   \   00000168   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   1771                          tbl[7] = (BYTE)n_disk;   
   \   0000016C   0x71E0             STRB     R0,[R4, #+7]
   1772                          tbl[6] = (BYTE)((n_disk >> 2) | 63);   
   \   0000016E   0x0880             LSRS     R0,R0,#+2
   \   00000170   0xF040 0x003F      ORR      R0,R0,#0x3F
   \   00000174   0x71A0             STRB     R0,[R4, #+6]
   \   00000176   0xE002             B.N      ??f_mkfs_17
   1773                      } else {   
   1774                          ST_WORD(&tbl[6], 0xFFFF);   
   \                     ??f_mkfs_16: (+1)
   \   00000178   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000017C   0x80E0             STRH     R0,[R4, #+6]
   1775                      }   
   1776                      tbl[5] = 254;   
   \                     ??f_mkfs_17: (+1)
   \   0000017E   0x20FE             MOVS     R0,#+254
   1777                      if (fmt != FS_FAT32)            /* System ID */   
   \   00000180   0x2F03             CMP      R7,#+3
   \   00000182   0x7160             STRB     R0,[R4, #+5]
   \   00000184   0xD006             BEQ.N    ??f_mkfs_18
   1778                          tbl[4] = (n_part < 0x10000) ? 0x04 : 0x06;   
   \   00000186   0x9801             LDR      R0,[SP, #+4]
   \   00000188   0xF5B0 0x3F80      CMP      R0,#+65536
   \   0000018C   0xBF2C             ITE      CS 
   \   0000018E   0x2006             MOVCS    R0,#+6
   \   00000190   0x2004             MOVCC    R0,#+4
   \   00000192   0xE000             B.N      ??f_mkfs_19
   1779                      else   
   1780                          tbl[4] = 0x0c;   
   \                     ??f_mkfs_18: (+1)
   \   00000194   0x200C             MOVS     R0,#+12
   \                     ??f_mkfs_19: (+1)
   \   00000196   0x7120             STRB     R0,[R4, #+4]
   1781                      ST_DWORD(&tbl[8], 63);          /* Partition start in LBA */   
   1782                      ST_DWORD(&tbl[12], n_part);     /* Partition size in LBA */   
   1783                      ST_WORD(&tbl[64], 0xAA55);      /* Signature */   
   1784                      if (disk_write(drv, fs->win, 0, 1) != RES_OK)   
   \   00000198   0x2301             MOVS     R3,#+1
   \   0000019A   0x203F             MOVS     R0,#+63
   \   0000019C   0x60A0             STR      R0,[R4, #+8]
   \   0000019E   0x2200             MOVS     R2,#+0
   \   000001A0   0x9801             LDR      R0,[SP, #+4]
   \   000001A2   0x60E0             STR      R0,[R4, #+12]
   \   000001A4   0xF64A 0x2055      MOVW     R0,#+43605
   \   000001A8   0xF8A4 0x0040      STRH     R0,[R4, #+64]
   \   000001AC   0x9803             LDR      R0,[SP, #+12]
   \   000001AE   0xF100 0x0130      ADD      R1,R0,#+48
   \   000001B2   0x2000             MOVS     R0,#+0
   \   000001B4   0x.... 0x....      BL       disk_write
   \   000001B8   0x2800             CMP      R0,#+0
   \   000001BA   0xF040 0x80EB      BNE.W    ??f_mkfs_20
   1785                          return FR_RW_ERROR;   
   1786                  }   
   1787                 
   1788                  /* Create boot record */   
   1789                  tbl = fs->win;                               /* Clear buffer */   
   \                     ??f_mkfs_15: (+1)
   \   000001BE   0x9803             LDR      R0,[SP, #+12]
   \   000001C0   0xF100 0x0430      ADD      R4,R0,#+48
   1790                  memset(tbl, 0, SS(fs));   
   \   000001C4   0xF44F 0x7100      MOV      R1,#+512
   \   000001C8   0x4620             MOV      R0,R4
   \   000001CA   0x.... 0x....      BL       __aeabi_memclr
   1791                  ST_DWORD(&tbl[BS_jmpBoot], 0x90FEEB);       /* Boot code (jmp $, nop) */   
   \   000001CE   0x483C             LDR.N    R0,??f_mkfs_4+0x14  ;; 0x90feeb
   \   000001D0   0x6020             STR      R0,[R4, #+0]
   1792                  ST_WORD(&tbl[BPB_BytsPerSec], SS(fs));      /* Sector size */   
   1793                  tbl[BPB_SecPerClus] = (BYTE)allocsize;      /* Sectors per cluster */   
   \   000001D2   0xF884 0xA00D      STRB     R10,[R4, #+13]
   \   000001D6   0xF44F 0x7000      MOV      R0,#+512
   \   000001DA   0xF8A4 0x000B      STRH     R0,[R4, #+11]
   1794                  ST_WORD(&tbl[BPB_RsvdSecCnt], n_rsv);       /* Reserved sectors */   
   \   000001DE   0x9802             LDR      R0,[SP, #+8]
   \   000001E0   0x81E0             STRH     R0,[R4, #+14]
   1795                  tbl[BPB_NumFATs] = N_FATS;                  /* Number of FATs */   
   \   000001E2   0x2001             MOVS     R0,#+1
   \   000001E4   0x7420             STRB     R0,[R4, #+16]
   1796                  ST_WORD(&tbl[BPB_RootEntCnt], SS(fs) / 32 * n_dir); /* Number of rootdir entries */   
   \   000001E6   0xEA4F 0x100B      LSL      R0,R11,#+4
   \   000001EA   0xF8A4 0x0011      STRH     R0,[R4, #+17]
   1797                  if (n_part < 0x10000) {                      /* Number of total sectors */   
   \   000001EE   0x9801             LDR      R0,[SP, #+4]
   \   000001F0   0xF5B0 0x3F80      CMP      R0,#+65536
   \   000001F4   0xBF34             ITE      CC 
   \   000001F6   0xF8A4 0x0013      STRHCC   R0,[R4, #+19]
   \   000001FA   0x6220             STRCS    R0,[R4, #+32]
   1798                      ST_WORD(&tbl[BPB_TotSec16], n_part);   
   1799                  } else {   
   1800                      ST_DWORD(&tbl[BPB_TotSec32], n_part);   
   1801                  }   
   1802                  tbl[BPB_Media] = 0xF8;                      /* Media descripter */   
   \   000001FC   0x20F8             MOVS     R0,#+248
   \   000001FE   0x7560             STRB     R0,[R4, #+21]
   1803                  ST_WORD(&tbl[BPB_SecPerTrk], 63);           /* Number of sectors per track */   
   \   00000200   0x203F             MOVS     R0,#+63
   \   00000202   0x8320             STRH     R0,[R4, #+24]
   1804                  ST_WORD(&tbl[BPB_NumHeads], 255);           /* Number of heads */   
   \   00000204   0x20FF             MOVS     R0,#+255
   \   00000206   0x8360             STRH     R0,[R4, #+26]
   1805                  ST_DWORD(&tbl[BPB_HiddSec], b_part);        /* Hidden sectors */   
   \   00000208   0x61E6             STR      R6,[R4, #+28]
   1806                  n = get_fattime();                          /* Use current time as a VSN */   
   \   0000020A   0x.... 0x....      BL       get_fattime
   \   0000020E   0x9000             STR      R0,[SP, #+0]
   1807                  if (fmt != FS_FAT32) {   
   \   00000210   0x2F03             CMP      R7,#+3
   \   00000212   0x9900             LDR      R1,[SP, #+0]
   \   00000214   0xF104 0x0024      ADD      R0,R4,#+36
   \   00000218   0xD00C             BEQ.N    ??f_mkfs_21
   1808                      ST_DWORD(&tbl[BS_VolID], n);            /* Volume serial number */   
   \   0000021A   0xF8C4 0x1027      STR      R1,[R4, #+39]
   1809                      ST_WORD(&tbl[BPB_FATSz16], n_fat);      /* Number of secters per FAT */   
   \   0000021E   0x82E5             STRH     R5,[R4, #+22]
   1810                      tbl[BS_DrvNum] = 0x80;                  /* Drive number */   
   \   00000220   0x2180             MOVS     R1,#+128
   \   00000222   0x7001             STRB     R1,[R0, #+0]
   1811                      tbl[BS_BootSig] = 0x29;                 /* Extended boot signature */   
   1812                      memcpy(&tbl[BS_VolLab], "NO NAME    FAT     ", 19); /* Volume lavel, FAT signature */   
   \   00000224   0x2213             MOVS     R2,#+19
   \   00000226   0x2129             MOVS     R1,#+41
   \   00000228   0x7081             STRB     R1,[R0, #+2]
   \   0000022A   0xF104 0x002B      ADD      R0,R4,#+43
   \   0000022E   0x.... 0x....      ADR.W    R1,?_2
   \   00000232   0xE013             B.N      ??f_mkfs_22
   1813                  } else {   
   1814                      ST_DWORD(&tbl[BS_VolID32], n);          /* Volume serial number */   
   \                     ??f_mkfs_21: (+1)
   \   00000234   0xF8C4 0x1043      STR      R1,[R4, #+67]
   1815                      ST_DWORD(&tbl[BPB_FATSz32], n_fat);     /* Number of secters per FAT */   
   \   00000238   0x6005             STR      R5,[R0, #+0]
   1816                      ST_DWORD(&tbl[BPB_RootClus], 2);        /* Root directory cluster (2) */   
   \   0000023A   0xF104 0x002C      ADD      R0,R4,#+44
   \   0000023E   0x2102             MOVS     R1,#+2
   \   00000240   0x6001             STR      R1,[R0, #+0]
   1817                      ST_WORD(&tbl[BPB_FSInfo], 1);           /* FSInfo record (bs+1) */   
   1818                      ST_WORD(&tbl[BPB_BkBootSec], 6);        /* Backup boot record (bs+6) */   
   1819                      tbl[BS_DrvNum32] = 0x80;                /* Drive number */   
   1820                      tbl[BS_BootSig32] = 0x29;               /* Extended boot signature */   
   1821                      memcpy(&tbl[BS_VolLab32], "NO NAME    FAT32   ", 19);   /* Volume lavel, FAT signature */   
   \   00000242   0x2213             MOVS     R2,#+19
   \   00000244   0x2101             MOVS     R1,#+1
   \   00000246   0x8081             STRH     R1,[R0, #+4]
   \   00000248   0x2106             MOVS     R1,#+6
   \   0000024A   0x80C1             STRH     R1,[R0, #+6]
   \   0000024C   0x2180             MOVS     R1,#+128
   \   0000024E   0x7501             STRB     R1,[R0, #+20]
   \   00000250   0x2129             MOVS     R1,#+41
   \   00000252   0x7581             STRB     R1,[R0, #+22]
   \   00000254   0xF104 0x0047      ADD      R0,R4,#+71
   \   00000258   0x.... 0x....      ADR.W    R1,?_3
   \                     ??f_mkfs_22: (+1)
   \   0000025C   0x.... 0x....      BL       __aeabi_memcpy
   1822                  }   
   \   00000260   0xF504 0x71F2      ADD      R1,R4,#+484
   \   00000264   0xF64A 0x2055      MOVW     R0,#+43605
   \   00000268   0x8348             STRH     R0,[R1, #+26]
   1823                  ST_WORD(&tbl[BS_55AA], 0xAA55);         /* Signature */   
   1824                  if (disk_write(drv, tbl, b_part+0, 1) != RES_OK)   
   \   0000026A   0x2301             MOVS     R3,#+1
   \   0000026C   0x4632             MOV      R2,R6
   \   0000026E   0x4621             MOV      R1,R4
   \   00000270   0x2000             MOVS     R0,#+0
   \   00000272   0x.... 0x....      BL       disk_write
   \   00000276   0x2800             CMP      R0,#+0
   \   00000278   0xF040 0x808C      BNE.W    ??f_mkfs_20
   1825                      return FR_RW_ERROR;   
   1826                  if (fmt == FS_FAT32)   
   \   0000027C   0x2F03             CMP      R7,#+3
   \   0000027E   0xD104             BNE.N    ??f_mkfs_23
   1827                      disk_write(drv, tbl, b_part+6, 1);   
   \   00000280   0x2301             MOVS     R3,#+1
   \   00000282   0x1DB2             ADDS     R2,R6,#+6
   \   00000284   0x4621             MOV      R1,R4
   \   00000286   0x.... 0x....      BL       disk_write
   1828                 
   1829                  /* Initialize FAT area */   
   1830                  for (m = 0; m < N_FATS; m++) {   
   1831                      memset(tbl, 0, SS(fs));     /* 1st sector of the FAT  */   
   \                     ??f_mkfs_23: (+1)
   \   0000028A   0xF44F 0x7100      MOV      R1,#+512
   \   0000028E   0x4620             MOV      R0,R4
   \   00000290   0x.... 0x....      BL       __aeabi_memclr
   1832                      if (fmt != FS_FAT32) {   
   \   00000294   0x2F03             CMP      R7,#+3
   \   00000296   0xD017             BEQ.N    ??f_mkfs_24
   1833                          n = (fmt == FS_FAT12) ? 0x00FFFFF8 : 0xFFFFFFF8;   
   \   00000298   0x2F01             CMP      R7,#+1
   \   0000029A   0xBF0C             ITE      EQ 
   \   0000029C   0x4809             LDREQ.N  R0,??f_mkfs_4+0x18  ;; 0xfffff8
   \   0000029E   0xF06F 0x0007      MVNNE    R0,#+7
   \   000002A2   0x9000             STR      R0,[SP, #+0]
   1834                          ST_DWORD(&tbl[0], n);           /* Reserve cluster #0-1 (FAT12/16) */   
   \   000002A4   0x9800             LDR      R0,[SP, #+0]
   \   000002A6   0x6020             STR      R0,[R4, #+0]
   \   000002A8   0xE017             B.N      ??f_mkfs_25
   \   000002AA   0xBF00             Nop      
   \                     ??f_mkfs_4:
   \   000002AC   0x........         DC32     fsid
   \   000002B0   0x03D09001         DC32     0x3d09001
   \   000002B4   0x03D09000         DC32     0x3d09000
   \   000002B8   0x00010180         DC32     0x10180
   \   000002BC   0x00FB0400         DC32     0xfb0400
   \   000002C0   0x0090FEEB         DC32     0x90feeb
   \   000002C4   0x00FFFFF8         DC32     0xfffff8
   1835                      } else {   
   1836                          ST_DWORD(&tbl[0], 0xFFFFFFF8);  /* Reserve cluster #0-1 (FAT32) */   
   \                     ??f_mkfs_24: (+1)
   \   000002C8   0xF06F 0x0007      MVN      R0,#+7
   \   000002CC   0x6020             STR      R0,[R4, #+0]
   1837                          ST_DWORD(&tbl[4], 0xFFFFFFFF);   
   \   000002CE   0xF04F 0x30FF      MOV      R0,#-1
   \   000002D2   0x6060             STR      R0,[R4, #+4]
   1838                          ST_DWORD(&tbl[8], 0x0FFFFFFF);  /* Reserve cluster #2 for root dir */   
   \   000002D4   0xF06F 0x4070      MVN      R0,#-268435456
   \   000002D8   0x60A0             STR      R0,[R4, #+8]
   1839                      }   
   1840                      if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)   
   \                     ??f_mkfs_25: (+1)
   \   000002DA   0x2301             MOVS     R3,#+1
   \   000002DC   0x4642             MOV      R2,R8
   \   000002DE   0x4621             MOV      R1,R4
   \   000002E0   0x2000             MOVS     R0,#+0
   \   000002E2   0x.... 0x....      BL       disk_write
   \   000002E6   0x2800             CMP      R0,#+0
   \   000002E8   0xF108 0x0801      ADD      R8,R8,#+1
   \   000002EC   0xD152             BNE.N    ??f_mkfs_20
   1841                          return FR_RW_ERROR;   
   1842                      memset(tbl, 0, SS(fs));     /* Following FAT entries are filled by zero */   
   \   000002EE   0xF44F 0x7100      MOV      R1,#+512
   \   000002F2   0x4620             MOV      R0,R4
   \   000002F4   0x.... 0x....      BL       __aeabi_memclr
   1843                      for (n = 1; n < n_fat; n++) {   
   \   000002F8   0x2001             MOVS     R0,#+1
   \   000002FA   0xE00B             B.N      ??f_mkfs_26
   1844                          if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)   
   \                     ??f_mkfs_27: (+1)
   \   000002FC   0x2301             MOVS     R3,#+1
   \   000002FE   0x4642             MOV      R2,R8
   \   00000300   0x4621             MOV      R1,R4
   \   00000302   0x2000             MOVS     R0,#+0
   \   00000304   0x.... 0x....      BL       disk_write
   \   00000308   0x2800             CMP      R0,#+0
   \   0000030A   0xF108 0x0801      ADD      R8,R8,#+1
   \   0000030E   0xD141             BNE.N    ??f_mkfs_20
   1845                              return FR_RW_ERROR;   
   1846                      }   
   \   00000310   0x9800             LDR      R0,[SP, #+0]
   \   00000312   0x1C40             ADDS     R0,R0,#+1
   \                     ??f_mkfs_26: (+1)
   \   00000314   0x9000             STR      R0,[SP, #+0]
   \   00000316   0x9800             LDR      R0,[SP, #+0]
   \   00000318   0x42A8             CMP      R0,R5
   \   0000031A   0xD3EF             BCC.N    ??f_mkfs_27
   1847                  }   
   1848                 
   1849                  /* Initialize Root directory */   
   1850                  m = (BYTE)((fmt == FS_FAT32) ? allocsize : n_dir);   
   \   0000031C   0x2F03             CMP      R7,#+3
   \   0000031E   0xBF18             IT       NE 
   \   00000320   0x46DA             MOVNE    R10,R11
   1851                  do {   
   1852                      if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)   
   \                     ??f_mkfs_28: (+1)
   \   00000322   0x2301             MOVS     R3,#+1
   \   00000324   0x4642             MOV      R2,R8
   \   00000326   0x4621             MOV      R1,R4
   \   00000328   0x2000             MOVS     R0,#+0
   \   0000032A   0x.... 0x....      BL       disk_write
   \   0000032E   0xF108 0x0801      ADD      R8,R8,#+1
   \   00000332   0xBB78             CBNZ.N   R0,??f_mkfs_20
   1853                          return FR_RW_ERROR;   
   1854                  } while (--m);   
   \   00000334   0xF1AA 0x0001      SUB      R0,R10,#+1
   \   00000338   0xFA5F 0xFA80      UXTB     R10,R0
   \   0000033C   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000340   0xD1EF             BNE.N    ??f_mkfs_28
   1855                 
   1856                  /* Create FSInfo record if needed */   
   1857                  if (fmt == FS_FAT32) {   
   \   00000342   0x2F03             CMP      R7,#+3
   \   00000344   0xD120             BNE.N    ??f_mkfs_29
   1858                      ST_WORD(&tbl[BS_55AA], 0xAA55);   
   \   00000346   0xF504 0x71F2      ADD      R1,R4,#+484
   \   0000034A   0xF64A 0x2055      MOVW     R0,#+43605
   \   0000034E   0x8348             STRH     R0,[R1, #+26]
   1859                      ST_DWORD(&tbl[FSI_LeadSig], 0x41615252);   
   1860                      ST_DWORD(&tbl[FSI_StrucSig], 0x61417272);   
   1861                      ST_DWORD(&tbl[FSI_Free_Count], n_clust - 1);   
   1862                      ST_DWORD(&tbl[FSI_Nxt_Free], 0xFFFFFFFF);   
   1863                      disk_write(drv, tbl, b_part+1, 1);   
   \   00000350   0x2301             MOVS     R3,#+1
   \   00000352   0x4802             LDR.N    R0,??f_mkfs_30   ;; 0x41615252
   \   00000354   0x6020             STR      R0,[R4, #+0]
   \   00000356   0x1C72             ADDS     R2,R6,#+1
   \   00000358   0x4801             LDR.N    R0,??f_mkfs_30+0x4  ;; 0x61417272
   \   0000035A   0xE003             B.N      ??f_mkfs_31
   \                     ??f_mkfs_30:
   \   0000035C   0x41615252         DC32     0x41615252
   \   00000360   0x61417272         DC32     0x61417272
   \                     ??f_mkfs_31: (+1)
   \   00000364   0xF8C4 0x01E4      STR      R0,[R4, #+484]
   \   00000368   0xF1A9 0x0001      SUB      R0,R9,#+1
   \   0000036C   0x6048             STR      R0,[R1, #+4]
   \   0000036E   0xF04F 0x30FF      MOV      R0,#-1
   \   00000372   0x6088             STR      R0,[R1, #+8]
   \   00000374   0x4621             MOV      R1,R4
   \   00000376   0x2000             MOVS     R0,#+0
   \   00000378   0x.... 0x....      BL       disk_write
   1864                      disk_write(drv, tbl, b_part+7, 1);   
   \   0000037C   0x2301             MOVS     R3,#+1
   \   0000037E   0x1DF2             ADDS     R2,R6,#+7
   \   00000380   0x4621             MOV      R1,R4
   \   00000382   0x2000             MOVS     R0,#+0
   \   00000384   0x.... 0x....      BL       disk_write
   1865                  }   
   1866                 
   1867                  return (disk_ioctl(drv, CTRL_SYNC, NULL) == RES_OK) ? FR_OK : FR_RW_ERROR;   
   \                     ??f_mkfs_29: (+1)
   \   00000388   0x2200             MOVS     R2,#+0
   \   0000038A   0x2100             MOVS     R1,#+0
   \   0000038C   0x2000             MOVS     R0,#+0
   \   0000038E   0x.... 0x....      BL       disk_ioctl
   \   00000392   0xB100             CBZ.N    R0,??f_mkfs_6
   \                     ??f_mkfs_20: (+1)
   \   00000394   0x2008             MOVS     R0,#+8
   \                     ??f_mkfs_6: (+1)
   \   00000396                      REQUIRE ?Subroutine5
   \   00000396                      ;; // Fall through to label ?Subroutine5
   1868              }   

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0xB005             ADD      SP,SP,#+20
   \   00000002   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x46 0x41          DC8 "FAT"
   \              0x54 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x46 0x41          DC8 "FAT32"
   \              0x54 0x33    
   \              0x32 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x41615252         DC32     0x41615252

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x46 0x41          DC8      "FAT"
   \              0x54 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x61417272         DC32     0x61417272

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x........         DC32     fsid

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x4E 0x4F          DC8 "NO NAME    FAT     "
   \              0x20 0x4E    
   \              0x41 0x4D    
   \              0x45 0x20    
   \              0x20 0x20    
   \              0x20 0x46    
   \              0x41 0x54    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x4E 0x4F          DC8 "NO NAME    FAT32   "
   \              0x20 0x4E    
   \              0x41 0x4D    
   \              0x45 0x20    
   \              0x20 0x20    
   \              0x20 0x46    
   \              0x41 0x54    
   \              0x33 0x32    
   \              0x20 0x20    
   \              0x20 0x00    
   1869                 
   1870              #endif /* _USE_MKFS && !_FS_READONLY */   
   1871                 
   1872                 
   1873                 
   1874                 
   1875              #if _USE_STRFUNC >= 1   
   1876              /*-----------------------------------------------------------------------*/   
   1877              /* Get a string from the file                                            */   
   1878              /*-----------------------------------------------------------------------*/   
   1879              char* fgets (   
   1880                  char* buff, /* Pointer to the string buffer to read */   
   1881                  int len,    /* Size of string buffer */   
   1882                  FIL* fil    /* Pointer to the file object */   
   1883              )   
   1884              {   
   1885                  int i = 0;   
   1886                  char *p = buff;   
   1887                  UINT rc;   
   1888                 
   1889                 
   1890                  while (i < len - 1) {            /* Read bytes until buffer gets filled */   
   1891                      f_read(fil, p, 1, &rc);   
   1892                      if (rc != 1) break;         /* Break when no data to read */   
   1893              #if _USE_STRFUNC >= 2   
   1894                      if (*p == '\r') continue;   /* Strip '\r' */   
   1895              #endif   
   1896                      i++;   
   1897                      if (*p++ == '\n') break;    /* Break when reached end of line */   
   1898                  }   
   1899                  *p = 0;   
   1900                  return i ? buff : 0;            /* When no data read (eof or error), return with error. */   
   1901              }   
   1902                 
   1903                 
   1904                 
   1905              #if !_FS_READONLY   
   1906              #include <stdarg.h>   
   1907              /*-----------------------------------------------------------------------*/   
   1908              /* Put a character to the file                                           */   
   1909              /*-----------------------------------------------------------------------*/   
   1910              int fputc (   
   1911                  int chr,    /* A character to be output */   
   1912                  FIL* fil    /* Ponter to the file object */   
   1913              )   
   1914              {   
   1915                  UINT bw;   
   1916                  char c;   
   1917                 
   1918                 
   1919              #if _USE_STRFUNC >= 2   
   1920                  if (chr == '\n') fputc ('\r', fil); /* LF -> CRLF conversion */   
   1921              #endif   
   1922                  if (!fil) { /* Special value may be used to switch the destination to any other device */   
   1923                  /*  put_console(chr);   */   
   1924                      return chr;   
   1925                  }   
   1926                  c = (char)chr;   
   1927                  f_write(fil, &c, 1, &bw);   /* Write a byte to the file */   
   1928                  return bw ? chr : EOF;      /* Return the resulut */   
   1929              }   
   1930                 
   1931                 
   1932                 
   1933                 
   1934              /*-----------------------------------------------------------------------*/   
   1935              /* Put a string to the file                                              */   
   1936              /*-----------------------------------------------------------------------*/   
   1937              int fputs (   
   1938                  const char* str,    /* Pointer to the string to be output */   
   1939                  FIL* fil            /* Pointer to the file object */   
   1940              )   
   1941              {   
   1942                  int n;   
   1943                 
   1944                 
   1945                  for (n = 0; *str; str++, n++) {   
   1946                      if (fputc(*str, fil) == EOF) return EOF;   
   1947                  }   
   1948                  return n;   
   1949              }   
   1950                 
   1951                 
   1952                 
   1953                 
   1954              /*-----------------------------------------------------------------------*/   
   1955              /* Put a formatted string to the file                                    */   
   1956              /*-----------------------------------------------------------------------*/   
   1957              int fprintf (   
   1958                  FIL* fil,           /* Pointer to the file object */   
   1959                  const char* str,    /* Pointer to the format string */   
   1960                  ...                 /* Optional arguments... */   
   1961              )   
   1962              {   
   1963                  va_list arp;   
   1964                  UCHAR c, f, r;   
   1965                  ULONG val;   
   1966                  char s[16];   
   1967                  int i, w, res, cc;   
   1968                 
   1969                 
   1970                  va_start(arp, str);   
   1971                 
   1972                  for (cc = res = 0; cc != EOF; res += cc) {   
   1973                      c = *str++;   
   1974                      if (c == 0) break;          /* End of string */   
   1975                      if (c != '%') {             /* Non escape cahracter */   
   1976                          cc = fputc(c, fil);   
   1977                          if (cc != EOF) cc = 1;   
   1978                          continue;   
   1979                      }   
   1980                      w = f = 0;   
   1981                      c = *str++;   
   1982                      if (c == '0') {             /* Flag: '0' padding */   
   1983                          f = 1; c = *str++;   
   1984                      }   
   1985                      while (c >= '0' && c <= '9') {    /* Precision */   
   1986                          w = w * 10 + (c - '0');   
   1987                          c = *str++;   
   1988                      }   
   1989                      if (c == 'l') {             /* Prefix: Size is long int */   
   1990                          f |= 2; c = *str++;   
   1991                      }   
   1992                      if (c == 's') {             /* Type is string */   
   1993                          cc = fputs(va_arg(arp, char*), fil);   
   1994                          continue;   
   1995                      }   
   1996                      if (c == 'c') {             /* Type is character */   
   1997                          cc = fputc(va_arg(arp, char), fil);   
   1998                          if (cc != EOF) cc = 1;   
   1999                          continue;   
   2000                      }   
   2001                      r = 0;   
   2002                      if (c == 'd') r = 10;       /* Type is signed decimal */   
   2003                      if (c == 'u') r = 10;       /* Type is unsigned decimal */   
   2004                      if (c == 'X') r = 16;       /* Type is unsigned hexdecimal */   
   2005                      if (r == 0) break;          /* Unknown type */   
   2006                      if (f & 2) {                /* Get the value */   
   2007                          val = (ULONG)va_arg(arp, long);   
   2008                      } else {   
   2009                          val = (c == 'd') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int);   
   2010                      }   
   2011                      /* Put numeral string */   
   2012                      if (c == 'd') {   
   2013                          if (val >= 0x80000000) {   
   2014                              val = 0 - val;   
   2015                              f |= 4;   
   2016                          }   
   2017                      }   
   2018                      i = sizeof(s) - 1; s[i] = 0;   
   2019                      do {   
   2020                          c = (UCHAR)(val % r + '0');   
   2021                          if (c > '9') c += 7;   
   2022                          s[--i] = c;   
   2023                          val /= r;   
   2024                      } while (i && val);   
   2025                      if (i && (f & 4)) s[--i] = '-';   
   2026                      w = sizeof(s) - 1 - w;   
   2027                      while (i && i > w) s[--i] = (f & 1) ? '0' : ' ';   
   2028                      cc = fputs(&s[i], fil);   
   2029                  }   
   2030                 
   2031                  va_end(arp);   
   2032                  return (cc == EOF) ? cc : res;   
   2033              }   
   2034                 
   2035              #endif /* !_FS_READONLY */   
   2036              #endif /* _USE_STRFUNC >= 1*/   
   2037          
   2038          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   auto_mount
        32   -> __aeabi_memclr4
        32   -> check_fs
        32   -> disk_initialize
        32   -> disk_read
        32   -> disk_status
        32   -> memcmp
       8   check_fs
         8   -> disk_read
         8   -> memcmp
       0   clust2sect
      32   create_chain
        32   -> get_cluster
        32   -> put_cluster
      56   f_chmod
        56   -> auto_mount
        56   -> sync
        56   -> trace_path
       8   f_close
         8   -> f_sync
      40   f_getfree
        40   -> auto_mount
        40   -> get_cluster
        40   -> move_window
      16   f_lseek
        16   -> clust2sect
        16   -> create_chain
        16   -> disk_read
        16   -> disk_write
        16   -> get_cluster
        16   -> validate
      64   f_mkdir
        64   -> __aeabi_memclr
        64   -> __aeabi_memcpy
        64   -> __aeabi_memset
        64   -> auto_mount
        64   -> create_chain
        64   -> disk_write
        64   -> get_fattime
        64   -> move_window
        64   -> reserve_direntry
        64   -> sync
        64   -> trace_path
      56   f_mkfs
        56   -> __aeabi_memclr
        56   -> __aeabi_memcpy
        56   -> disk_initialize
        56   -> disk_ioctl
        56   -> disk_write
        56   -> get_fattime
       0   f_mount
      64   f_open
        64   -> __aeabi_memclr
        64   -> __aeabi_memcpy
        64   -> auto_mount
        64   -> get_fattime
        64   -> move_window
        64   -> remove_chain
        64   -> reserve_direntry
        64   -> trace_path
      32   f_opendir
        32   -> auto_mount
        32   -> clust2sect
        32   -> trace_path
      32   f_read
        32   -> __aeabi_memcpy
        32   -> disk_read
        32   -> disk_write
        32   -> get_cluster
        32   -> validate
      16   f_readdir
        16   -> get_fileinfo
        16   -> move_window
        16   -> next_dir_entry
        16   -> validate
      80   f_rename
        80   -> __aeabi_memcpy
        80   -> auto_mount
        80   -> move_window
        80   -> reserve_direntry
        80   -> sync
        80   -> trace_path
      56   f_stat
        56   -> auto_mount
        56   -> get_fileinfo
        56   -> trace_path
      16   f_sync
        16   -> disk_write
        16   -> get_fattime
        16   -> move_window
         0   -> sync
        16   -> validate
      16   f_truncate
        16   -> get_cluster
        16   -> put_cluster
        16   -> remove_chain
        16   -> validate
      56   f_unlink
        56   -> auto_mount
        56   -> clust2sect
        56   -> move_window
        56   -> next_dir_entry
        56   -> remove_chain
        56   -> sync
        56   -> trace_path
      48   f_utime
        48   -> auto_mount
        48   -> sync
        48   -> trace_path
      32   f_write
        32   -> __aeabi_memcpy
        32   -> create_chain
        32   -> disk_read
        32   -> disk_write
        32   -> validate
      40   get_cluster
        40   -> disk_read
        40   -> disk_write
      16   get_fileinfo
      24   make_dirfile
        24   -> __aeabi_memset
      32   move_window
        32   -> disk_read
        32   -> disk_write
      16   next_dir_entry
        16   -> clust2sect
        16   -> get_cluster
      40   put_cluster
        40   -> disk_read
        40   -> disk_write
        40   -> move_window
      32   remove_chain
        32   -> get_cluster
        32   -> move_window
      40   reserve_direntry
        40   -> __aeabi_memclr4
        40   -> clust2sect
        40   -> create_chain
        40   -> disk_read
        40   -> disk_write
        40   -> next_dir_entry
      24   sync
        24   -> __aeabi_memclr4
        24   -> disk_ioctl
        24   -> disk_write
      48   trace_path
        48   -> clust2sect
        48   -> disk_read
        48   -> disk_write
        48   -> get_cluster
        48   -> make_dirfile
        48   -> memcmp
       8   validate
         8   -> disk_status


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       6  ?Subroutine0
       6  ?Subroutine1
       6  ?Subroutine2
       6  ?Subroutine3
       6  ?Subroutine4
       6  ?Subroutine5
       6  ?Subroutine6
       4  ?_0
       8  ?_1
      20  ?_2
      20  ?_3
     472  auto_mount
      86  check_fs
      24  clust2sect
     132  create_chain
      70  f_chmod
      16  f_close
     178  f_getfree
     296  f_lseek
     324  f_mkdir
     918  f_mkfs
      32  f_mount
     320  f_open
      88  f_opendir
     336  f_read
      92  f_readdir
     168  f_rename
      58  f_stat
     116  f_sync
     120  f_truncate
     190  f_unlink
      64  f_utime
     384  f_write
       8  fsid
          FatFs
     574  get_cluster
     128  get_fileinfo
     210  make_dirfile
     110  move_window
      86  next_dir_entry
     300  put_cluster
     236  remove_chain
     352  reserve_direntry
     174  sync
     392  trace_path
      46  validate

 
     8 bytes in section .bss
     4 bytes in section .rodata
 7 198 bytes in section .text
 
 7 198 bytes of CODE  memory
     4 bytes of CONST memory
     8 bytes of DATA  memory

Errors: none
Warnings: none
