###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       09/Feb/2018  16:14:56
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\HW Projects\ControlHome\CntrHome -
#        RF69w\uc-terminal\src\hw_config.c
#    Command line =  
#        "E:\HW Projects\ControlHome\CntrHome -
#        RF69w\uc-terminal\src\hw_config.c" -lCN "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Debug\List" -o "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Debug\Obj" --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\APP\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\BSP\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\CPU\inc\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-CPU\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-RTC\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-LIB\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uCOS-II\Ports\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uCOS-II\Source\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\I2C-Out\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Direct_Sw\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Wdt_led\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-LCD\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-RF\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\api\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\config\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\os\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\fsl\fat\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\clib\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\lbl\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\device\mmc\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\file\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-Terminal\src\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-Terminal\inc\" -Oh
#    List file    =  
#        E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\List\hw_config.lst
#    Object file  =  
#        E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\Obj\hw_config.o
#
###############################################################################

E:\HW Projects\ControlHome\CntrHome - RF69w\uc-terminal\src\hw_config.c
      1          /******************** (C) COPYRIGHT 2011 STMicroelectronics ********************
      2           * File Name          : hw_config.c
      3           * Author             : MCD Application Team
      4           * Version            : V3.3.0
      5           * Date               : 21-March-2011
      6           * Description        : Hardware Configuration & Setup
      7           ********************************************************************************
      8           * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9           * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10           * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11           * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12           * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13           * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14           *******************************************************************************/
     15          
     16          #include <includes.h>
     17          #if USBD_MODULE == DEF_ENABLED
     18             

   \                                 In section .bss, align 4
     19          USB_COM_FIFO_T g_tUsbFifo;
   \                     g_tUsbFifo:
   \   00000000                      DS8 152
     20          
     21          extern INT16U i; 

   \                                 In section .bss, align 2
     22          INT16U usRxWrite, usData;
     23          INT8U  ucData, idx;
   \                     ucData:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \                     usRxWrite:
   \   00000002                      DS8 2

   \                                 In section .bss, align 2
   \                     usData:
   \   00000000                      DS8 2

   \                                 In section .bss, align 4
   \                     idx:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
     24          INT32U Device_Serial0, Device_Serial1, Device_Serial2;
   \                     Device_Serial0:
   \   00000004                      DS8 4
   \                     Device_Serial1:
   \   00000008                      DS8 4
   \                     Device_Serial2:
   \   0000000C                      DS8 4
     25          
     26          void Set_USBClock(void);
     27          void USB_Interrupts_Config(void);
     28          void IntToUnicode(INT32U value, INT8U *pbuf, INT8U len);
     29          void USB_LP_CAN1_RX0_IRQHandler(void);
     30          
     31          
     32          /*******************************************************************************
     33           * Description    : Configures Main system clocks & power
     34           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     35          void Set_USBSystem(void)
     36          {
   \                     Set_USBSystem: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
     37            GPIO_InitTypeDef GPIO_InitStructure;
     38            
     39                  RCC_APB2PeriphResetCmd(  RCC_APB2Periph_GPIOA
     40                                         | RCC_APB2Periph_GPIOC
     41                                         | RCC_APB2Periph_AFIO, DISABLE);
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x2015             MOVS     R0,#+21
   \   00000008   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     42                  RCC_APB2PeriphClockCmd(  RCC_APB2Periph_GPIOA
     43                                         | RCC_APB2Periph_GPIOC
     44                                         | RCC_APB2Periph_AFIO, ENABLE);
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x2015             MOVS     R0,#+21
   \   00000010   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     45          
     46          
     47                   // Configure PC11 USB connect.
     48                  GPIO_WriteBit(GPIOC,GPIO_Pin_11,Bit_SET);
   \   00000014   0x....             LDR.N    R4,??DataTable10  ;; 0x40011000
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0xF44F 0x6100      MOV      R1,#+2048
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       GPIO_WriteBit
     49                  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_11;
   \   00000022   0xF44F 0x6000      MOV      R0,#+2048
   \   00000026   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     50                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
     51                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     52                  GPIO_Init(GPIOC, &GPIO_InitStructure);
   \   0000002A   0x4669             MOV      R1,SP
   \   0000002C   0x2004             MOVS     R0,#+4
   \   0000002E   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   00000032   0x2003             MOVS     R0,#+3
   \   00000034   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       GPIO_Init
     53                  // Configure PC12 USB reset.
     54                  GPIO_WriteBit(GPIOC,GPIO_Pin_12,Bit_SET);
   \   0000003E   0x2201             MOVS     R2,#+1
   \   00000040   0xF44F 0x5180      MOV      R1,#+4096
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0x.... 0x....      BL       GPIO_WriteBit
     55                  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_12;
   \   0000004A   0xF44F 0x5080      MOV      R0,#+4096
   \   0000004E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     56                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
     57                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     58                  GPIO_Init(GPIOC, &GPIO_InitStructure);
   \   00000052   0x4669             MOV      R1,SP
   \   00000054   0x2014             MOVS     R0,#+20
   \   00000056   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   0000005A   0x2003             MOVS     R0,#+3
   \   0000005C   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   00000060   0x4620             MOV      R0,R4
   \   00000062   0x.... 0x....      BL       GPIO_Init
     59                  
     60                  Set_USBClock();
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x.... 0x....      BL       RCC_USBCLKConfig
   \   0000006C   0x2101             MOVS     R1,#+1
   \   0000006E   0xF44F 0x0000      MOV      R0,#+8388608
   \   00000072   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
     61                  USB_Interrupts_Config();
   \   00000076   0x.... 0x....      ADR.W    R1,USB_LP_CAN1_RX0_IRQHandler
   \   0000007A   0x2014             MOVS     R0,#+20
   \   0000007C   0x.... 0x....      BL       BSP_IntVectSet
   \   00000080   0x2101             MOVS     R1,#+1
   \   00000082   0x2014             MOVS     R0,#+20
   \   00000084   0x.... 0x....      BL       BSP_IntPrioSet
   \   00000088   0x2014             MOVS     R0,#+20
   \   0000008A   0x.... 0x....      BL       BSP_IntEn
     62                  USB_Init();
   \   0000008E   0x.... 0x....      BL       USB_Init
     63                  
     64                  g_tUsbFifo.usRxWrite = 0;
   \   00000092   0x....             LDR.N    R0,??DataTable10_1
   \   00000094   0x2100             MOVS     R1,#+0
     65          	g_tUsbFifo.usRxRead = 0;
   \   00000096   0x6041             STR      R1,[R0, #+4]
     66          	g_tUsbFifo.usTxWrite = 0;
     67          	g_tUsbFifo.usTxRead = 0;
   \   00000098   0x6001             STR      R1,[R0, #+0]
     68            
     69          }
   \   0000009A   0xBD13             POP      {R0,R1,R4,PC}    ;; return
     70          /*******************************************************************************
     71           * Description    : Configures USB Clock input (48MHz)
     72           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     73          void Set_USBClock(void)
     74          {
   \                     Set_USBClock: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     75          
     76          	// Select USBCLK source 
     77          	RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      BL       RCC_USBCLKConfig
     78          
     79          	// Enable the USB clock 
     80          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
   \   00000008   0xE8BD 0x4004      POP      {R2,LR}
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF44F 0x0000      MOV      R0,#+8388608
   \   00000012   0x.... 0x....      B.W      RCC_APB1PeriphClockCmd
     81                 
     82          }
     83          
     84          /*******************************************************************************
     85           * Description    : Power-off system clocks and power while entering suspend mode
     86           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     87          void usb_EnterLowPowerMode(void)
     88          {
     89          	/* Set the device state to suspend */
     90          	bDeviceState = SUSPENDED;
   \                     usb_EnterLowPowerMode: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable10_2
   \   00000002   0x2003             MOVS     R0,#+3
   \   00000004   0x6008             STR      R0,[R1, #+0]
     91          }
   \   00000006   0x4770             BX       LR               ;; return
     92          
     93          /*******************************************************************************
     94           * Description    : Restores system clocks and power while exiting suspend mode
     95           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     96          void usb_LeaveLowPowerMode(void)
     97          {
     98          	DEVICE_INFO *pInfo = &Device_Info;
     99          
    100          	/* Set the device state to the correct state */
    101          	if (pInfo->Current_Configuration != 0)
   \                     usb_LeaveLowPowerMode: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_3
    102          	{
    103          		/* Device configured */
    104          		bDeviceState = CONFIGURED;
    105          	}
    106          	else
    107          	{
    108          		bDeviceState = ATTACHED;
   \   00000002   0x....             LDR.N    R1,??DataTable10_2
   \   00000004   0x7A80             LDRB     R0,[R0, #+10]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xBF14             ITE      NE 
   \   0000000A   0x2005             MOVNE    R0,#+5
   \   0000000C   0x2001             MOVEQ    R0,#+1
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    109          	}
    110          }
   \   00000010   0x4770             BX       LR               ;; return
    111          
    112          /*******************************************************************************
    113           * Description    : Configures the USB interrupts
    114           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    115          void USB_Interrupts_Config(void)
    116          {
   \                     USB_Interrupts_Config: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    117                  BSP_IntVectSet(BSP_INT_ID_USB_LP_CAN_RX0, USB_LP_CAN1_RX0_IRQHandler);
   \   00000002   0x.... 0x....      ADR.W    R1,USB_LP_CAN1_RX0_IRQHandler
   \   00000006   0x2014             MOVS     R0,#+20
   \   00000008   0x.... 0x....      BL       BSP_IntVectSet
    118                  BSP_IntPrioSet(BSP_INT_ID_USB_LP_CAN_RX0,1);
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x2014             MOVS     R0,#+20
   \   00000010   0x.... 0x....      BL       BSP_IntPrioSet
    119          	BSP_IntEn(BSP_INT_ID_USB_LP_CAN_RX0);
   \   00000014   0xE8BD 0x4002      POP      {R1,LR}
   \   00000018   0x2014             MOVS     R0,#+20
   \   0000001A   0x.... 0x....      B.W      BSP_IntEn
    120          }
    121          
    122          /*******************************************************************************
    123          * Function Name  : USB_LP_CAN_RX0_IRQHandler
    124          * Description    : This function handles USB Low Priority or CAN RX0 interrupts 
    125          *                  requests.
    126          * Input          : None
    127          * Output         : None
    128          * Return         : None
    129          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    130          void USB_LP_CAN1_RX0_IRQHandler(void)
    131          {
   \                     USB_LP_CAN1_RX0_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    132              OS_CPU_SR  cpu_sr;
    133          
    134          
    135              OS_ENTER_CRITICAL();                         /* Tell uC/OS-II that we are starting an ISR          */
   \   00000002   0x.... 0x....      BL       OS_CPU_SR_Save
    136              OSIntNesting++;
   \   00000006   0x....             LDR.N    R1,??DataTable10_4
   \   00000008   0x780A             LDRB     R2,[R1, #+0]
   \   0000000A   0x1C52             ADDS     R2,R2,#+1
   \   0000000C   0x700A             STRB     R2,[R1, #+0]
    137              OS_EXIT_CRITICAL();
   \   0000000E   0x.... 0x....      BL       OS_CPU_SR_Restore
    138          
    139          	usb_Istr();
   \   00000012   0x.... 0x....      BL       usb_Istr
    140          
    141              OSIntExit();
   \   00000016   0xE8BD 0x4001      POP      {R0,LR}
   \   0000001A   0x.... 0x....      B.W      OSIntExit
    142          	
    143          }
    144          /*******************************************************************************
    145           * Description    : Software Connection/Disconnection of USB Cable
    146           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    147          void usb_CableConfig(INT8U _ucMode)
    148          {
    149                 if (_ucMode != DISABLE)
   \                     usb_CableConfig: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable10  ;; 0x40011000
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xF44F 0x5180      MOV      R1,#+4096
   \   00000008   0x4610             MOV      R0,R2
   \   0000000A   0xBF18             IT       NE 
    150                   {
    151                     GPIO_ResetBits(GPIOC, GPIO_Pin_12);
   \   0000000C   0x.... 0x....      BNE.W    GPIO_ResetBits
    152                   } else
    153                     {
    154                       GPIO_SetBits(GPIOC, GPIO_Pin_12);
   \   00000010   0x.... 0x....      B.W      GPIO_SetBits
    155                     }
    156          
    157          }
    158          
    159          /*******************************************************************************
    160           * Description    : Create the serial number string descriptor.
    161           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    162          void Get_SerialNum(INT8U *_pBuf)
    163          
    164          {
   \                     Get_SerialNum: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    165          	Device_Serial0 = *(INT32U*) (0x1FFFF7E8);
   \   00000002   0x....             LDR.N    R2,??DataTable10_5  ;; 0x1ffff7e8
   \   00000004   0x....             LDR.N    R1,??DataTable10_6
   \   00000006   0x6813             LDR      R3,[R2, #+0]
   \   00000008   0x604B             STR      R3,[R1, #+4]
    166          	Device_Serial1 = *(INT32U*) (0x1FFFF7EC);
   \   0000000A   0x6854             LDR      R4,[R2, #+4]
   \   0000000C   0x608C             STR      R4,[R1, #+8]
    167          	Device_Serial2 = *(INT32U*) (0x1FFFF7F0);
   \   0000000E   0x6892             LDR      R2,[R2, #+8]
   \   00000010   0x60CA             STR      R2,[R1, #+12]
    168          
    169          	Device_Serial0 += Device_Serial2;
   \   00000012   0x18D2             ADDS     R2,R2,R3
   \   00000014   0x604A             STR      R2,[R1, #+4]
    170          
    171          	if (Device_Serial0 != 0)
   \   00000016   0xD02C             BEQ.N    ??Get_SerialNum_0
    172          	{
    173          		IntToUnicode(Device_Serial0, &_pBuf[2], 8);
   \   00000018   0x2400             MOVS     R4,#+0
   \   0000001A   0x1C83             ADDS     R3,R0,#+2
   \   0000001C   0x700C             STRB     R4,[R1, #+0]
   \                     ??Get_SerialNum_1: (+1)
   \   0000001E   0x780C             LDRB     R4,[R1, #+0]
   \   00000020   0x0F15             LSRS     R5,R2,#+28
   \   00000022   0x2D0A             CMP      R5,#+10
   \   00000024   0xBF34             ITE      CC 
   \   00000026   0x3530             ADDCC    R5,R5,#+48
   \   00000028   0x3537             ADDCS    R5,R5,#+55
   \   0000002A   0xF803 0x5014      STRB     R5,[R3, R4, LSL #+1]
   \   0000002E   0x2500             MOVS     R5,#+0
   \   00000030   0x780C             LDRB     R4,[R1, #+0]
   \   00000032   0xEB03 0x0444      ADD      R4,R3,R4, LSL #+1
   \   00000036   0x0112             LSLS     R2,R2,#+4
   \   00000038   0x7065             STRB     R5,[R4, #+1]
   \   0000003A   0x780C             LDRB     R4,[R1, #+0]
   \   0000003C   0x1C64             ADDS     R4,R4,#+1
   \   0000003E   0x700C             STRB     R4,[R1, #+0]
   \   00000040   0xB2E4             UXTB     R4,R4
   \   00000042   0x2C08             CMP      R4,#+8
   \   00000044   0xD3EB             BCC.N    ??Get_SerialNum_1
    174          		IntToUnicode(Device_Serial1, &_pBuf[18], 4);
   \   00000046   0x3012             ADDS     R0,R0,#+18
   \   00000048   0x688A             LDR      R2,[R1, #+8]
   \   0000004A   0x700D             STRB     R5,[R1, #+0]
   \                     ??Get_SerialNum_2: (+1)
   \   0000004C   0x780B             LDRB     R3,[R1, #+0]
   \   0000004E   0x0F14             LSRS     R4,R2,#+28
   \   00000050   0x2C0A             CMP      R4,#+10
   \   00000052   0xBF34             ITE      CC 
   \   00000054   0x3430             ADDCC    R4,R4,#+48
   \   00000056   0x3437             ADDCS    R4,R4,#+55
   \   00000058   0xF800 0x4013      STRB     R4,[R0, R3, LSL #+1]
   \   0000005C   0x0112             LSLS     R2,R2,#+4
   \   0000005E   0x780B             LDRB     R3,[R1, #+0]
   \   00000060   0xEB00 0x0343      ADD      R3,R0,R3, LSL #+1
   \   00000064   0x705D             STRB     R5,[R3, #+1]
   \   00000066   0x780B             LDRB     R3,[R1, #+0]
   \   00000068   0x1C5B             ADDS     R3,R3,#+1
   \   0000006A   0x700B             STRB     R3,[R1, #+0]
   \   0000006C   0xB2DB             UXTB     R3,R3
   \   0000006E   0x2B04             CMP      R3,#+4
   \   00000070   0xD3EC             BCC.N    ??Get_SerialNum_2
    175          	}
    176          }
   \                     ??Get_SerialNum_0: (+1)
   \   00000072   0xBC30             POP      {R4,R5}
   \   00000074   0x4770             BX       LR               ;; return
    177          
    178          /*******************************************************************************
    179           * Description    : Convert Hex 32Bits value into char.
    180           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    181          void IntToUnicode(INT32U value, INT8U *pbuf, INT8U len)
    182          {
   \                     IntToUnicode: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    183          	for (idx = 0; idx < len; idx++)
   \   00000002   0x....             LDR.N    R3,??DataTable10_6
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0xE009             B.N      ??IntToUnicode_0
    184          	{
    185          		if (((value >> 28)) < 0xA)
    186          		{
    187          			pbuf[2 * idx] = (value >> 28) + '0';
    188          		}
    189          		else
    190          		{
    191          			pbuf[2 * idx] = (value >> 28) + 'A' - 10;
   \                     ??IntToUnicode_1: (+1)
   \   00000008   0xF801 0x5014      STRB     R5,[R1, R4, LSL #+1]
    192          		}
    193          
    194          		value = value << 4;
    195          
    196          		pbuf[2 * idx + 1] = 0;
   \   0000000C   0x2500             MOVS     R5,#+0
   \   0000000E   0x781C             LDRB     R4,[R3, #+0]
   \   00000010   0xEB01 0x0444      ADD      R4,R1,R4, LSL #+1
   \   00000014   0x0100             LSLS     R0,R0,#+4
   \   00000016   0x7065             STRB     R5,[R4, #+1]
   \   00000018   0x781C             LDRB     R4,[R3, #+0]
   \   0000001A   0x1C64             ADDS     R4,R4,#+1
   \                     ??IntToUnicode_0: (+1)
   \   0000001C   0x701C             STRB     R4,[R3, #+0]
   \   0000001E   0x781C             LDRB     R4,[R3, #+0]
   \   00000020   0x4294             CMP      R4,R2
   \   00000022   0xD205             BCS.N    ??IntToUnicode_2
   \   00000024   0x0F05             LSRS     R5,R0,#+28
   \   00000026   0x2D0A             CMP      R5,#+10
   \   00000028   0xBF34             ITE      CC 
   \   0000002A   0x3530             ADDCC    R5,R5,#+48
   \   0000002C   0x3537             ADDCS    R5,R5,#+55
   \   0000002E   0xE7EB             B.N      ??IntToUnicode_1
    197          	}
    198          }
   \                     ??IntToUnicode_2: (+1)
   \   00000030   0xBC30             POP      {R4,R5}
   \   00000032   0x4770             BX       LR               ;; return
    199          /*
    200          *********************************************************************************************************
    201          *	usb_SendBuf
    202          *********************************************************************************************************
    203          */

   \                                 In section .text, align 2, keep-with-next
    204          void usb_SendBuf(INT8U *_pTxBuf, INT8U _ucLen)
    205          {
   \                     usb_SendBuf: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    206              UserToPMABufferCopy(_pTxBuf, ENDP1_TXADDR, _ucLen);
   \   00000004   0x4622             MOV      R2,R4
   \   00000006   0x21C0             MOVS     R1,#+192
   \   00000008   0x.... 0x....      BL       UserToPMABufferCopy
    207              SetEPTxCount(ENDP1, _ucLen);
   \   0000000C   0x4621             MOV      R1,R4
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       SetEPTxCount
    208              SetEPTxValid(ENDP1); 
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x.... 0x....      BL       SetEPTxValid
    209              while(GetEPTxStatus(ENDP1) != EP_TX_NAK);    
   \                     ??usb_SendBuf_0: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x.... 0x....      BL       GetEPTxStatus
   \   00000020   0x2820             CMP      R0,#+32
   \   00000022   0xD1FA             BNE.N    ??usb_SendBuf_0
    210          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    211          
    212          /*
    213          *********************************************************************************************************
    214          *	SaveHostDataToBuf
    215          *********************************************************************************************************
    216          */

   \                                 In section .text, align 2, keep-with-next
    217          void usb_SaveHostDataToBuf(INT8U *_pInBuf, INT16U _usLen)
    218          {        
    219          	for (i = 0 ; i < _usLen; i++)
   \                     usb_SaveHostDataToBuf: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable10_7
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x8013             STRH     R3,[R2, #+0]
   \   00000006   0xB901             CBNZ.N   R1,??usb_SaveHostDataToBuf_0
   \   00000008   0x4770             BX       LR
   \                     ??usb_SaveHostDataToBuf_0: (+1)
   \   0000000A   0xB430             PUSH     {R4,R5}
   \   0000000C   0x....             LDR.N    R3,??DataTable10_8
    220          	{
    221          		g_tUsbFifo.aRxBuf[g_tUsbFifo.usRxWrite] = _pInBuf[i];
   \                     ??usb_SaveHostDataToBuf_1: (+1)
   \   0000000E   0xF8B3 0x5092      LDRH     R5,[R3, #+146]
   \   00000012   0x7804             LDRB     R4,[R0, #+0]
   \   00000014   0x18ED             ADDS     R5,R5,R3
   \   00000016   0xF885 0x4078      STRB     R4,[R5, #+120]
    222          		
    223          		if (++g_tUsbFifo.usRxWrite >= USB_RX_BUF_SIZE)
   \   0000001A   0xF8B3 0x4092      LDRH     R4,[R3, #+146]
   \   0000001E   0x1C64             ADDS     R4,R4,#+1
   \   00000020   0xF8A3 0x4092      STRH     R4,[R3, #+146]
   \   00000024   0xB2A4             UXTH     R4,R4
   \   00000026   0x2C14             CMP      R4,#+20
   \   00000028   0xBFA4             ITT      GE 
   \   0000002A   0x2400             MOVGE    R4,#+0
   \   0000002C   0xF8A3 0x4092      STRHGE   R4,[R3, #+146]
    224          		{
    225          			g_tUsbFifo.usRxWrite = 0;
    226          		}
    227          	}
   \   00000030   0x8814             LDRH     R4,[R2, #+0]
   \   00000032   0x1C64             ADDS     R4,R4,#+1
   \   00000034   0x8014             STRH     R4,[R2, #+0]
   \   00000036   0x1C40             ADDS     R0,R0,#+1
   \   00000038   0xB2A4             UXTH     R4,R4
   \   0000003A   0x428C             CMP      R4,R1
   \   0000003C   0xD3E7             BCC.N    ??usb_SaveHostDataToBuf_1
    228          }
   \   0000003E   0xBC30             POP      {R4,R5}
   \   00000040   0x4770             BX       LR               ;; return
    229          
    230          /*
    231          *********************************************************************************************************
    232          *	usb_GetRxByte
    233          *********************************************************************************************************
    234          */

   \                                 In section .text, align 2, keep-with-next
    235          BOOLEAN usb_GetRxByte(void)
    236          {
    237            usRxWrite = g_tUsbFifo.usRxWrite;
   \                     usb_GetRxByte: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_8
   \   00000002   0x....             LDR.N    R3,??DataTable10_9
   \   00000004   0xF100 0x0190      ADD      R1,R0,#+144
   \   00000008   0x884A             LDRH     R2,[R1, #+2]
   \   0000000A   0x805A             STRH     R2,[R3, #+2]
    238          	
    239            if (g_tUsbFifo.usRxRead == usRxWrite)
   \   0000000C   0xF8B1 0xC000      LDRH     R12,[R1, #+0]
   \   00000010   0x4594             CMP      R12,R2
   \   00000012   0xD101             BNE.N    ??usb_GetRxByte_0
    240            {
    241              return FALSE;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4770             BX       LR
    242            }
    243          	
    244          	
    245            ucData = g_tUsbFifo.aRxBuf[g_tUsbFifo.usRxRead];
   \                     ??usb_GetRxByte_0: (+1)
   \   00000018   0x4460             ADD      R0,R12,R0
   \   0000001A   0xF890 0x0078      LDRB     R0,[R0, #+120]
   \   0000001E   0x7018             STRB     R0,[R3, #+0]
    246          	
    247          	
    248            if (++g_tUsbFifo.usRxRead >= USB_RX_BUF_SIZE)
   \   00000020   0xF10C 0x0001      ADD      R0,R12,#+1
   \   00000024   0x8008             STRH     R0,[R1, #+0]
   \   00000026   0xB280             UXTH     R0,R0
   \   00000028   0x2814             CMP      R0,#+20
   \   0000002A   0xBFA4             ITT      GE 
   \   0000002C   0x2000             MOVGE    R0,#+0
   \   0000002E   0x8008             STRHGE   R0,[R1, #+0]
    249            {
    250              g_tUsbFifo.usRxRead = 0;
    251            }
    252            		
    253            return TRUE;		
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x4770             BX       LR               ;; return
    254          }
    255          
    256          /*
    257          *********************************************************************************************************
    258          *	SendDataToHost
    259          *********************************************************************************************************
    260          */

   \                                 In section .text, align 2, keep-with-next
    261          void usb_SendDataToHost(INT8U *_pTxBuf, INT16U _usLen)
    262          {
    263            for (i = 0 ; i < _usLen; i++)
   \                     usb_SendDataToHost: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable10_7
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x8013             STRH     R3,[R2, #+0]
   \   00000006   0xB901             CBNZ.N   R1,??usb_SendDataToHost_0
   \   00000008   0x4770             BX       LR
   \                     ??usb_SendDataToHost_0: (+1)
   \   0000000A   0xB430             PUSH     {R4,R5}
   \   0000000C   0x....             LDR.N    R3,??DataTable10_8
    264            {
    265              g_tUsbFifo.aTxBuf[g_tUsbFifo.usTxWrite] = _pTxBuf[i];
   \                     ??usb_SendDataToHost_1: (+1)
   \   0000000E   0xF8B3 0x508E      LDRH     R5,[R3, #+142]
   \   00000012   0x7804             LDRB     R4,[R0, #+0]
   \   00000014   0x54EC             STRB     R4,[R5, R3]
    266          	
    267              if (++g_tUsbFifo.usTxWrite >= USB_RX_BUF_SIZE)
   \   00000016   0xF8B3 0x408E      LDRH     R4,[R3, #+142]
   \   0000001A   0x1C64             ADDS     R4,R4,#+1
   \   0000001C   0xF8A3 0x408E      STRH     R4,[R3, #+142]
   \   00000020   0xB2A4             UXTH     R4,R4
   \   00000022   0x2C14             CMP      R4,#+20
   \   00000024   0xBFA4             ITT      GE 
   \   00000026   0x2400             MOVGE    R4,#+0
   \   00000028   0xF8A3 0x408E      STRHGE   R4,[R3, #+142]
    268              {
    269                g_tUsbFifo.usTxWrite = 0;
    270              }	
    271            }
   \   0000002C   0x8814             LDRH     R4,[R2, #+0]
   \   0000002E   0x1C64             ADDS     R4,R4,#+1
   \   00000030   0x8014             STRH     R4,[R2, #+0]
   \   00000032   0x1C40             ADDS     R0,R0,#+1
   \   00000034   0xB2A4             UXTH     R4,R4
   \   00000036   0x428C             CMP      R4,R1
   \   00000038   0xD3E9             BCC.N    ??usb_SendDataToHost_1
    272          }
   \   0000003A   0xBC30             POP      {R4,R5}
   \   0000003C   0x4770             BX       LR               ;; return
    273          
    274          /*
    275          *********************************************************************************************************
    276          *	usb_GetTxWord
    277          *********************************************************************************************************
    278          */

   \                                 In section .text, align 2, keep-with-next
    279          INT16U usb_GetTxWord(INT8U *_pByteNum)
    280          {
   \                     usb_GetTxWord: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    281            if (g_tUsbFifo.usTxRead == g_tUsbFifo.usTxWrite)
   \   00000002   0x....             LDR.N    R2,??DataTable10_8
   \   00000004   0xF102 0x038C      ADD      R3,R2,#+140
   \   00000008   0x885C             LDRH     R4,[R3, #+2]
   \   0000000A   0x881D             LDRH     R5,[R3, #+0]
   \   0000000C   0x42A5             CMP      R5,R4
   \   0000000E   0xD104             BNE.N    ??usb_GetTxWord_0
    282            {
    283              *_pByteNum = 0;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x7001             STRB     R1,[R0, #+0]
    284              return 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBC70             POP      {R4-R6}
   \   00000018   0x4770             BX       LR
    285            }
    286          	
    287            usData = g_tUsbFifo.aTxBuf[g_tUsbFifo.usTxRead];
   \                     ??usb_GetTxWord_0: (+1)
   \   0000001A   0x5CAE             LDRB     R6,[R5, R2]
   \   0000001C   0x....             LDR.N    R1,??DataTable10_10
   \   0000001E   0x800E             STRH     R6,[R1, #+0]
    288          	
    289            if (++g_tUsbFifo.usTxRead >= USB_TX_BUF_SIZE)
   \   00000020   0x1C6D             ADDS     R5,R5,#+1
   \   00000022   0x801D             STRH     R5,[R3, #+0]
   \   00000024   0xB2AD             UXTH     R5,R5
   \   00000026   0x2D78             CMP      R5,#+120
   \   00000028   0xBFA4             ITT      GE 
   \   0000002A   0x2500             MOVGE    R5,#+0
   \   0000002C   0x801D             STRHGE   R5,[R3, #+0]
    290            {
    291              g_tUsbFifo.usTxRead = 0;
    292            }
    293          	
    294            if (g_tUsbFifo.usTxRead == g_tUsbFifo.usTxWrite)
   \   0000002E   0x881D             LDRH     R5,[R3, #+0]
   \   00000030   0x42A5             CMP      R5,R4
   \   00000032   0xBF08             IT       EQ 
   \   00000034   0x2201             MOVEQ    R2,#+1
    295            {
    296              *_pByteNum = 1;		
   \   00000036   0xD00B             BEQ.N    ??usb_GetTxWord_1
    297              return usData;
    298            }	
    299          	
    300            usData += g_tUsbFifo.aTxBuf[g_tUsbFifo.usTxRead] << 8;
   \   00000038   0x5CAA             LDRB     R2,[R5, R2]
   \   0000003A   0xEB06 0x2202      ADD      R2,R6,R2, LSL #+8
   \   0000003E   0x800A             STRH     R2,[R1, #+0]
    301          
    302            if (++g_tUsbFifo.usTxRead >= USB_TX_BUF_SIZE)
   \   00000040   0x1C6A             ADDS     R2,R5,#+1
   \   00000042   0x801A             STRH     R2,[R3, #+0]
   \   00000044   0xB292             UXTH     R2,R2
   \   00000046   0x2A78             CMP      R2,#+120
   \   00000048   0xBFA4             ITT      GE 
   \   0000004A   0x2200             MOVGE    R2,#+0
   \   0000004C   0x801A             STRHGE   R2,[R3, #+0]
    303            {
    304              g_tUsbFifo.usTxRead = 0;
    305            }
    306          
    307            *_pByteNum = 2;	
   \   0000004E   0x2202             MOVS     R2,#+2
   \                     ??usb_GetTxWord_1: (+1)
   \   00000050   0x7002             STRB     R2,[R0, #+0]
    308            return usData;		
   \   00000052   0xBC70             POP      {R4-R6}
   \   00000054   0x8808             LDRH     R0,[R1, #+0]
   \   00000056   0x4770             BX       LR               ;; return
    309          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     g_tUsbFifo+0x8C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     bDeviceState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     Device_Info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x1FFFF7E8         DC32     0x1ffff7e8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     idx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x........         DC32     i

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x........         DC32     g_tUsbFifo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x........         DC32     ucData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x........         DC32     usData
    310          
    311          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   Get_SerialNum
       8   IntToUnicode
       8   Set_USBClock
         0   -> RCC_APB1PeriphClockCmd
         8   -> RCC_USBCLKConfig
      16   Set_USBSystem
        16   -> BSP_IntEn
        16   -> BSP_IntPrioSet
        16   -> BSP_IntVectSet
        16   -> GPIO_Init
        16   -> GPIO_WriteBit
        16   -> RCC_APB1PeriphClockCmd
        16   -> RCC_APB2PeriphClockCmd
        16   -> RCC_APB2PeriphResetCmd
        16   -> RCC_USBCLKConfig
        16   -> USB_Init
       8   USB_Interrupts_Config
         0   -> BSP_IntEn
         8   -> BSP_IntPrioSet
         8   -> BSP_IntVectSet
       8   USB_LP_CAN1_RX0_IRQHandler
         0   -> OSIntExit
         8   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
         8   -> usb_Istr
       0   usb_CableConfig
         0   -> GPIO_ResetBits
         0   -> GPIO_SetBits
       0   usb_EnterLowPowerMode
       0   usb_GetRxByte
      12   usb_GetTxWord
       0   usb_LeaveLowPowerMode
       8   usb_SaveHostDataToBuf
       8   usb_SendBuf
         8   -> GetEPTxStatus
         8   -> SetEPTxCount
         8   -> SetEPTxValid
         8   -> UserToPMABufferCopy
       8   usb_SendDataToHost


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
     118  Get_SerialNum
      52  IntToUnicode
      22  Set_USBClock
     156  Set_USBSystem
      30  USB_Interrupts_Config
      30  USB_LP_CAN1_RX0_IRQHandler
     152  g_tUsbFifo
      16  idx
          Device_Serial0
          Device_Serial1
          Device_Serial2
       4  ucData
          usRxWrite
       2  usData
      20  usb_CableConfig
       8  usb_EnterLowPowerMode
      52  usb_GetRxByte
      88  usb_GetTxWord
      18  usb_LeaveLowPowerMode
      66  usb_SaveHostDataToBuf
      38  usb_SendBuf
      62  usb_SendDataToHost

 
 174 bytes in section .bss
 804 bytes in section .text
 
 804 bytes of CODE memory
 174 bytes of DATA memory

Errors: none
Warnings: none
