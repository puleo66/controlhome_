###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       09/Feb/2018  16:15:06
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\HW Projects\ControlHome\CntrHome -
#        RF69w\uC-FatFS\device\Mmc\sdcmd.c
#    Command line =  
#        "E:\HW Projects\ControlHome\CntrHome -
#        RF69w\uC-FatFS\device\Mmc\sdcmd.c" -lCN "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Debug\List" -o "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Debug\Obj" --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\APP\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\BSP\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\CPU\inc\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-CPU\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-RTC\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-LIB\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uCOS-II\Ports\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uCOS-II\Source\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\I2C-Out\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Direct_Sw\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Wdt_led\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-LCD\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-RF\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\api\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\config\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\os\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\fsl\fat\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\clib\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\lbl\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\device\mmc\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\file\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-Terminal\src\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-Terminal\inc\" -Oh
#    List file    =  
#        E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\List\sdcmd.lst
#    Object file  =  
#        E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\Obj\sdcmd.o
#
###############################################################################

E:\HW Projects\ControlHome\CntrHome - RF69w\uC-FatFS\device\Mmc\sdcmd.c
      1          /****************************************Copyright (c)**************************************************
      2          **                               Hangzhou yh software  Co.,LTD.
      3          **                                     
      4          **                                 http://www.armgcc.com
      5          **
      6          **--------------File Info-------------------------------------------------------------------------------
      7          ** File name:			sdcmd.c
      8          ** Last modified Date:	2007-10-15
      9          ** Last Version:		V1.0
     10          ** Descriptions:		SD/MMC 读写模块: 物理层 ---- SD/MMC卡SPI模式支持的命令 						
     11          **------------------------------------------------------------------------------------------------------
     12          ** Created by:			lhlzjut@hotmail.com
     13          ** Created date:		2007-10-15
     14          ** Version:				V1.0
     15          ** Descriptions:		The original version
     16          **
     17          **------------------------------------------------------------------------------------------------------
     18          ********************************************************************************************************/
     19          #include <stdio.h>
     20          //#include "sdhal.h"
     21          #include "sdcrc.h"
     22          #include "sdcmd.h"
     23          #include "sddriver.h"
     24          
     25          #if SD_UCOSII_EN    
     26          #include  "ucos_ii.h"
     27          #endif
     28          
     29          
     30          /********************************************************************************************************************
     31          ** Name:	  INT8U SD_SendCmd()
     32          ** Function:      send command to the card,and get a response
     33          ** Input:	  INT8U cmd	    : command byte	
     34          ** 	          INT8U *param	: command parameter,length is 4 bytes  
     35          **	          INT8U resptype: response type
     36          **	          INT8U *resp	: response,length is 1-5 bytes
     37          ** Output:	  0:  right		>0:  error code
     38          ********************************************************************************************************************/

   \                                 In section .text, align 4, keep-with-next
     39          INT8U SD_SendCmd(INT8U cmd, INT8U *param, INT8U resptype, INT8U *resp)
     40          {
   \                     SD_SendCmd: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4617             MOV      R7,R2
   \   00000008   0x461C             MOV      R4,R3
     41          	CPU_INT32S i,rlen;
     42          	INT8U tmp;
     43              
     44          	MSD_CS_Assert();
   \   0000000A   0x.... 0x....      BL       MSD_CS_Assert
     45             
     46              SPI2_SendByte((cmd & 0x3F) | 0x40);				 /*  send command header and word */
   \   0000000E   0xF005 0x003F      AND      R0,R5,#0x3F
   \   00000012   0xF040 0x0540      ORR      R5,R0,#0x40
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       SPI2_SendByte
     47              
     48              for (i = 3; i >= 0; i--)
     49                  SPI2_SendByte(param[i]);					 /*  send parameters */
   \   0000001C   0x78F0             LDRB     R0,[R6, #+3]
   \   0000001E   0x.... 0x....      BL       SPI2_SendByte
   \   00000022   0x78B0             LDRB     R0,[R6, #+2]
   \   00000024   0x.... 0x....      BL       SPI2_SendByte
   \   00000028   0x7870             LDRB     R0,[R6, #+1]
   \   0000002A   0x.... 0x....      BL       SPI2_SendByte
   \   0000002E   0x7830             LDRB     R0,[R6, #+0]
   \   00000030   0x.... 0x....      BL       SPI2_SendByte
     50          
     51          #if SD_CRC_EN
     52          	tmp = SD_GetCmdByte6((cmd & 0x3F) | 0x40, param);
   \   00000034   0x4631             MOV      R1,R6
   \   00000036   0x4628             MOV      R0,R5
   \   00000038   0x.... 0x....      BL       SD_GetCmdByte6
     53          	SPI2_SendByte(tmp);
   \   0000003C   0x.... 0x....      BL       SPI2_SendByte
     54          #else
     55              SPI2_SendByte(0x95);					        /*  CRC,only used for the first command */
     56          #endif 
     57              
     58              rlen = 0;
     59              switch (resptype)								 
   \   00000040   0x1E7F             SUBS     R7,R7,#+1
   \   00000042   0x2F03             CMP      R7,#+3
   \   00000044   0xD816             BHI.N    ??SD_SendCmd_1
   \   00000046   0xE8DF 0xF007      TBB      [PC, R7]
   \                     ??SD_SendCmd_0:
   \   0000004A   0x02 0x02          DC8      0x2,0x2,0x11,0x13
   \              0x11 0x13    
     60              {								/* according various command,get the various response length */
     61            		case R1:  rlen = 1;  break;
     62             	 	case R1B: rlen = 1;  break;
   \                     ??SD_SendCmd_2: (+1)
   \   0000004E   0x2501             MOVS     R5,#+1
     63                 		 
     64              	case R2:  rlen = 2;	 break;
     65                 		 
     66             		case R3:  rlen = 5;	 break;
     67                 		 
     68              	default:  
     69          			 SPI2_SendByte(0xFF);	
     70                		 MSD_CS_Deassert();						 
     71                  	 return SD_ERR_CMD_RESPTYPE;		        /*  return error of command response type */
     72              }
     73              i = 0;				
   \                     ??SD_SendCmd_3: (+1)
   \   00000050   0x2600             MOVS     R6,#+0
     74              do 												 
     75              {								/* Wait for a response,a response is a start bit(zero) */ 
     76                  tmp = SPI2_RecByte();
   \                     ??SD_SendCmd_4: (+1)
   \   00000052   0x.... 0x....      BL       SPI2_RecByte
     77                  i++;
   \   00000056   0x1C76             ADDS     R6,R6,#+1
     78              }while (((tmp & 0x80) != 0) && (i < SD_CMD_TIMEOUT));
   \   00000058   0x0601             LSLS     R1,R0,#+24
   \   0000005A   0xD501             BPL.N    ??SD_SendCmd_5
   \   0000005C   0x2E64             CMP      R6,#+100
   \   0000005E   0xDBF8             BLT.N    ??SD_SendCmd_4
     79              
     80              if (i >= SD_CMD_TIMEOUT)
   \                     ??SD_SendCmd_5: (+1)
   \   00000060   0x2E64             CMP      R6,#+100
   \   00000062   0xDB0E             BLT.N    ??SD_SendCmd_6
     81              {												 
     82                  MSD_CS_Deassert();
   \   00000064   0x.... 0x....      BL       MSD_CS_Deassert
     83                  return SD_ERR_CMD_TIMEOUT;				/* return response timeout of command */
   \   00000068   0x2011             MOVS     R0,#+17
   \   0000006A   0xBDF2             POP      {R1,R4-R7,PC}
     84              }
   \                     ??SD_SendCmd_7: (+1)
   \   0000006C   0x2502             MOVS     R5,#+2
   \   0000006E   0xE7EF             B.N      ??SD_SendCmd_3
   \                     ??SD_SendCmd_8: (+1)
   \   00000070   0x2505             MOVS     R5,#+5
   \   00000072   0xE7ED             B.N      ??SD_SendCmd_3
   \                     ??SD_SendCmd_1: (+1)
   \   00000074   0x20FF             MOVS     R0,#+255
   \   00000076   0x.... 0x....      BL       SPI2_SendByte
   \   0000007A   0x.... 0x....      BL       MSD_CS_Deassert
   \   0000007E   0x2010             MOVS     R0,#+16
   \   00000080   0xBDF2             POP      {R1,R4-R7,PC}
     85              
     86              for (i = rlen - 1; i >= 0; i--)
   \                     ??SD_SendCmd_6: (+1)
   \   00000082   0x1E6E             SUBS     R6,R5,#+1
   \   00000084   0xD406             BMI.N    ??SD_SendCmd_9
   \   00000086   0x1934             ADDS     R4,R6,R4
     87              {
     88                  resp[i] = tmp;
   \                     ??SD_SendCmd_10: (+1)
   \   00000088   0xF804 0x0901      STRB     R0,[R4], #-1
     89                  tmp = SPI2_RecByte();					/* clock  at the last recycle,clock out 8 clock */
   \   0000008C   0x.... 0x....      BL       SPI2_RecByte
     90              }
   \   00000090   0x1E76             SUBS     R6,R6,#+1
   \   00000092   0xD5F9             BPL.N    ??SD_SendCmd_10
     91                
     92              MSD_CS_Deassert();
   \                     ??SD_SendCmd_9: (+1)
   \   00000094   0x....             B.N      ?Subroutine0
     93              return SD_NO_ERR;						/* return perform sucessfully */
     94          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x.... 0x....      BL       MSD_CS_Deassert
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
     95          
     96          /********************************************************************************************************************
     97          ** Name:	  void SD_PackParam()
     98          ** Function:      change 32bit parameter to bytes form 
     99          ** Input:	  INT8U *parameter: the buffer of bytes parameter
    100          **	          INT32U value    : 32bit parameter
    101          ** Output:	  NULL
    102          *********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    103          void SD_PackParam(INT8U *parameter, INT32U value)
    104          {
    105              parameter[3] = (INT8U)(value >> 24);
   \                     SD_PackParam: (+1)
   \   00000000   0x0E0A             LSRS     R2,R1,#+24
   \   00000002   0x70C2             STRB     R2,[R0, #+3]
    106              parameter[2] = (INT8U)(value >> 16);
   \   00000004   0x0C0A             LSRS     R2,R1,#+16
   \   00000006   0x7082             STRB     R2,[R0, #+2]
    107              parameter[1] = (INT8U)(value >> 8);
   \   00000008   0x0A0A             LSRS     R2,R1,#+8
   \   0000000A   0x7042             STRB     R2,[R0, #+1]
    108              parameter[0] = (INT8U)(value);
   \   0000000C   0x7001             STRB     R1,[R0, #+0]
    109          }
   \   0000000E   0x4770             BX       LR               ;; return
    110          
    111          /********************************************************************************************************************
    112          ** Name:	  INT8U SD_BlockCommand()
    113          ** Function:      command about block operation
    114          ** Input:	  INT8U cmd	      : command byte 
    115          **                INT8U resptype  : response type
    116          **	          INT32U parameter: parameter of block operation
    117          ** Output:	  0:  right		>0:  error code
    118          *********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    119          INT8U SD_BlockCommand(INT8U cmd, INT8U resptype, INT32U parameter)
    120          {
   \                     SD_BlockCommand: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    121          	INT8U param[4],resp,ret;
    122          	
    123          	parameter <<= SD_BLOCKSIZE_NBITS;					/* adjust address: move 9 bits left */
    124          
    125          	SD_PackParam(param, parameter);						/* change the parameter to bytes form */	
   \   00000004   0x0252             LSLS     R2,R2,#+9
   \   00000006   0x0E13             LSRS     R3,R2,#+24
   \   00000008   0xF88D 0x3003      STRB     R3,[SP, #+3]
   \   0000000C   0x0C13             LSRS     R3,R2,#+16
   \   0000000E   0x0A12             LSRS     R2,R2,#+8
   \   00000010   0xF88D 0x2001      STRB     R2,[SP, #+1]
   \   00000014   0xF88D 0x3002      STRB     R3,[SP, #+2]
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0xF88D 0x2000      STRB     R2,[SP, #+0]
    126          
    127          	ret = SD_SendCmd(cmd, param, resptype, &resp);
   \   0000001E   0xAB01             ADD      R3,SP,#+4
   \   00000020   0x460A             MOV      R2,R1
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x....             B.N      ?Subroutine1
    128          	if (ret != SD_NO_ERR)
    129          	   	 return ret;							/* stop transmission operation fail */
    130          	
    131          	if (resp != 0) {
    132          		 return SD_ERR_CMD_RESP;		 			/* response is error */
    133          	}
    134          		 
    135          	return SD_NO_ERR;
    136          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x.... 0x....      BL       SD_SendCmd
   \   00000004   0xB918             CBNZ.N   R0,??Subroutine1_0
   \   00000006   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000000A   0xB100             CBZ.N    R0,??Subroutine1_0
   \   0000000C   0x2012             MOVS     R0,#+18
   \                     ??Subroutine1_0: (+1)
   \   0000000E   0xB003             ADD      SP,SP,#+12
   \   00000010   0xBD00             POP      {PC}             ;; return
    137          	
    138          /********************************************************************************************************************
    139          ** Name:	  INT8U SD_ResetSD()
    140          ** Function:      reset SD/MMC card
    141          ** Input:	  NULL
    142          ** Output:	  0:  right		>0:  error code
    143          *********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    144          INT8U SD_ResetSD(void)
    145          {
   \                     SD_ResetSD: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    146          	INT8U param[4] = {0,0,0,0},resp;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x9100             STR      R1,[SP, #+0]
    147          	
    148              return (SD_SendCmd(CMD0, param, CMD0_R, &resp));	/* command that reset card */
   \   00000008   0xAB01             ADD      R3,SP,#+4
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x....             B.N      ?Subroutine2
    149          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x.... 0x....      BL       SD_SendCmd
   \   00000004   0xB003             ADD      SP,SP,#+12
   \   00000006   0xBD00             POP      {PC}             ;; return
    150          
    151          /********************************************************************************************************************
    152          ** Name:	  INT8U SD_ReadCSD()
    153          ** Function: read CSD register of SD/MMC card 
    154          ** INT8U csdlen  : len of register (fixed,is 16)
    155          **	           INT8U *recbuf : recbuffer	
    156          ** Output:	  0:  right		>0:  error code
    157          *********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    158          INT8U SD_ReadCSD(INT8U csdlen, INT8U *recbuf)
    159          {
   \                     SD_ReadCSD: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    160              INT8U param[4] = {0,0,0,0},resp,ret;
   \   00000008   0xA801             ADD      R0,SP,#+4
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    161            	
    162              ret = SD_SendCmd(CMD9, param, CMD9_R, &resp);		/* command that read CSD register */
   \   0000000E   0x466B             MOV      R3,SP
   \   00000010   0x2201             MOVS     R2,#+1
   \   00000012   0xA901             ADD      R1,SP,#+4
   \   00000014   0x2009             MOVS     R0,#+9
   \   00000016   0x.... 0x....      BL       SD_SendCmd
    163              if (ret != SD_NO_ERR) 									
   \   0000001A   0xB940             CBNZ.N   R0,??SD_ReadCSD_0
    164                  return ret;									
    165            	
    166              if (resp != 0)
   \   0000001C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xBF11             ITEEE    NE 
    167                  return SD_ERR_CMD_RESP;					/* response is error */
   \   00000024   0x2012             MOVNE    R0,#+18
    168               
    169          	return (SD_ReadRegister(csdlen, recbuf));
   \   00000026   0x4629             MOVEQ    R1,R5
   \   00000028   0x4620             MOVEQ    R0,R4
   \   0000002A   0x.... 0x....      BLEQ     SD_ReadRegister
   \                     ??SD_ReadCSD_0: (+1)
   \   0000002E   0xB003             ADD      SP,SP,#+12
   \   00000030   0xBD30             POP      {R4,R5,PC}       ;; return
    170          }
    171          
    172          /*******************************************************************************************************************
    173          ** Name:	  INT8U SD_ReadCID()
    174          ** Function: read CID register of sd card
    175          ** INT8U cidlen  : len of register (fixed,is 16)
    176          ** INT8U *recbuf : recbuffer	
    177          ** Output:	  0:  right		>0:  error code
    178          ********************************************************************************************************************/
    179          #if SD_ReadCID_EN
    180          INT8U SD_ReadCID(INT8U cidlen, INT8U *recbuf)
    181          {
    182              INT8U param[4] = {0,0,0,0},resp,ret;
    183           
    184              ret = SD_SendCmd(CMD10, param, CMD10_R, &resp);		/* command that read CID register */
    185              if ( ret != SD_NO_ERR)
    186             		return ret;			  									
    187             
    188              if (resp != 0)
    189                  return SD_ERR_CMD_RESP;					/* response is error */
    190                
    191            	return (SD_ReadRegister(cidlen, recbuf));
    192          }
    193          #endif
    194          
    195          /********************************************************************************************************************
    196          ** Name:	  INT8U SD_StopTransmission()
    197          ** Function: stop data transmission 
    198          ** Input:    NULL
    199          ** Output:	  0:  right		>0:  error code
    200          *********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    201          INT8U SD_StopTransmission(void)
    202          {
   \                     SD_StopTransmission: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    203          	INT8U param[4] = {0,0,0,0},resp;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x9100             STR      R1,[SP, #+0]
    204          	
    205           	return (SD_SendCmd(CMD12, param, CMD12_R, &resp));	/* stop transmission command fail */
   \   00000008   0xAB01             ADD      R3,SP,#+4
   \   0000000A   0x2202             MOVS     R2,#+2
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0x200C             MOVS     R0,#+12
   \   00000010                      REQUIRE ?Subroutine2
   \   00000010                      ;; // Fall through to label ?Subroutine2
    206          }
    207          
    208          /*********************************************************************************************************************
    209          ** Name:	  INT8U SD_ReadCard_Status()
    210          ** Function: read Card Status register of SD/MMC card 
    211          ** INT8U len:      len of register (fixed,is 2)
    212          ** INT8U *recbuf : recbuffer
    213          ** Output:	  0:  right		>0:  error code
    214          **********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    215          INT8U SD_ReadCard_Status(INT8U len, INT8U *buffer)
    216          {
   \                     SD_ReadCard_Status: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    217              INT8U param[4] = {0,0,0,0};
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x9200             STR      R2,[SP, #+0]
    218          
    219              return (SD_SendCmd(CMD13, param, CMD13_R, buffer)); 	/* read register of Card Status */
   \   00000006   0x460B             MOV      R3,R1
   \   00000008   0x2203             MOVS     R2,#+3
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x200D             MOVS     R0,#+13
   \   0000000E   0x.... 0x....      BL       SD_SendCmd
   \   00000012   0xBD02             POP      {R1,PC}          ;; return
    220          }
    221          
    222          
    223          /********************************************************************************************************************
    224          ** Name:	  INT8U SD_SetBlockLen()
    225          ** Function:      set a block len of card 
    226          ** Input:	  INT32U length	: the length of a block
    227          ** Output:	  0:  right		>0:  error code
    228          *********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    229          INT8U SD_SetBlockLen(INT32U length)
    230          {
   \                     SD_SetBlockLen: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    231          	INT8U param[4],resp,ret;
    232            
    233              SD_PackParam(param, length);					/* change the parameter to bytes form */
   \   00000004   0x0E01             LSRS     R1,R0,#+24
   \   00000006   0xF88D 0x1003      STRB     R1,[SP, #+3]
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000000E   0x0C01             LSRS     R1,R0,#+16
   \   00000010   0xF88D 0x1002      STRB     R1,[SP, #+2]
    234                    												
    235              ret = SD_SendCmd(CMD16, param, CMD16_R, &resp);
   \   00000014   0xAB01             ADD      R3,SP,#+4
   \   00000016   0x0A01             LSRS     R1,R0,#+8
   \   00000018   0xF88D 0x1001      STRB     R1,[SP, #+1]
   \   0000001C   0x2201             MOVS     R2,#+1
   \   0000001E   0x4669             MOV      R1,SP
   \   00000020   0x2010             MOVS     R0,#+16
   \   00000022                      REQUIRE ?Subroutine1
   \   00000022                      ;; // Fall through to label ?Subroutine1
    236              if (ret != SD_NO_ERR)
    237           		return ret;						/* set the length of block to length fail */
    238          	
    239          	if (resp != 0)
    240              	return SD_ERR_CMD_RESP;			   			/* response is error */
    241              
    242              return SD_NO_ERR; 							/* return perform sucessfully */			
    243          }
    244          
    245          /********************************************************************************************************************
    246          ** Name:	  INT8U SD_ReadSingleBlock()
    247          ** Function: read single block command
    248          ** Input:	  INT32U blockaddr: block address
    249          ** Output:	  0:  right	>0:  error code
    250          *********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    251          INT8U SD_ReadSingleBlock(INT32U blockaddr)
    252          {
    253          	return (SD_BlockCommand(CMD17, CMD17_R, blockaddr));           /* command that read single block */
   \                     SD_ReadSingleBlock: (+1)
   \   00000000   0x4602             MOV      R2,R0
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2011             MOVS     R0,#+17
   \   00000006   0x....             B.N      SD_BlockCommand
    254          }
    255          
    256          /********************************************************************************************************************
    257          ** Name:	  INT8U SD_ReadMultipleBlock()
    258          ** Function:      read multiple block command 
    259          ** Input:	  INT32U blockaddr: block address
    260          ** Output:	  0:  right		>0:  error code
    261          *********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    262          INT8U SD_ReadMultipleBlock(INT32U blockaddr)
    263          {
    264          	return (SD_BlockCommand(CMD18, CMD18_R, blockaddr));          /* command that read multiple block */
   \                     SD_ReadMultipleBlock: (+1)
   \   00000000   0x4602             MOV      R2,R0
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2012             MOVS     R0,#+18
   \   00000006   0x....             B.N      SD_BlockCommand
    265          }
    266          
    267          /********************************************************************************************************************
    268          ** Name:	  INT8U SD_WriteSingleBlock()
    269          ** Function:      write single block command
    270          ** Input:	  INT32U blockaddr: block address
    271          ** Output:	  0:  right		>0:  error code
    272          *********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    273          INT8U SD_WriteSingleBlock(INT32U blockaddr)
    274          {
   \                     SD_WriteSingleBlock: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    275          	return (SD_BlockCommand(CMD24, CMD24_R, blockaddr)); /* command that write single block */
   \   00000004   0x0240             LSLS     R0,R0,#+9
   \   00000006   0x0E01             LSRS     R1,R0,#+24
   \   00000008   0xF88D 0x1003      STRB     R1,[SP, #+3]
   \   0000000C   0xAB01             ADD      R3,SP,#+4
   \   0000000E   0x0C01             LSRS     R1,R0,#+16
   \   00000010   0x0A00             LSRS     R0,R0,#+8
   \   00000012   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   00000016   0xF88D 0x1002      STRB     R1,[SP, #+2]
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x2018             MOVS     R0,#+24
   \   00000026   0x....             B.N      ?Subroutine1
    276          }
    277          
    278          /********************************************************************************************************************
    279          ** Name:	  INT8U SD_WriteMultipleBlock()
    280          ** Function:      write multiple block command
    281          ** Input:	  INT32U blockaddr: block address
    282          ** Output:	  0:  right	>0:  error code
    283          *********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    284          INT8U SD_WriteMultipleBlock(INT32U blockaddr)
    285          {
   \                     SD_WriteMultipleBlock: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    286          	return (SD_BlockCommand(CMD25, CMD25_R, blockaddr)); /* command that write multiple block */
   \   00000004   0x0240             LSLS     R0,R0,#+9
   \   00000006   0x0E01             LSRS     R1,R0,#+24
   \   00000008   0xF88D 0x1003      STRB     R1,[SP, #+3]
   \   0000000C   0xAB01             ADD      R3,SP,#+4
   \   0000000E   0x0C01             LSRS     R1,R0,#+16
   \   00000010   0x0A00             LSRS     R0,R0,#+8
   \   00000012   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   00000016   0xF88D 0x1002      STRB     R1,[SP, #+2]
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x2019             MOVS     R0,#+25
   \   00000026   0x....             B.N      ?Subroutine1
    287          }
    288          
    289          /********************************************************************************************************************
    290          ** Name:	  INT8U SD_ProgramCSD()
    291          ** Function: write CSD register
    292          ** Input:	  INT8U *buff   	  : the content of CSD register	
    293          **                INT8U len		  : the length of CSD register
    294          ** Output:	  0:  right		>0:  error code
    295          ********************************************************************************************************************/
    296          #if SD_ProgramCSD_EN
    297          INT8U SD_ProgramCSD(INT8U len, INT8U *buff)
    298          {
    299          	INT8U param[4] = {0,0,0,0},resp,ret;
    300          	
    301          	if (len != 16) return SD_ERR_USER_PARAM;
    302          
    303          	ret = SD_SendCmd(CMD27, param, CMD27_R, &resp); 	/* send command that write CSD */
    304          	if (ret != SD_NO_ERR)
    305          		return ret;
    306          		        
    307              if (resp != 0)    
    308                  return SD_ERR_CMD_RESP;
    309          		
    310          	buff[15] = (SD_GetCRC7(buff, 15) << 1) + 0x01;  	/* calculate crc field in CSD */
    311          		
    312          	return(SD_WriteBlockData(0, 16, buff));
    313          }
    314          
    315          /********************************************************************************************************************
    316          ** Name:	  INT8U SD_GetCRC7()
    317          ** Function:      calculate crc7
    318          ** Input:         INT8U *pSource: data
    319          **                INT16U len   : data length
    320          ** Output:	  CRC7 code
    321          *********************************************************************************************************************/
    322          INT8U SD_GetCRC7(INT8U *pSource, INT16U len)
    323          {
    324          	INT8U i = 0, j;
    325          	INT8U reg = 0;
    326          	
    327          	do
    328          	{
    329          	    for (j = 0; j < 8; j++)
    330          	    {
    331          			reg <<= 1;
    332          			reg ^= ((((pSource[i] << j) ^ reg) & 0x80) ? 0x9 : 0);
    333          	    }
    334          	    
    335          	    i++;
    336          	    
    337          	}while(i < len);
    338          	
    339          	return reg;
    340          }	
    341          #endif	
    342          
    343          #if SD_EraseBlock_EN
    344          /********************************************************************************************************************
    345          ** Name:	  INT8U SD_EraseStartBlock()
    346          ** Function: select the start block address of erasing operation 
    347          ** Input: 	  INT32U startblock	: block address
    348          ** Output:	  0:  right	   >0:  error code
    349          *********************************************************************************************************************/
    350          INT8U SD_EraseStartBlock(INT32U startblock)
    351          {
    352          	if (sds.card_type == CARDTYPE_SD)
    353          		return (SD_BlockCommand(CMD32, CMD32_R, startblock));	/* send the start block address of erasing operation */
    354          	else
    355          		return (SD_BlockCommand(CMD35, CMD35_R, startblock));	/* send the start block address of erasing operation */
    356          }
    357          
    358          /********************************************************************************************************************
    359          ** Name:	  INT8U SD_EraseEndBlock()
    360          ** Function:      select the end block address of erasing operation  
    361          ** Input:	  INT32U Length	: block address
    362          ** Output:	  0:  right	   >0:  error code
    363          *********************************************************************************************************************/
    364          INT8U SD_EraseEndBlock(INT32U endblock)
    365          {
    366          	if (sds.card_type == CARDTYPE_SD)
    367          		return (SD_BlockCommand(CMD33, CMD33_R, endblock));     /* send the end block address of erasing operation */
    368          	else
    369          		return (SD_BlockCommand(CMD36, CMD36_R, endblock));     /* send the end block address of erasing operation */
    370          }
    371          
    372          /********************************************************************************************************************
    373          ** Name:	  INT8U SD_EraseSelectedBlock()
    374          ** Function:      erase block selected
    375          ** Input:	  NULL
    376          ** Output:	  0:  right		>0:  error code
    377          *********************************************************************************************************************/
    378          INT8U SD_EraseSelectedBlock(void)
    379          {
    380          	INT8U param[4],resp,tmp;
    381          	
    382          	SD_PackParam(param, 0);
    383          	
    384          	tmp = SD_SendCmd(CMD38, param, CMD38_R, &resp);	 	    /* erase blocks selected */
    385          	if (tmp != SD_NO_ERR)
    386          		return tmp;							 	
    387          	
    388          	if (SD_WaitBusy(SD_WAIT_ERASE) != SD_NO_ERR)		    /* wait for finishing erasing */
    389          		return SD_ERR_TIMEOUT_ERASE;
    390          	else
    391          		return SD_NO_ERR;									
    392          }	
    393          #endif
    394          
    395          /*********************************************************************************************************************
    396          ** Name:	  INT8U SD_ReadOCR()
    397          ** Function: read OCR register of card
    398          ** Input:	  INT8U ocrlen  : len of register (fixed,is 4)
    399          **                INT8U *recbuf : recbuffer	
    400          ** Output:	  0:  right		>0:  error code
    401          **********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    402          INT8U SD_ReadOCR(INT8U ocrlen, INT8U *recbuf)
    403          {
   \                     SD_ReadOCR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x460C             MOV      R4,R1
    404              INT8U param[4] = {0,0,0,0},resp[5],tmp;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x9100             STR      R1,[SP, #+0]
    405          
    406              tmp = SD_SendCmd(CMD58, param, CMD58_R, resp);		
   \   0000000A   0xAB01             ADD      R3,SP,#+4
   \   0000000C   0x2204             MOVS     R2,#+4
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0x203A             MOVS     R0,#+58
   \   00000012   0x.... 0x....      BL       SD_SendCmd
    407              if (tmp != SD_NO_ERR)						/* read OCR register command */
   \   00000016   0xB978             CBNZ.N   R0,??SD_ReadOCR_0
    408              	return tmp;		 										
    409              												
    410              if (resp[0] != 0)
   \   00000018   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   0000001C   0xB971             CBNZ.N   R1,??SD_ReadOCR_1
   \   0000001E   0x2804             CMP      R0,#+4
   \   00000020   0xDA09             BGE.N    ??SD_ReadOCR_2
   \   00000022   0xF10D 0x0105      ADD      R1,SP,#+5
   \   00000026   0xF1C0 0x0004      RSB      R0,R0,#+4
    411                  return SD_ERR_CMD_RESP;			 			/* response is error */
    412              
    413              for (tmp = 0; tmp < 4; tmp++)
    414              	recbuf[tmp] = resp[tmp + 1];				
   \                     ??SD_ReadOCR_3: (+1)
   \   0000002A   0xF811 0x2B01      LDRB     R2,[R1], #+1
   \   0000002E   0xF804 0x2B01      STRB     R2,[R4], #+1
   \   00000032   0x1E40             SUBS     R0,R0,#+1
   \   00000034   0xD1F9             BNE.N    ??SD_ReadOCR_3
    415              
    416              return SD_NO_ERR;
   \                     ??SD_ReadOCR_2: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \                     ??SD_ReadOCR_0: (+1)
   \   00000038   0xB004             ADD      SP,SP,#+16
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
   \                     ??SD_ReadOCR_1: (+1)
   \   0000003C   0x2012             MOVS     R0,#+18
   \   0000003E   0xB004             ADD      SP,SP,#+16
   \   00000040   0xBD10             POP      {R4,PC}
    417          }
    418          
    419          /********************************************************************************************************************
    420          ** Name:	  INT8U SD_EnableCRC()
    421          ** Function:      enable crc check of SD Card 
    422          ** Input:	  INT8U bEnable : 1:enable  0: disable
    423          ** Output:	  0:  right		>0:  error code
    424          *********************************************************************************************************************/
    425          #if SD_CRC_EN

   \                                 In section .text, align 2, keep-with-next
    426          INT8U SD_EnableCRC(INT8U bEnable)
    427          {
   \                     SD_EnableCRC: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    428          	INT8U param[4],resp,ret;
    429          		
    430          	if (bEnable == 1)
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xBF0E             ITEE     EQ 
   \   00000008   0xF88D 0x0000      STRBEQ   R0,[SP, #+0]
   \   0000000C   0x2000             MOVNE    R0,#+0
   \   0000000E   0xF88D 0x0001      STRBNE   R0,[SP, #+1]
    431          		param[0] = 1;						/* enable crc */
    432          	else
    433          		param[1] = 0; 						/* disalbe crc */
    434          
    435          	ret = SD_SendCmd(CMD59, param, CMD59_R, &resp);			/* enable/disable crc command */
   \   00000012   0xAB01             ADD      R3,SP,#+4
   \   00000014   0x2201             MOVS     R2,#+1
   \   00000016   0x4669             MOV      R1,SP
   \   00000018   0x203B             MOVS     R0,#+59
   \   0000001A   0x....             B.N      ?Subroutine1
    436          	if (ret != SD_NO_ERR)
    437                  return ret;							 
    438              
    439              if (resp != 0)    
    440                 	return SD_ERR_CMD_RESP;						/* response is error */		
    441           	
    442          	return SD_NO_ERR;
    443          
    444          }
    445          #endif
    446          
    447          /*********************************************************************************************************************
    448          ** Name:	   INT8U SD_ReadSD_Status()
    449          ** Function: read SD_Status register of sd card 
    450          ** Input:    INT8U sdslen: len of register (fixed,is 64)
    451          **           INT8U *recbuf: recbuffer	
    452          ** Output:	  0:  right		>0:  error code
    453          ** Note:     only SD card have SD Status Register
    454          **********************************************************************************************************************/
    455          #if SD_ReadSD_Status_EN
    456          INT8U SD_ReadSD_Status(INT8U sdslen, INT8U *recbuf)
    457          {
    458              INT8U param[4] = {0,0,0,0},resp[2],ret;
    459              
    460              ret = SD_SendCmd(CMD55, param, CMD55_R, resp);			
    461              if (ret != SD_NO_ERR)
    462              	return ret;						/* command that the followed commnad is a specific application */
    463              												 
    464              if (resp[0] != 0)
    465                  return SD_ERR_CMD_RESP;					/* response is error */
    466              
    467              ret = SD_SendCmd(ACMD13, param, ACMD13_R, resp);		
    468              if (ret != SD_NO_ERR)
    469              	return ret;						/* command that read SD_Status register */
    470             												
    471              if ((resp[0] != 0) || (resp[1] != 0))
    472                  return SD_ERR_CMD_RESP;					/* response is error */
    473                  
    474          	return (SD_ReadBlockData(sdslen, recbuf));		/* read the content of the register */
    475          }
    476          #endif
    477          
    478          /*******************************************************************************************************************
    479          ** Name:	  INT8U SD_ReadSCR()
    480          ** Function:      read SCR register of SD card 
    481          ** Input:         INT8U scrlen		 : len of register (fixed,is 8)
    482          **                INT8U *recbuf		 : recieve buffer	
    483          ** Output:	  0:  right		>0:  error code
    484          ** Note:	  MMC Card have not this register
    485          ********************************************************************************************************************/
    486          #if SD_ReadSCR_EN
    487          INT8U SD_ReadSCR(INT8U scrlen, INT8U *recbuf)
    488          {
    489              INT8U param[4] = {0,0,0,0},resp,ret;
    490              
    491              ret = SD_SendCmd(CMD55, param, CMD55_R, &resp);		
    492              if (ret != SD_NO_ERR)					/* command that the followed commnad is a specific application */
    493              	return ret;													
    494              												 
    495              if (resp != 0)
    496                  return SD_ERR_CMD_RESP;					/* response is error */
    497              
    498              ret = SD_SendCmd(ACMD51, param, ACMD51_R, &resp);           /* SD Status 命令*/
    499              if (ret != SD_NO_ERR)					/* command that read SD Status register */
    500             		return ret;													
    501          				    															
    502              if (resp != 0)
    503                  return SD_ERR_CMD_RESP;					/* response is error */
    504                  
    505          	return (SD_ReadBlockData(scrlen, recbuf));	 	/* read the content of the register */
    506          }
    507          #endif
    508          
    509          /********************************************************************************************************************
    510          ** Name:	  INT8U SD_GetNumWRBlcoks()
    511          ** Function:      get the block numbers that written correctly
    512          ** Input:	  INT32U blocknum	: the block numbers returned
    513          ** Output:	  0:  right		>0:  error code
    514          ** Note:          MMC Card have no this command
    515          *********************************************************************************************************************/
    516          #if SD_WriteMultiBlock_EN
    517          INT8U SD_GetNumWRBlcoks(INT32U *blocknum)
    518          {
    519              INT8U tmp[4] = {0,0,0,0},resp,ret;
    520            
    521              ret = SD_SendCmd(CMD55, tmp, CMD55_R, &resp);	  	 
    522              if (ret != SD_NO_ERR) 					/* command that the followed commnad is a specific application */
    523              	return ret;
    524              	 
    525              if (resp != 0)
    526              	return SD_ERR_CMD_RESP;    	
    527           											
    528             	ret = SD_SendCmd(ACMD22, tmp, ACMD22_R, &resp);  	 
    529             	if (ret != SD_NO_ERR)					/* command that read the numbers of block written correctly */
    530             		return ret;											    
    531             		 														
    532          	if (resp != 0)
    533              	return SD_ERR_CMD_RESP;					/* response is error */
    534              		
    535              ret = SD_ReadBlockData(4, tmp);				/* read the numbvers of block */
    536              if (ret != SD_NO_ERR)
    537              	return ret;
    538              	
    539              *blocknum = (tmp[0] << 24) + (tmp[1] << 16) + (tmp[2] << 8) + tmp[3];	
    540              								/* change to 32 bits */
    541          
    542          	return SD_NO_ERR;    					/* return perform sucessfully */		
    543          }
    544          #endif
    545          
    546          		
    547          /********************************************************************************************************************
    548          ** Name:	  INT8U SD_ReadRegister()
    549          ** Function: read data from SD card
    550          ** Input:	  INT32U len   : length
    551          **      	  INT8U *recbuf: receive buffer
    552          ** Output:	  0:  right		>0:  error code
    553          *********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    554          INT8U SD_ReadRegister(INT32U len, INT8U *recbuf)
    555          {	
   \                     SD_ReadRegister: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    556          	INT32U i = 0;
    557          	INT8U resp;
    558          
    559              MSD_CS_Assert();
   \   00000006   0x.... 0x....      BL       MSD_CS_Assert
    560              do{    								/* wait for data start token */
    561                  resp = SPI2_RecByte();
   \   0000000A   0x.... 0x....      BL       SPI2_RecByte
    562              	i++;
    563              }while((resp == 0xFF) && (i < SD_READREG_TIMEOUT));    
   \   0000000E   0x28FF             CMP      R0,#+255
   \   00000010   0xD11D             BNE.N    ??SD_ReadRegister_0
   \   00000012   0x.... 0x....      BL       SPI2_RecByte
   \   00000016   0x28FF             CMP      R0,#+255
   \   00000018   0xD119             BNE.N    ??SD_ReadRegister_0
   \   0000001A   0x.... 0x....      BL       SPI2_RecByte
   \   0000001E   0x28FF             CMP      R0,#+255
   \   00000020   0xD115             BNE.N    ??SD_ReadRegister_0
   \   00000022   0x.... 0x....      BL       SPI2_RecByte
   \   00000026   0x28FF             CMP      R0,#+255
   \   00000028   0xD111             BNE.N    ??SD_ReadRegister_0
   \   0000002A   0x.... 0x....      BL       SPI2_RecByte
   \   0000002E   0x28FF             CMP      R0,#+255
   \   00000030   0xD10D             BNE.N    ??SD_ReadRegister_0
   \   00000032   0x.... 0x....      BL       SPI2_RecByte
   \   00000036   0x28FF             CMP      R0,#+255
   \   00000038   0xD109             BNE.N    ??SD_ReadRegister_0
   \   0000003A   0x.... 0x....      BL       SPI2_RecByte
   \   0000003E   0x28FF             CMP      R0,#+255
   \   00000040   0xD105             BNE.N    ??SD_ReadRegister_0
   \   00000042   0x.... 0x....      BL       SPI2_RecByte
    564              
    565              if (i >= SD_READREG_TIMEOUT)
    566              {
    567              	MSD_CS_Deassert();
   \   00000046   0x.... 0x....      BL       MSD_CS_Deassert
    568              	return SD_ERR_TIMEOUT_READ;					/* timeout, return error */
   \   0000004A   0x2031             MOVS     R0,#+49
   \   0000004C   0xBD70             POP      {R4-R6,PC}
    569            	}
    570            	
    571             	if (resp != SD_TOK_READ_STARTBLOCK)				
   \                     ??SD_ReadRegister_0: (+1)
   \   0000004E   0x28FE             CMP      R0,#+254
   \   00000050   0xBF0E             ITEE     EQ 
   \   00000052   0x2600             MOVEQ    R6,#+0
   \   00000054   0x7028             STRBNE   R0,[R5, #+0]
   \   00000056   0x2601             MOVNE    R6,#+1
    572             	{								/* not receive data start token */
    573          		recbuf[0] = resp;							
    574          		i = 1;							/* still len - 1 bytes will be received */
    575             	}
    576             	else
    577             		i = 0;							/* received data start token,still len bytes will be received */
   \   00000058   0xE003             B.N      ??SD_ReadRegister_1
    578             	  	
    579              for (; i < len; i++)
    580             		recbuf[i] = SPI2_RecByte();				/* receive data */
   \                     ??SD_ReadRegister_2: (+1)
   \   0000005A   0x.... 0x....      BL       SPI2_RecByte
   \   0000005E   0x5570             STRB     R0,[R6, R5]
   \   00000060   0x1C76             ADDS     R6,R6,#+1
   \                     ??SD_ReadRegister_1: (+1)
   \   00000062   0x42A6             CMP      R6,R4
   \   00000064   0xD3F9             BCC.N    ??SD_ReadRegister_2
    581             		
    582              i = SPI2_RecByte();								
   \   00000066   0x.... 0x....      BL       SPI2_RecByte
   \   0000006A   0x4606             MOV      R6,R0
    583              i = (i << 8) + SPI2_RecByte();    				        /* get 16-bit CRC */	
   \   0000006C   0x.... 0x....      BL       SPI2_RecByte
    584          
    585          #if SD_CRC_EN 
    586             	if (i != SD_GetCRC16(recbuf, len))
   \   00000070   0xEB00 0x2606      ADD      R6,R0,R6, LSL #+8
   \   00000074   0xB2A1             UXTH     R1,R4
   \   00000076   0x4628             MOV      R0,R5
   \   00000078   0x.... 0x....      BL       SD_GetCRC16
   \   0000007C   0x4286             CMP      R6,R0
   \   0000007E   0xD006             BEQ.N    ??SD_ReadRegister_3
    587             	{								/* CRC check is error */
    588             		SPI2_SendByte(0xFF);
   \   00000080   0x20FF             MOVS     R0,#+255
   \   00000082   0x.... 0x....      BL       SPI2_SendByte
    589             		MSD_CS_Deassert();		
   \   00000086   0x.... 0x....      BL       MSD_CS_Deassert
    590            		return SD_ERR_DATA_CRC16;				/* return error of CRC16 */				
   \   0000008A   0x2020             MOVS     R0,#+32
   \   0000008C   0xBD70             POP      {R4-R6,PC}
    591            	}    
    592          #endif   
    593            
    594              SPI2_SendByte(0xFF);							/* clock out 8 clk before return */
   \                     ??SD_ReadRegister_3: (+1)
   \   0000008E   0x20FF             MOVS     R0,#+255
   \   00000090   0x.... 0x....      BL       SPI2_SendByte
    595              MSD_CS_Deassert();	
   \   00000094   0x.... 0x....      BL       MSD_CS_Deassert
    596              	
    597          	return SD_NO_ERR;
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0xBD70             POP      {R4-R6,PC}       ;; return
    598          }	
    599          
    600          /*******************************************************************************************************************
    601          ** Name:	  INT8U SD_ReadBlockData()
    602          ** Function: read block data from card
    603          ** Input:	  INT32U len    : length
    604          **      	  INT8U *recbuf : the buffer of receive
    605          ** Output:	  0:  right		>0:  error code
    606          *******************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    607          INT8U SD_ReadBlockData(INT32U len, INT8U *recbuf)
    608          {
   \                     SD_ReadBlockData: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    609              INT8U tmp;
    610              INT32U i = 0,timeout;
    611          
    612          #if SD_UCOSII_EN    
    613              timeout = SD_UCOSII_SMALLWAIT;						/* small wait time */
    614          #else
    615          	timeout = sds.timeout_read;						/* wait time that receive data start token */
    616          #endif  
    617              
    618              MSD_CS_Assert();    
   \   00000006   0x.... 0x....      BL       MSD_CS_Assert
   \   0000000A   0x2600             MOVS     R6,#+0
   \   0000000C   0xF44F 0x7761      MOV      R7,#+900
    619              do
    620              { 									    	/* wait for receiving data start token 0xFE */
    621                  tmp = SPI2_RecByte();
   \                     ??SD_ReadBlockData_0: (+1)
   \   00000010   0x.... 0x....      BL       SPI2_RecByte
    622                  i++;
   \   00000014   0x1C76             ADDS     R6,R6,#+1
    623              }while((tmp == 0xFF) && (i < timeout));
   \   00000016   0x28FF             CMP      R0,#+255
   \   00000018   0xD102             BNE.N    ??SD_ReadBlockData_1
   \   0000001A   0xF5B6 0x7F61      CMP      R6,#+900
   \   0000001E   0xD3F7             BCC.N    ??SD_ReadBlockData_0
    624          	
    625          #if SD_UCOSII_EN    
    626              if (i >= timeout)
   \                     ??SD_ReadBlockData_1: (+1)
   \   00000020   0xF5B6 0x7F61      CMP      R6,#+900
   \   00000024   0xD30C             BCC.N    ??SD_ReadBlockData_2
    627             	{									/* continue to wait(suspend task) */
    628             		timeout = sds.timeout_read;
   \   00000026   0x....             LDR.N    R0,??DataTable5
   \   00000028   0x6907             LDR      R7,[R0, #+16]
    629             		i = 0;
   \   0000002A   0x2600             MOVS     R6,#+0
    630          	    do
    631              	{
    632                  	OSTimeDly(1);							/* tick(suspend task 1 tick) */
   \                     ??SD_ReadBlockData_3: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x.... 0x....      BL       OSTimeDly
    633                  	tmp = SPI2_RecByte();
   \   00000032   0x.... 0x....      BL       SPI2_RecByte
    634                 	 	i++;
   \   00000036   0x1C76             ADDS     R6,R6,#+1
    635             		}while((tmp == 0xFF) && (i < timeout));
   \   00000038   0x28FF             CMP      R0,#+255
   \   0000003A   0xD101             BNE.N    ??SD_ReadBlockData_2
   \   0000003C   0x42BE             CMP      R6,R7
   \   0000003E   0xD3F5             BCC.N    ??SD_ReadBlockData_3
    636          	}
    637          #endif
    638          
    639          	if (i >= timeout)
   \                     ??SD_ReadBlockData_2: (+1)
   \   00000040   0x42BE             CMP      R6,R7
   \   00000042   0xD303             BCC.N    ??SD_ReadBlockData_4
    640          	{
    641          		MSD_CS_Deassert();
   \   00000044   0x.... 0x....      BL       MSD_CS_Deassert
    642                 	return SD_ERR_TIMEOUT_READ;						/* return error timeout error code of reading */
   \   00000048   0x2031             MOVS     R0,#+49
   \   0000004A   0xBDF2             POP      {R1,R4-R7,PC}
    643          	}
    644          	
    645          	if (tmp != SD_TOK_READ_STARTBLOCK)					/* read start block token is error */
   \                     ??SD_ReadBlockData_4: (+1)
   \   0000004C   0x28FE             CMP      R0,#+254
   \   0000004E   0xD006             BEQ.N    ??SD_ReadBlockData_5
    646          	{
    647          		SPI2_SendByte(0xFF);
   \   00000050   0x20FF             MOVS     R0,#+255
   \   00000052   0x.... 0x....      BL       SPI2_SendByte
    648          		MSD_CS_Deassert();
   \   00000056   0x.... 0x....      BL       MSD_CS_Deassert
    649          		return SD_ERR_DATA_START_TOK;
   \   0000005A   0x2021             MOVS     R0,#+33
   \   0000005C   0xBDF2             POP      {R1,R4-R7,PC}
    650          	}
    651          
    652          	for (i = 0; i < len; i++) {
   \                     ??SD_ReadBlockData_5: (+1)
   \   0000005E   0xB13C             CBZ.N    R4,??SD_ReadBlockData_6
   \   00000060   0x462E             MOV      R6,R5
   \   00000062   0x4627             MOV      R7,R4
    653             		recbuf[i] = SPI2_RecByte();					/* receive data */
   \                     ??SD_ReadBlockData_7: (+1)
   \   00000064   0x.... 0x....      BL       SPI2_RecByte
    654          	}
   \   00000068   0x1E7F             SUBS     R7,R7,#+1
   \   0000006A   0xF806 0x0B01      STRB     R0,[R6], #+1
   \   0000006E   0xD1F9             BNE.N    ??SD_ReadBlockData_7
    655             		
    656              i = SPI2_RecByte();								
   \                     ??SD_ReadBlockData_6: (+1)
   \   00000070   0x.... 0x....      BL       SPI2_RecByte
   \   00000074   0x4606             MOV      R6,R0
    657              i = (i << 8) + SPI2_RecByte();    					        /* get 16-bit CRC */	
   \   00000076   0x.... 0x....      BL       SPI2_RecByte
    658          
    659          #if SD_CRC_EN 
    660             	if (i != SD_GetCRC16(recbuf, len))
   \   0000007A   0xEB00 0x2606      ADD      R6,R0,R6, LSL #+8
   \   0000007E   0xB2A1             UXTH     R1,R4
   \   00000080   0x4628             MOV      R0,R5
   \   00000082   0x.... 0x....      BL       SD_GetCRC16
   \   00000086   0x4286             CMP      R6,R0
   \   00000088   0xD006             BEQ.N    ??SD_ReadBlockData_8
    661             	{	
    662             		SPI2_SendByte(0xFF); 						/* CRC check is error */
   \   0000008A   0x20FF             MOVS     R0,#+255
   \   0000008C   0x.... 0x....      BL       SPI2_SendByte
    663             		MSD_CS_Deassert();		
   \   00000090   0x.... 0x....      BL       MSD_CS_Deassert
    664            		return SD_ERR_DATA_CRC16;					/* return error of CRC16 */				
   \   00000094   0x2020             MOVS     R0,#+32
   \   00000096   0xBDF2             POP      {R1,R4-R7,PC}
    665            	}    
    666          #endif   
    667          
    668          	SPI2_SendByte(0xFF); 
   \                     ??SD_ReadBlockData_8: (+1)
   \   00000098   0x20FF             MOVS     R0,#+255
   \   0000009A   0x.... 0x....      BL       SPI2_SendByte
    669          	MSD_CS_Deassert();
   \   0000009E                      REQUIRE ?Subroutine0
   \   0000009E                      ;; // Fall through to label ?Subroutine0
    670          
    671            	return SD_NO_ERR;							/* return function perform sucessfully */
    672          }
    673          
    674          /*******************************************************************************************************************
    675          ** Name:	  INT8U SD_WriteBlockData()
    676          ** Function: write block data to card
    677          ** INT8U bmulti   : multi blocks operate 1:Y 0:N 
    678          **	  	  INT32U len     : length
    679          **	 	  INT8U *sendbuf : the buffer of send
    680          **Output:	  0:  right		>0:  error code
    681          ********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    682          INT8U SD_WriteBlockData(INT8U bmulti, INT32U len, INT8U *sendbuf)
    683          {
   \                     SD_WriteBlockData: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    684              INT16U i;
    685              #if 0
    686          	INT16U tmp;
    687              #endif  
    688          
    689              MSD_CS_Assert();
   \   00000008   0x.... 0x....      BL       MSD_CS_Assert
    690          		
    691              SPI2_SendByte(0xFF);						/* clock out 8 clk before start */
   \   0000000C   0x20FF             MOVS     R0,#+255
   \   0000000E   0x.... 0x....      BL       SPI2_SendByte
    692              
    693              if (bmulti == 1)
   \   00000012   0x2C01             CMP      R4,#+1
   \   00000014   0xBF0C             ITE      EQ 
   \   00000016   0x20FC             MOVEQ    R0,#+252
   \   00000018   0x20FE             MOVNE    R0,#+254
    694               SPI2_SendByte(SD_TOK_WRITE_STARTBLOCK_M);	                /* start token of write multi blocks */
    695              else
    696               SPI2_SendByte(SD_TOK_WRITE_STARTBLOCK);		        /* start token of write single block */
   \   0000001A   0x.... 0x....      BL       SPI2_SendByte
    697          
    698              for (i = 0; i < len; i++)
   \   0000001E   0x2400             MOVS     R4,#+0
   \   00000020   0xE003             B.N      ??SD_WriteBlockData_0
    699               SPI2_SendByte(sendbuf[i]);				        /* send data */
   \                     ??SD_WriteBlockData_1: (+1)
   \   00000022   0x5DA0             LDRB     R0,[R4, R6]
   \   00000024   0x.... 0x....      BL       SPI2_SendByte
   \   00000028   0x1C64             ADDS     R4,R4,#+1
   \                     ??SD_WriteBlockData_0: (+1)
   \   0000002A   0xB2A4             UXTH     R4,R4
   \   0000002C   0x42AC             CMP      R4,R5
   \   0000002E   0xD3F8             BCC.N    ??SD_WriteBlockData_1
    700          
    701          #if SD_CRC_EN	
    702          	i = SD_GetCRC16(sendbuf,len);				/* calculate CRC16 */
   \   00000030   0xB2A9             UXTH     R1,R5
   \   00000032   0x4630             MOV      R0,R6
   \   00000034   0x.... 0x....      BL       SD_GetCRC16
   \   00000038   0x4604             MOV      R4,R0
    703          #endif
    704          	
    705          	SPI2_SendByte((i >> 8) & 0xFF);
   \   0000003A   0x0A00             LSRS     R0,R0,#+8
   \   0000003C   0x.... 0x....      BL       SPI2_SendByte
    706          	SPI2_SendByte(i & 0xFF); 				/* send CRC16 check code */
   \   00000040   0xB2E0             UXTB     R0,R4
   \   00000042   0x.... 0x....      BL       SPI2_SendByte
    707          			    
    708             #if 0
    709          	tmp = SPI2_RecByte();
    710          
    711            	if ((tmp & SD_RESP_DATA_MSK) != SD_RESP_DATA_ACCETPTED)	
    712            	{		
    713             		SPI2_SendByte(0xFF);				/* clock out 8 clk before return */
    714             		MSD_CS_Deassert();
    715             		return SD_ERR_DATA_RESP;			/* data response error */
    716              }
    717              #endif   
    718          
    719              MSD_CS_Deassert();
   \   00000046   0x.... 0x....      BL       MSD_CS_Deassert
    720               		
    721              if (SD_WaitBusy(SD_WAIT_WRITE) != SD_NO_ERR)			
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x.... 0x....      BL       SD_WaitBusy
   \   00000050   0xB100             CBZ.N    R0,??SD_WriteBlockData_2
    722              	return SD_ERR_TIMEOUT_WRITE;				/* write time out */
   \   00000052   0x2032             MOVS     R0,#+50
    723              else
    724              	return SD_NO_ERR; 					/* write right */
   \                     ??SD_WriteBlockData_2: (+1)
   \   00000054   0xBD70             POP      {R4-R6,PC}       ;; return
    725           }
    726          
    727          /*******************************************************************************************************************
    728          ** Name:	  void SD_StopMultiToken(void)
    729          ** Function: send the token that stop multiple block write
    730          ** Input:	  NULL
    731          ** Output:	  NULL
    732          ********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    733          void SD_StopMultiToken(void)
    734          {
   \                     SD_StopMultiToken: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    735          	MSD_CS_Assert();
   \   00000002   0x.... 0x....      BL       MSD_CS_Assert
    736          	
    737          	SPI2_SendByte(0xFF);						/* send 8 clock first */
   \   00000006   0x20FF             MOVS     R0,#+255
   \   00000008   0x.... 0x....      BL       SPI2_SendByte
    738          	SPI2_SendByte(SD_TOK_STOP_MULTI);				/* send stop transmission token */
   \   0000000C   0x20FD             MOVS     R0,#+253
   \   0000000E   0x.... 0x....      BL       SPI2_SendByte
    739          	SPI2_RecByte();
   \   00000012   0x.... 0x....      BL       SPI2_RecByte
    740          	
    741              MSD_CS_Deassert();
   \   00000016   0xE8BD 0x4001      POP      {R0,LR}
   \   0000001A   0x.... 0x....      B.W      MSD_CS_Deassert
    742          }
    743          
    744          
    745          /********************************************************************************************************************
    746          ** Name:	  void SD_WaitBusy()
    747          ** Function: poll SD Card wheather it is busy
    748          ** Input:	  INT32U timeout: time out type
    749          ** Output:	  0: not time out   > 0: error code
    750          *********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    751          INT8U SD_WaitBusy(INT8U waittype)
    752          {
   \                     SD_WaitBusy: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    753              INT32U timeout, i = 0;
    754              INT8U tmp;
    755              
    756            	if (waittype == SD_WAIT_WRITE)
    757            		timeout = sds.timeout_write;			/* wait type is write operation */
    758            	else
    759            		timeout = sds.timeout_erase;   			/* wait type is erase operation */
    760              	
    761          #if SD_UCOSII_EN
    762                  timeout = SD_UCOSII_SMALLWAIT;				/* small wait time */
    763          #endif
    764             
    765          	MSD_CS_Assert();
   \   00000004   0x.... 0x....      BL       MSD_CS_Assert
   \   00000008   0x2500             MOVS     R5,#+0
   \   0000000A   0xF44F 0x7661      MOV      R6,#+900
    766             	do
    767             	{ 							/* wait for being busy end */
    768                  tmp = SPI2_RecByte();
   \                     ??SD_WaitBusy_0: (+1)
   \   0000000E   0x.... 0x....      BL       SPI2_RecByte
    769                  i++;
   \   00000012   0x1C6D             ADDS     R5,R5,#+1
    770              }while ((tmp != 0xFF) && (i < timeout));		        /* always receive 0 when card is busy */    
   \   00000014   0x28FF             CMP      R0,#+255
   \   00000016   0xD002             BEQ.N    ??SD_WaitBusy_1
   \   00000018   0xF5B5 0x7F61      CMP      R5,#+900
   \   0000001C   0xD3F7             BCC.N    ??SD_WaitBusy_0
    771          
    772          #if SD_UCOSII_EN
    773          	if (i >= timeout)
   \                     ??SD_WaitBusy_1: (+1)
   \   0000001E   0xF5B5 0x7F61      CMP      R5,#+900
   \   00000022   0xD30F             BCC.N    ??SD_WaitBusy_2
    774          	{							/* after small wait, card is still busy */
    775            		if (waittype == SD_WAIT_WRITE)
   \   00000024   0x....             LDR.N    R0,??DataTable5
   \   00000026   0x2C01             CMP      R4,#+1
   \   00000028   0xBF0C             ITE      EQ 
   \   0000002A   0x6946             LDREQ    R6,[R0, #+20]
   \   0000002C   0x6986             LDRNE    R6,[R0, #+24]
    776            			timeout = sds.timeout_write;
    777            		else
    778            			timeout = sds.timeout_erase;   
    779          			
    780          		i = 0;
   \   0000002E   0x2500             MOVS     R5,#+0
    781             		do
    782             		{ 	
    783             		  OSTimeDly(1); 				/* OS suspend 1 tick */
   \                     ??SD_WaitBusy_3: (+1)
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x.... 0x....      BL       OSTimeDly
    784                 		  tmp = SPI2_RecByte();
   \   00000036   0x.... 0x....      BL       SPI2_RecByte
    785                 		  i++;
   \   0000003A   0x1C6D             ADDS     R5,R5,#+1
    786              	        }while ((tmp != 0xFF) && (i < timeout));        /* always receive 0 when card is busy */    
   \   0000003C   0x28FF             CMP      R0,#+255
   \   0000003E   0xD001             BEQ.N    ??SD_WaitBusy_2
   \   00000040   0x42B5             CMP      R5,R6
   \   00000042   0xD3F5             BCC.N    ??SD_WaitBusy_3
    787          	}
    788          #endif	
    789          
    790          	if(i < timeout) 
   \                     ??SD_WaitBusy_2: (+1)
   \   00000044   0x42B5             CMP      R5,R6
   \   00000046   0xBF34             ITE      CC 
   \   00000048   0x2400             MOVCC    R4,#+0
   \   0000004A   0x2430             MOVCS    R4,#+48
    791          		tmp = SD_NO_ERR;				/* return 0 indicate that operation is not time out */
    792          	else 
    793          		tmp = SD_ERR_TIMEOUT_WAIT;			/* return error code indicate that operation is time out */
    794          
    795          	SPI2_SendByte(0xFF);
   \   0000004C   0x20FF             MOVS     R0,#+255
   \   0000004E   0x.... 0x....      BL       SPI2_SendByte
    796          	MSD_CS_Deassert();								
   \   00000052   0x.... 0x....      BL       MSD_CS_Deassert
    797          	return tmp;							
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0xBD70             POP      {R4-R6,PC}       ;; return
    798          }
    799          
    800          /********************************************************************************************************************
    801          ** Name:	  void SD_SPIDelay()
    802          ** Function: SPI Bus delay 
    803          ** Input:	  INT8U value : delay value,do not beyond 255
    804          ** Output:	  NULL
    805          *********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    806          void SD_SPIDelay(INT8U value)
    807          {
   \                     SD_SPIDelay: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    808              INT8U i;
    809          
    810              for (i = 0; i < value; i++)
   \   00000004   0xD004             BEQ.N    ??SD_SPIDelay_0
    811                  SPI2_SendByte(0xFF);					/* clock out 0xFF */
   \                     ??SD_SPIDelay_1: (+1)
   \   00000006   0x20FF             MOVS     R0,#+255
   \   00000008   0x.... 0x....      BL       SPI2_SendByte
   \   0000000C   0x1E64             SUBS     R4,R4,#+1
   \   0000000E   0xD1FA             BNE.N    ??SD_SPIDelay_1
    812          }
   \                     ??SD_SPIDelay_0: (+1)
   \   00000010   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     sds

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    813          
    814          
    815          
    816          
    817          
    818          
    819          
    820          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   SD_BlockCommand
        16   -> SD_SendCmd
      16   SD_EnableCRC
        16   -> SD_SendCmd
       0   SD_PackParam
      24   SD_ReadBlockData
        24   -> MSD_CS_Assert
        24   -> MSD_CS_Deassert
        24   -> OSTimeDly
        24   -> SD_GetCRC16
        24   -> SPI2_RecByte
        24   -> SPI2_SendByte
      24   SD_ReadCSD
        24   -> SD_ReadRegister
        24   -> SD_SendCmd
       8   SD_ReadCard_Status
         8   -> SD_SendCmd
       0   SD_ReadMultipleBlock
         0   -> SD_BlockCommand
      24   SD_ReadOCR
        24   -> SD_SendCmd
      16   SD_ReadRegister
        16   -> MSD_CS_Assert
        16   -> MSD_CS_Deassert
        16   -> SD_GetCRC16
        16   -> SPI2_RecByte
        16   -> SPI2_SendByte
       0   SD_ReadSingleBlock
         0   -> SD_BlockCommand
      16   SD_ResetSD
        16   -> SD_SendCmd
       8   SD_SPIDelay
         8   -> SPI2_SendByte
      24   SD_SendCmd
        24   -> MSD_CS_Assert
        24   -> MSD_CS_Deassert
        24   -> SD_GetCmdByte6
        24   -> SPI2_RecByte
        24   -> SPI2_SendByte
      16   SD_SetBlockLen
        16   -> SD_SendCmd
       8   SD_StopMultiToken
         8   -> MSD_CS_Assert
         0   -> MSD_CS_Deassert
         8   -> SPI2_RecByte
         8   -> SPI2_SendByte
      16   SD_StopTransmission
        16   -> SD_SendCmd
      16   SD_WaitBusy
        16   -> MSD_CS_Assert
        16   -> MSD_CS_Deassert
        16   -> OSTimeDly
        16   -> SPI2_RecByte
        16   -> SPI2_SendByte
      16   SD_WriteBlockData
        16   -> MSD_CS_Assert
        16   -> MSD_CS_Deassert
        16   -> SD_GetCRC16
        16   -> SD_WaitBusy
        16   -> SPI2_SendByte
      16   SD_WriteMultipleBlock
        16   -> SD_SendCmd
      16   SD_WriteSingleBlock
        16   -> SD_SendCmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       8  ?Subroutine0
      18  ?Subroutine1
       8  ?Subroutine2
       4  ?_0
       4  ?_1
       4  ?_2
       4  ?_3
       4  ?_4
      38  SD_BlockCommand
      28  SD_EnableCRC
      16  SD_PackParam
     158  SD_ReadBlockData
      50  SD_ReadCSD
      20  SD_ReadCard_Status
       8  SD_ReadMultipleBlock
      66  SD_ReadOCR
     156  SD_ReadRegister
       8  SD_ReadSingleBlock
      18  SD_ResetSD
      18  SD_SPIDelay
     150  SD_SendCmd
      34  SD_SetBlockLen
      30  SD_StopMultiToken
      16  SD_StopTransmission
      90  SD_WaitBusy
      86  SD_WriteBlockData
      40  SD_WriteMultipleBlock
      40  SD_WriteSingleBlock

 
    20 bytes in section .rodata
 1 108 bytes in section .text
 
 1 108 bytes of CODE  memory
    20 bytes of CONST memory

Errors: none
Warnings: none
