###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       09/Feb/2018  16:15:00
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\HW Projects\ControlHome\CntrHome - RF69w\uCOS-II\Source\os_core.c
#    Command line =  
#        "E:\HW Projects\ControlHome\CntrHome - RF69w\uCOS-II\Source\os_core.c"
#        -lCN "E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\List" -o
#        "E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\Obj" --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\APP\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\BSP\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\CPU\inc\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-CPU\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-RTC\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-LIB\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uCOS-II\Ports\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uCOS-II\Source\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\I2C-Out\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Direct_Sw\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Wdt_led\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-LCD\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-RF\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\api\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\config\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\os\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\fsl\fat\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\clib\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\lbl\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\device\mmc\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\file\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-Terminal\src\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-Terminal\inc\" -Oh
#    List file    =  
#        E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\List\os_core.lst
#    Object file  =  
#        E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\Obj\os_core.o
#
###############################################################################

E:\HW Projects\ControlHome\CntrHome - RF69w\uCOS-II\Source\os_core.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                             CORE FUNCTIONS
      6          *
      7          *                              (c) Copyright 1992-2007, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_CORE.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.86
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license 
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience 
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          #define  OS_GLOBALS
     26          #include <ucos_ii.h>

   \                                 In section .bss, align 4
   \   __absolute INT8U OSIntNesting
   \                     OSIntNesting:
   \   00000000                      DS8 1
   \   __absolute INT8U OSLockNesting
   \                     OSLockNesting:
   \   00000001                      DS8 1
   \   __absolute INT8U OSPrioCur
   \                     OSPrioCur:
   \   00000002                      DS8 1
   \   __absolute INT8U OSPrioHighRdy
   \                     OSPrioHighRdy:
   \   00000003                      DS8 1
   \   __absolute INT8U OSRdyGrp
   \                     OSRdyGrp:
   \   00000004                      DS8 1
   \   __absolute BOOLEAN OSRunning
   \                     OSRunning:
   \   00000005                      DS8 1
   \   __absolute INT8U OSTaskCtr
   \                     OSTaskCtr:
   \   00000006                      DS8 1
   \   __absolute INT8U OSTickStepState
   \                     OSTickStepState:
   \   00000007                      DS8 1
   \   __absolute INT8U OSRdyTbl[4]
   \                     OSRdyTbl:
   \   00000008                      DS8 4
   \   __absolute INT32U OSCtxSwCtr
   \                     OSCtxSwCtr:
   \   0000000C                      DS8 4
   \   __absolute OS_EVENT *OSEventFreeList
   \                     OSEventFreeList:
   \   00000010                      DS8 4
   \   __absolute INT32U volatile OSIdleCtr
   \                     OSIdleCtr:
   \   00000014                      DS8 4
   \   __absolute OS_TCB *OSTCBCur
   \                     OSTCBCur:
   \   00000018                      DS8 4
   \   __absolute OS_TCB *OSTCBFreeList
   \                     OSTCBFreeList:
   \   0000001C                      DS8 4
   \   __absolute OS_TCB *OSTCBHighRdy
   \                     OSTCBHighRdy:
   \   00000020                      DS8 4
   \   __absolute OS_TCB *OSTCBList
   \                     OSTCBList:
   \   00000024                      DS8 4
   \   __absolute INT32U volatile OSTime
   \                     OSTime:
   \   00000028                      DS8 4
   \   __absolute OS_EVENT OSEventTbl[10]
   \                     OSEventTbl:
   \   0000002C                      DS8 320
   \   __absolute OS_STK OSTaskIdleStk[128]
   \                     OSTaskIdleStk:
   \   0000016C                      DS8 512
   \   __absolute OS_TCB OSTCBTbl[17]
   \                     OSTCBTbl:
   \   0000036C                      DS8 1564

   \                                 In section .bss, align 4
   \   __absolute OS_FLAG_GRP OSFlagTbl[5]
   \                     OSFlagTbl:
   \   00000000                      DS8 140

   \                                 In section .bss, align 4
   \   __absolute OS_FLAG_GRP *OSFlagFreeList
   \                     OSFlagFreeList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute OS_TCB *OSTCBPrioTbl[32]
   \                     OSTCBPrioTbl:
   \   00000000                      DS8 128

   \                                 In section .bss, align 4
   \   __absolute OS_MEM *OSMemFreeList
   \                     OSMemFreeList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute OS_MEM OSMemTbl[5]
   \                     OSMemTbl:
   \   00000000                      DS8 180

   \                                 In section .bss, align 4
   \   __absolute OS_Q *OSQFreeList
   \                     OSQFreeList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute OS_Q OSQTbl[4]
   \                     OSQTbl:
   \   00000000                      DS8 96
     27          #endif
     28          
     29          /*
     30          *********************************************************************************************************
     31          *                                       PRIORITY RESOLUTION TABLE
     32          *
     33          * Note: Index into table is bit pattern to resolve highest priority
     34          *       Indexed value corresponds to highest priority bit position (i.e. 0..7)
     35          *********************************************************************************************************
     36          */
     37          

   \                                 In section .text, align 4, keep-with-next
     38          INT8U  const  OSUnMapTbl[256] = {
   \                     OSUnMapTbl:
   \   00000000   0x00 0x00          DC8 0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x04 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01         
   \   00000017   0x00 0x03          DC8 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x05    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00         
   \   0000002E   0x01 0x00          DC8 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2
   \              0x04 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x06 0x00    
   \              0x01 0x00    
   \              0x02         
   \   00000045   0x00 0x01          DC8 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x04    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00         
   \   0000005C   0x02 0x00          DC8 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1
   \              0x01 0x00    
   \              0x05 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x04 0x00    
   \              0x01         
   \   00000073   0x00 0x02          DC8 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x07    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00         
   \   0000008A   0x01 0x00          DC8 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x04 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x05         
   \   000000A1   0x00 0x01          DC8 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x04    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00         
   \   000000B8   0x03 0x00          DC8 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x06 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01         
   \   000000CF   0x00 0x04          DC8 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x05    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00         
   \   000000E6   0x01 0x00          DC8 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x04 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02         
   \   000000FD   0x00 0x01          DC8 0, 1, 0
   \              0x00         
     39              0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x00 to 0x0F                             */
     40              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x10 to 0x1F                             */
     41              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x20 to 0x2F                             */
     42              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x30 to 0x3F                             */
     43              6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x40 to 0x4F                             */
     44              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x50 to 0x5F                             */
     45              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x60 to 0x6F                             */
     46              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x70 to 0x7F                             */
     47              7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x80 to 0x8F                             */
     48              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x90 to 0x9F                             */
     49              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xA0 to 0xAF                             */
     50              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xB0 to 0xBF                             */
     51              6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xC0 to 0xCF                             */
     52              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xD0 to 0xDF                             */
     53              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xE0 to 0xEF                             */
     54              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0        /* 0xF0 to 0xFF                             */
     55          };
     56          
     57          /*$PAGE*/
     58          /*
     59          *********************************************************************************************************
     60          *                                       FUNCTION PROTOTYPES
     61          *********************************************************************************************************
     62          */
     63          
     64          static  void  OS_InitEventList(void);
     65          
     66          static  void  OS_InitMisc(void);
     67          
     68          static  void  OS_InitRdyList(void);
     69          
     70          static  void  OS_InitTaskIdle(void);
     71          
     72          #if OS_TASK_STAT_EN > 0
     73          static  void  OS_InitTaskStat(void);
     74          #endif
     75          
     76          static  void  OS_InitTCBList(void);
     77          
     78          static  void  OS_SchedNew(void);
     79          
     80          /*$PAGE*/
     81          /*
     82          *********************************************************************************************************
     83          *                         GET THE NAME OF A SEMAPHORE, MUTEX, MAILBOX or QUEUE
     84          *
     85          * Description: This function is used to obtain the name assigned to a semaphore, mutex, mailbox or queue.
     86          *
     87          * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
     88          *                        a mutex, a mailbox or a queue.  Where this function is concerned, the actual
     89          *                        type is irrelevant.
     90          *
     91          *              pname     is a pointer to an ASCII string that will receive the name of the semaphore,
     92          *                        mutex, mailbox or queue.  The string must be able to hold at least
     93          *                        OS_EVENT_NAME_SIZE characters.
     94          *
     95          *              perr      is a pointer to an error code that can contain one of the following values:
     96          *
     97          *                        OS_ERR_NONE                if the name was copied to 'pname'
     98          *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
     99          *                                                   control block type.
    100          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    101          *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
    102          *                        OS_ERR_NAME_GET_ISR        if you are trying to call this function from an ISR
    103          *
    104          * Returns    : The length of the string or 0 if the 'pevent' is a NULL pointer.
    105          *********************************************************************************************************
    106          */
    107          
    108          #if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)

   \                                 In section .text, align 2, keep-with-next
    109          INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
    110          {
   \                     OSEventNameGet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
    111              INT8U      len;
    112          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    113              OS_CPU_SR  cpu_sr = 0;
    114          #endif
    115          
    116          
    117          
    118          #if OS_ARG_CHK_EN > 0
    119              if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
    120                  return (0);
    121              }
    122              if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
    123                  *perr = OS_ERR_PEVENT_NULL;
    124                  return (0);
    125              }
    126              if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
    127                  *perr = OS_ERR_PNAME_NULL;
    128                  return (0);
    129              }
    130          #endif
    131              if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x460E             MOV      R6,R1
   \   0000000C   0x4614             MOV      R4,R2
   \   0000000E   0xB108             CBZ.N    R0,??OSEventNameGet_0
    132                  *perr  = OS_ERR_NAME_GET_ISR;
   \   00000010   0x2011             MOVS     R0,#+17
   \   00000012   0xE014             B.N      ??OSEventNameGet_1
    133                  return (0);
    134              }
    135              switch (pevent->OSEventType) {
   \                     ??OSEventNameGet_0: (+1)
   \   00000014   0x7828             LDRB     R0,[R5, #+0]
   \   00000016   0x1E40             SUBS     R0,R0,#+1
   \   00000018   0x2803             CMP      R0,#+3
   \   0000001A   0xD80F             BHI.N    ??OSEventNameGet_2
    136                  case OS_EVENT_TYPE_SEM:
    137                  case OS_EVENT_TYPE_MUTEX:
    138                  case OS_EVENT_TYPE_MBOX:
    139                  case OS_EVENT_TYPE_Q:
    140                       break;
    141          
    142                  default:
    143                       *perr = OS_ERR_EVENT_TYPE;
    144                       return (0);
    145              }
    146              OS_ENTER_CRITICAL();
   \   0000001C   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000020   0x4607             MOV      R7,R0
    147              len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
   \   00000022   0xF105 0x010F      ADD      R1,R5,#+15
   \   00000026   0x4630             MOV      R0,R6
   \   00000028   0x.... 0x....      BL       OS_StrCopy
   \   0000002C   0x4605             MOV      R5,R0
    148              OS_EXIT_CRITICAL();
   \   0000002E   0x4638             MOV      R0,R7
   \   00000030   0x.... 0x....      BL       OS_CPU_SR_Restore
    149              *perr = OS_ERR_NONE;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x7020             STRB     R0,[R4, #+0]
    150              return (len);
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??OSEventNameGet_2: (+1)
   \   0000003C   0x2001             MOVS     R0,#+1
   \                     ??OSEventNameGet_1: (+1)
   \   0000003E   0x7020             STRB     R0,[R4, #+0]
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    151          }
    152          #endif
    153          
    154          /*$PAGE*/
    155          /*
    156          *********************************************************************************************************
    157          *                         ASSIGN A NAME TO A SEMAPHORE, MUTEX, MAILBOX or QUEUE
    158          *
    159          * Description: This function assigns a name to a semaphore, mutex, mailbox or queue.
    160          *
    161          * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
    162          *                        a mutex, a mailbox or a queue.  Where this function is concerned, it doesn't
    163          *                        matter the actual type.
    164          *
    165          *              pname     is a pointer to an ASCII string that will be used as the name of the semaphore,
    166          *                        mutex, mailbox or queue.  The string must be able to hold at least
    167          *                        OS_EVENT_NAME_SIZE characters.
    168          *
    169          *              perr      is a pointer to an error code that can contain one of the following values:
    170          *
    171          *                        OS_ERR_NONE                if the requested task is resumed
    172          *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
    173          *                                                   control block type.
    174          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    175          *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
    176          *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
    177          *
    178          * Returns    : None
    179          *********************************************************************************************************
    180          */
    181          
    182          #if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)

   \                                 In section .text, align 2, keep-with-next
    183          void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
    184          {
   \                     OSEventNameSet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
    185              INT8U      len;
    186          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    187              OS_CPU_SR  cpu_sr = 0;
    188          #endif
    189          
    190          
    191          
    192          #if OS_ARG_CHK_EN > 0
    193              if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
    194                  return;
    195              }
    196              if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
    197                  *perr = OS_ERR_PEVENT_NULL;
    198                  return;
    199              }
    200              if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
    201                  *perr = OS_ERR_PNAME_NULL;
    202                  return;
    203              }
    204          #endif
    205              if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x460E             MOV      R6,R1
   \   0000000C   0x4614             MOV      R4,R2
   \   0000000E   0xB108             CBZ.N    R0,??OSEventNameSet_0
    206                  *perr = OS_ERR_NAME_SET_ISR;
   \   00000010   0x2012             MOVS     R0,#+18
   \   00000012   0xE021             B.N      ??OSEventNameSet_1
    207                  return;
    208              }
    209              switch (pevent->OSEventType) {
   \                     ??OSEventNameSet_0: (+1)
   \   00000014   0x7828             LDRB     R0,[R5, #+0]
   \   00000016   0x1E40             SUBS     R0,R0,#+1
   \   00000018   0x2803             CMP      R0,#+3
   \   0000001A   0xD812             BHI.N    ??OSEventNameSet_2
    210                  case OS_EVENT_TYPE_SEM:
    211                  case OS_EVENT_TYPE_MUTEX:
    212                  case OS_EVENT_TYPE_MBOX:
    213                  case OS_EVENT_TYPE_Q:
    214                       break;
    215          
    216                  default:
    217                       *perr = OS_ERR_EVENT_TYPE;
    218                       return;
    219              }
    220              OS_ENTER_CRITICAL();
   \   0000001C   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000020   0x4607             MOV      R7,R0
    221              len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
   \   00000022   0x4630             MOV      R0,R6
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0xE000             B.N      ??OSEventNameSet_3
   \                     ??OSEventNameSet_4: (+1)
   \   00000028   0x1C49             ADDS     R1,R1,#+1
   \                     ??OSEventNameSet_3: (+1)
   \   0000002A   0xF810 0x2B01      LDRB     R2,[R0], #+1
   \   0000002E   0x2A00             CMP      R2,#+0
   \   00000030   0xD1FA             BNE.N    ??OSEventNameSet_4
    222              if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
   \   00000032   0xB2C9             UXTB     R1,R1
   \   00000034   0x2910             CMP      R1,#+16
   \   00000036   0xDB06             BLT.N    ??OSEventNameSet_5
    223                  OS_EXIT_CRITICAL();
   \   00000038   0x4638             MOV      R0,R7
   \   0000003A   0x.... 0x....      BL       OS_CPU_SR_Restore
    224                  *perr = OS_ERR_EVENT_NAME_TOO_LONG;
   \   0000003E   0x200B             MOVS     R0,#+11
   \   00000040   0xE00A             B.N      ??OSEventNameSet_1
    225                  return;
    226              }
   \                     ??OSEventNameSet_2: (+1)
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xE008             B.N      ??OSEventNameSet_1
    227              (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
   \                     ??OSEventNameSet_5: (+1)
   \   00000046   0x4631             MOV      R1,R6
   \   00000048   0xF105 0x000F      ADD      R0,R5,#+15
   \   0000004C   0x.... 0x....      BL       OS_StrCopy
    228              OS_EXIT_CRITICAL();
   \   00000050   0x4638             MOV      R0,R7
   \   00000052   0x.... 0x....      BL       OS_CPU_SR_Restore
    229              *perr = OS_ERR_NONE;
   \   00000056   0x2000             MOVS     R0,#+0
   \                     ??OSEventNameSet_1: (+1)
   \   00000058   0x7020             STRB     R0,[R4, #+0]
    230          }
   \   0000005A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    231          #endif
    232          
    233          /*$PAGE*/
    234          /*
    235          *********************************************************************************************************
    236          *                                      PEND ON MULTIPLE EVENTS
    237          *
    238          * Description: This function waits for multiple events.  If multiple events are ready at the start of the
    239          *              pend call, then all available events are returned as ready.  If the task must pend on the
    240          *              multiple events, then only the first posted or aborted event is returned as ready.
    241          *
    242          * Arguments  : pevents_pend  is a pointer to a NULL-terminated array of event control blocks to wait for.
    243          *
    244          *              pevents_rdy   is a pointer to an array to return which event control blocks are available
    245          *                            or ready.  The size of the array MUST be greater than or equal to the size
    246          *                            of the 'pevents_pend' array, including terminating NULL.
    247          *
    248          *              pmsgs_rdy     is a pointer to an array to return messages from any available message-type
    249          *                            events.  The size of the array MUST be greater than or equal to the size of
    250          *                            the 'pevents_pend' array, excluding the terminating NULL.  Since NULL
    251          *                            messages are valid messages, this array cannot be NULL-terminated.  Instead,
    252          *                            every available message-type event returns its messages in the 'pmsgs_rdy'
    253          *                            array at the same index as the event is returned in the 'pevents_rdy' array.
    254          *                            All other 'pmsgs_rdy' array indices are filled with NULL messages.
    255          *
    256          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
    257          *                            wait for the resources up to the amount of time specified by this argument.
    258          *                            If you specify 0, however, your task will wait forever for the specified
    259          *                            events or, until the resources becomes available (or the events occur).
    260          *
    261          *              perr          is a pointer to where an error message will be deposited.  Possible error
    262          *                            messages are:
    263          *
    264          *                            OS_ERR_NONE         The call was successful and your task owns the resources
    265          *                                                or, the events you are waiting for occurred; check the
    266          *                                                'pevents_rdy' array for which events are available.
    267          *                            OS_ERR_PEND_ABORT   The wait on the events was aborted; check the
    268          *                                                'pevents_rdy' array for which events were aborted.
    269          *                            OS_ERR_TIMEOUT      The events were not received within the specified
    270          *                                                'timeout'.
    271          *                            OS_ERR_PEVENT_NULL  If 'pevents_pend', 'pevents_rdy', or 'pmsgs_rdy' is a 
    272          *                                                NULL pointer.
    273          *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to an array of semaphores, 
    274          *                                                mailboxes, and/or queues.
    275          *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
    276          *                                                would lead to a suspension.
    277          *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked.
    278          *
    279          * Returns    : >  0          the number of events returned as ready or aborted.
    280          *              == 0          if no events are returned as ready because of timeout or upon error.
    281          *
    282          * Notes      : 1) a. Validate 'pevents_pend' array as valid OS_EVENTs : 
    283          *
    284          *                        semaphores, mailboxes, queues
    285          *
    286          *                 b. Return ALL available events and messages, if any
    287          *
    288          *                 c. Add    current task priority as pending to   each events's wait list
    289          *                      Performed in OS_EventTaskWaitMulti()
    290          *
    291          *                 d. Wait on any of multiple events
    292          *
    293          *                 e. Remove current task priority as pending from each events's wait list
    294          *                      Performed in OS_EventTaskRdy(), if events posted or aborted
    295          *
    296          *                 f. Return any event posted or aborted, if any
    297          *                      else
    298          *                    Return timeout
    299          *
    300          *              2) 'pevents_rdy' initialized to NULL PRIOR to all other validation or function handling in 
    301          *                 case of any error(s).
    302          *********************************************************************************************************
    303          */
    304          /*$PAGE*/
    305          #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))

   \                                 In section .text, align 2, keep-with-next
    306          INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
    307          {
   \                     OSEventPendMulti: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x468A             MOV      R10,R1
    308              OS_EVENT  **pevents;
    309              OS_EVENT   *pevent;
    310          #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
    311              OS_Q       *pq;
    312          #endif
    313              BOOLEAN     events_rdy;
    314              INT16U      events_rdy_nbr;
    315              INT8U       events_stat;
    316          #if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    317              OS_CPU_SR   cpu_sr = 0;
    318          #endif
    319          
    320          
    321          
    322          #if (OS_ARG_CHK_EN > 0)
    323              if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
    324                  return (0);
    325              }
    326              if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
    327                 *perr =  OS_ERR_PEVENT_NULL;
    328                  return (0);
    329              }
    330              if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
    331                 *perr =  OS_ERR_PEVENT_NULL;
    332                  return (0);
    333              }
    334              if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
    335                 *perr =  OS_ERR_PEVENT_NULL;
    336                  return (0);
    337              }
    338          #endif
    339          
    340             *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
   \   00000008   0x2000             MOVS     R0,#+0
    341          
    342              pevents     =  pevents_pend;
   \   0000000A   0x4641             MOV      R1,R8
   \   0000000C   0xF8CA 0x0000      STR      R0,[R10, #+0]
    343              pevent      = *pevents;
   \   00000010   0x680E             LDR      R6,[R1, #+0]
   \   00000012   0x9F0A             LDR      R7,[SP, #+40]
   \   00000014   0x4693             MOV      R11,R2
   \   00000016   0xE001             B.N      ??OSEventPendMulti_0
    344              while  (pevent != (OS_EVENT *)0) {
    345                  switch (pevent->OSEventType) {                  /* Validate event block types                  */
    346          #if (OS_SEM_EN  > 0)
    347                      case OS_EVENT_TYPE_SEM:
    348                           break;
    349          #endif
    350          #if (OS_MBOX_EN > 0)
    351                      case OS_EVENT_TYPE_MBOX:
    352                           break;
    353          #endif
    354          #if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
    355                      case OS_EVENT_TYPE_Q:
    356                           break;
    357          #endif
    358          
    359                      case OS_EVENT_TYPE_MUTEX:                                            
    360                      case OS_EVENT_TYPE_FLAG:
    361                      default:           
    362                          *perr = OS_ERR_EVENT_TYPE;
    363                           return (0);
    364                  }
    365                  pevents++;
    366                  pevent = *pevents;
   \                     ??OSEventPendMulti_1: (+1)
   \   00000018   0xF851 0x6F04      LDR      R6,[R1, #+4]!
   \                     ??OSEventPendMulti_0: (+1)
   \   0000001C   0xB12E             CBZ.N    R6,??OSEventPendMulti_2
   \   0000001E   0x7830             LDRB     R0,[R6, #+0]
   \   00000020   0x1E40             SUBS     R0,R0,#+1
   \   00000022   0x2802             CMP      R0,#+2
   \   00000024   0xD9F8             BLS.N    ??OSEventPendMulti_1
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE008             B.N      ??OSEventPendMulti_3
    367              }
    368          
    369              if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
   \                     ??OSEventPendMulti_2: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R4,??DataTable17
   \   0000002E   0x7820             LDRB     R0,[R4, #+0]
   \   00000030   0xB108             CBZ.N    R0,??OSEventPendMulti_4
    370                 *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0xE002             B.N      ??OSEventPendMulti_3
    371                  return (0);
    372              }
    373              if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
   \                     ??OSEventPendMulti_4: (+1)
   \   00000036   0x7860             LDRB     R0,[R4, #+1]
   \   00000038   0xB120             CBZ.N    R0,??OSEventPendMulti_5
    374                 *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
   \   0000003A   0x200D             MOVS     R0,#+13
   \                     ??OSEventPendMulti_3: (+1)
   \   0000003C   0x7038             STRB     R0,[R7, #+0]
    375                  return (0);
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    376              }
    377          
    378          /*$PAGE*/
    379              OS_ENTER_CRITICAL();
   \                     ??OSEventPendMulti_5: (+1)
   \   00000044   0x.... 0x....      BL       OS_CPU_SR_Save
    380              events_rdy     =  OS_FALSE;
    381              events_rdy_nbr =  0;
    382              events_stat    =  OS_STAT_RDY;
    383              pevents        =  pevents_pend;
   \   00000048   0x4641             MOV      R1,R8
   \   0000004A   0x4681             MOV      R9,R0
    384              pevent         = *pevents;
   \   0000004C   0x680E             LDR      R6,[R1, #+0]
   \   0000004E   0x2200             MOVS     R2,#+0
   \   00000050   0x2500             MOVS     R5,#+0
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xE00A             B.N      ??OSEventPendMulti_6
    385              while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
    386                  switch (pevent->OSEventType) {
    387          #if (OS_SEM_EN > 0)
    388                      case OS_EVENT_TYPE_SEM:
    389                           if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
    390                               pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
   \                     ??OSEventPendMulti_7: (+1)
   \   00000056   0x1E5A             SUBS     R2,R3,#+1
   \   00000058   0x8132             STRH     R2,[R6, #+8]
    391                              *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
   \   0000005A   0xF84A 0x6B04      STR      R6,[R10], #+4
    392                                events_rdy   =  OS_TRUE;
    393                              *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
   \   0000005E   0x2300             MOVS     R3,#+0
   \   00000060   0x2201             MOVS     R2,#+1
   \   00000062   0xF84B 0x3B04      STR      R3,[R11], #+4
    394                                events_rdy_nbr++;
   \                     ??OSEventPendMulti_8: (+1)
   \   00000066   0x1C6D             ADDS     R5,R5,#+1
    395          
    396                           } else {
    397                                events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
    398                           }
    399                           break;
    400          #endif
    401          
    402          #if (OS_MBOX_EN > 0)
    403                      case OS_EVENT_TYPE_MBOX:
    404                           if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
    405                                                                  /* ... return available message,           ... */
    406                              *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
    407                               pevent->OSEventPtr  = (void *)0;
    408                              *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
    409                                events_rdy         =  OS_TRUE;
    410                                events_rdy_nbr++;
    411          
    412                           } else {
    413                                events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
    414                           }
    415                           break;
    416          #endif
    417          
    418          #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
    419                      case OS_EVENT_TYPE_Q:
    420                           pq = (OS_Q *)pevent->OSEventPtr;
    421                           if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
    422                                                                  /* ... return available message,           ... */
    423                              *pmsgs_rdy++ = (void *)*pq->OSQOut++;
    424                               if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
    425                                   pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
    426                               }
    427                               pq->OSQEntries--;                  /* Update number of queue entries              */
    428                              *pevents_rdy++ = pevent;            /* ... and return available queue event        */
    429                                events_rdy   = OS_TRUE;
    430                                events_rdy_nbr++;
    431          
    432                           } else {
    433                                events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
    434                           }
    435                           break;
    436          #endif
    437          
    438                      case OS_EVENT_TYPE_MUTEX:                                            
    439                      case OS_EVENT_TYPE_FLAG:
    440                      default:           
    441                           OS_EXIT_CRITICAL();
    442                          *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
    443                          *perr        =  OS_ERR_EVENT_TYPE;
    444                           return (events_rdy_nbr);
    445                  }
    446                  pevents++;
    447                  pevent = *pevents;
   \                     ??OSEventPendMulti_9: (+1)
   \   00000068   0xF851 0x6F04      LDR      R6,[R1, #+4]!
   \                     ??OSEventPendMulti_6: (+1)
   \   0000006C   0x2E00             CMP      R6,#+0
   \   0000006E   0xD041             BEQ.N    ??OSEventPendMulti_10
   \   00000070   0x7833             LDRB     R3,[R6, #+0]
   \   00000072   0x2B01             CMP      R3,#+1
   \   00000074   0xD00A             BEQ.N    ??OSEventPendMulti_11
   \   00000076   0xD334             BCC.N    ??OSEventPendMulti_12
   \   00000078   0x2B03             CMP      R3,#+3
   \   0000007A   0xD001             BEQ.N    ??OSEventPendMulti_13
   \   0000007C   0xD313             BCC.N    ??OSEventPendMulti_14
   \   0000007E   0xE030             B.N      ??OSEventPendMulti_12
   \                     ??OSEventPendMulti_13: (+1)
   \   00000080   0x8933             LDRH     R3,[R6, #+8]
   \   00000082   0x2B00             CMP      R3,#+0
   \   00000084   0xD1E7             BNE.N    ??OSEventPendMulti_7
   \   00000086   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000008A   0xE7ED             B.N      ??OSEventPendMulti_9
   \                     ??OSEventPendMulti_11: (+1)
   \   0000008C   0x6873             LDR      R3,[R6, #+4]
   \   0000008E   0xB13B             CBZ.N    R3,??OSEventPendMulti_15
   \   00000090   0xF84B 0x3B04      STR      R3,[R11], #+4
   \   00000094   0x2200             MOVS     R2,#+0
   \   00000096   0x6072             STR      R2,[R6, #+4]
   \   00000098   0xF84A 0x6B04      STR      R6,[R10], #+4
   \   0000009C   0x2201             MOVS     R2,#+1
   \   0000009E   0xE7E2             B.N      ??OSEventPendMulti_8
   \                     ??OSEventPendMulti_15: (+1)
   \   000000A0   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000000A4   0xE7E0             B.N      ??OSEventPendMulti_9
   \                     ??OSEventPendMulti_14: (+1)
   \   000000A6   0x6873             LDR      R3,[R6, #+4]
   \   000000A8   0xF8B3 0xC016      LDRH     R12,[R3, #+22]
   \   000000AC   0xF1BC 0x0F00      CMP      R12,#+0
   \   000000B0   0xD014             BEQ.N    ??OSEventPendMulti_16
   \   000000B2   0xF8D3 0xE010      LDR      LR,[R3, #+16]
   \   000000B6   0xF10E 0x0204      ADD      R2,LR,#+4
   \   000000BA   0xF8DE 0xE000      LDR      LR,[LR, #+0]
   \   000000BE   0xF84B 0xEB04      STR      LR,[R11], #+4
   \   000000C2   0xF8D3 0xE008      LDR      LR,[R3, #+8]
   \   000000C6   0x4572             CMP      R2,LR
   \   000000C8   0xBF08             IT       EQ 
   \   000000CA   0x685A             LDREQ    R2,[R3, #+4]
   \   000000CC   0x611A             STR      R2,[R3, #+16]
   \   000000CE   0xF1AC 0x0201      SUB      R2,R12,#+1
   \   000000D2   0x82DA             STRH     R2,[R3, #+22]
   \   000000D4   0xF84A 0x6B04      STR      R6,[R10], #+4
   \   000000D8   0x2201             MOVS     R2,#+1
   \   000000DA   0xE7C4             B.N      ??OSEventPendMulti_8
   \                     ??OSEventPendMulti_16: (+1)
   \   000000DC   0xF040 0x0004      ORR      R0,R0,#0x4
   \   000000E0   0xE7C2             B.N      ??OSEventPendMulti_9
   \                     ??OSEventPendMulti_12: (+1)
   \   000000E2   0x4648             MOV      R0,R9
   \   000000E4   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   000000EE   0x2001             MOVS     R0,#+1
   \   000000F0   0x7038             STRB     R0,[R7, #+0]
   \   000000F2   0xE073             B.N      ??OSEventPendMulti_17
    448              }
    449          
    450              if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
   \                     ??OSEventPendMulti_10: (+1)
   \   000000F4   0xB142             CBZ.N    R2,??OSEventPendMulti_18
    451                 *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0xF8CA 0x0000      STR      R0,[R10, #+0]
    452                  OS_EXIT_CRITICAL();
   \   000000FC   0x4648             MOV      R0,R9
   \   000000FE   0x.... 0x....      BL       OS_CPU_SR_Restore
    453                 *perr        =  OS_ERR_NONE;
   \   00000102   0x2000             MOVS     R0,#+0
   \   00000104   0x7038             STRB     R0,[R7, #+0]
    454                  return (events_rdy_nbr);
   \   00000106   0xE069             B.N      ??OSEventPendMulti_17
    455              }
    456          /*$PAGE*/
    457                                                                  /* Otherwise, must wait until any event occurs */
    458              OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
    459                                         OS_STAT_MULTI;           /* ... pend on multiple events                 */
   \                     ??OSEventPendMulti_18: (+1)
   \   00000108   0x69A1             LDR      R1,[R4, #+24]
   \   0000010A   0xF891 0x2030      LDRB     R2,[R1, #+48]
   \   0000010E   0xF040 0x0080      ORR      R0,R0,#0x80
   \   00000112   0x4310             ORRS     R0,R0,R2
   \   00000114   0xF881 0x0030      STRB     R0,[R1, #+48]
    460              OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0x69A1             LDR      R1,[R4, #+24]
   \   0000011C   0xF881 0x0031      STRB     R0,[R1, #+49]
    461              OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
   \   00000120   0x69A1             LDR      R1,[R4, #+24]
   \   00000122   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000126   0x85C8             STRH     R0,[R1, #+46]
    462              OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
   \   00000128   0x4640             MOV      R0,R8
   \   0000012A   0x.... 0x....      BL       OS_EventTaskWaitMulti
    463          
    464              OS_EXIT_CRITICAL();
   \   0000012E   0x4648             MOV      R0,R9
   \   00000130   0x.... 0x....      BL       OS_CPU_SR_Restore
    465              OS_Sched();                                         /* Find next highest priority task ready       */
   \   00000134   0x.... 0x....      BL       OS_Sched
    466              OS_ENTER_CRITICAL();
   \   00000138   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000013C   0x4681             MOV      R9,R0
    467          
    468              switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
   \   0000013E   0x69A0             LDR      R0,[R4, #+24]
   \   00000140   0xF100 0x011C      ADD      R1,R0,#+28
   \   00000144   0x7D4A             LDRB     R2,[R1, #+21]
   \   00000146   0x2A00             CMP      R2,#+0
   \   00000148   0xBF18             IT       NE 
   \   0000014A   0x2A02             CMPNE    R2,#+2
   \   0000014C   0xD10D             BNE.N    ??OSEventPendMulti_19
    469                  case OS_STAT_PEND_OK:
    470                  case OS_STAT_PEND_ABORT:
    471                       pevent = OSTCBCur->OSTCBEventPtr;
   \   0000014E   0x680E             LDR      R6,[R1, #+0]
    472                       if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
   \   00000150   0xB136             CBZ.N    R6,??OSEventPendMulti_20
    473                          *pevents_rdy++ =  pevent;               /* ... return available event ...              */
   \   00000152   0xF8CA 0x6000      STR      R6,[R10, #+0]
    474                          *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
   \   00000156   0x2000             MOVS     R0,#+0
   \   00000158   0xF84A 0x0F04      STR      R0,[R10, #+4]!
    475                            events_rdy_nbr++;
   \   0000015C   0x1C6D             ADDS     R5,R5,#+1
   \   0000015E   0xE007             B.N      ??OSEventPendMulti_21
    476          
    477                       } else {                                   /* Else NO event available, handle as timeout  */
    478                           OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
   \                     ??OSEventPendMulti_20: (+1)
   \   00000160   0x2001             MOVS     R0,#+1
   \   00000162   0x7548             STRB     R0,[R1, #+21]
    479                           OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
   \   00000164   0x4641             MOV      R1,R8
   \   00000166   0x69A0             LDR      R0,[R4, #+24]
   \   00000168   0xE000             B.N      ??OSEventPendMulti_22
    480                       }
    481          			 break;
    482          
    483                  case OS_STAT_PEND_TO:                           /* If events timed out, ...                    */
    484                  default:                                        /* ... remove task from events' wait lists     */
    485                       OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
   \                     ??OSEventPendMulti_19: (+1)
   \   0000016A   0x4641             MOV      R1,R8
   \                     ??OSEventPendMulti_22: (+1)
   \   0000016C   0x.... 0x....      BL       OS_EventTaskRemoveMulti
    486                       break;
    487              }
    488          
    489              switch (OSTCBCur->OSTCBStatPend) {
   \                     ??OSEventPendMulti_21: (+1)
   \   00000170   0x69A0             LDR      R0,[R4, #+24]
   \   00000172   0x3024             ADDS     R0,R0,#+36
   \   00000174   0x7B41             LDRB     R1,[R0, #+13]
   \   00000176   0xB111             CBZ.N    R1,??OSEventPendMulti_23
   \   00000178   0x2902             CMP      R1,#+2
   \   0000017A   0xD016             BEQ.N    ??OSEventPendMulti_24
   \   0000017C   0xE01A             B.N      ??OSEventPendMulti_25
    490                  case OS_STAT_PEND_OK:
    491                       switch (pevent->OSEventType) {             /* Return event's message                      */
   \                     ??OSEventPendMulti_23: (+1)
   \   0000017E   0x7831             LDRB     R1,[R6, #+0]
   \   00000180   0x1E49             SUBS     R1,R1,#+1
   \   00000182   0x2901             CMP      R1,#+1
   \   00000184   0xD906             BLS.N    ??OSEventPendMulti_26
   \   00000186   0x1E89             SUBS     R1,R1,#+2
   \   00000188   0xD106             BNE.N    ??OSEventPendMulti_27
    492          #if (OS_SEM_EN > 0)
    493                           case OS_EVENT_TYPE_SEM:
    494                               *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
   \   0000018A   0x2000             MOVS     R0,#+0
   \                     ??OSEventPendMulti_28: (+1)
   \   0000018C   0xF8CB 0x0000      STR      R0,[R11, #+0]
    495                                break;
    496          #endif
    497          
    498          #if ((OS_MBOX_EN > 0) ||                 \
    499              ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
    500                           case OS_EVENT_TYPE_MBOX:
    501                           case OS_EVENT_TYPE_Q:
    502                               *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
    503                                break;
    504          #endif
    505          
    506                           case OS_EVENT_TYPE_MUTEX:                                       
    507                           case OS_EVENT_TYPE_FLAG:
    508                           default:           
    509                                OS_EXIT_CRITICAL();
    510                               *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
    511                               *perr        =  OS_ERR_EVENT_TYPE;
    512                                return (events_rdy_nbr);
    513                       }
    514                      *perr = OS_ERR_NONE;
   \   00000190   0x2000             MOVS     R0,#+0
   \   00000192   0xE013             B.N      ??OSEventPendMulti_29
   \                     ??OSEventPendMulti_26: (+1)
   \   00000194   0x6800             LDR      R0,[R0, #+0]
   \   00000196   0xE7F9             B.N      ??OSEventPendMulti_28
   \                     ??OSEventPendMulti_27: (+1)
   \   00000198   0x4648             MOV      R0,R9
   \   0000019A   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   0000019E   0x2000             MOVS     R0,#+0
   \   000001A0   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   000001A4   0x2001             MOVS     R0,#+1
   \   000001A6   0x7038             STRB     R0,[R7, #+0]
   \   000001A8   0xE018             B.N      ??OSEventPendMulti_17
    515                       break;
    516          
    517                  case OS_STAT_PEND_ABORT:
    518                      *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
   \                     ??OSEventPendMulti_24: (+1)
   \   000001AA   0x2000             MOVS     R0,#+0
   \   000001AC   0xF8CB 0x0000      STR      R0,[R11, #+0]
    519                      *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
   \   000001B0   0x200E             MOVS     R0,#+14
   \   000001B2   0xE003             B.N      ??OSEventPendMulti_29
    520                       break;
    521                                                                  
    522                  case OS_STAT_PEND_TO:                                                
    523                  default:        
    524                      *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
   \                     ??OSEventPendMulti_25: (+1)
   \   000001B4   0x2000             MOVS     R0,#+0
   \   000001B6   0xF8CB 0x0000      STR      R0,[R11, #+0]
    525                      *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
   \   000001BA   0x200A             MOVS     R0,#+10
   \                     ??OSEventPendMulti_29: (+1)
   \   000001BC   0x7038             STRB     R0,[R7, #+0]
    526                       break;
    527              }
    528          
    529              OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
   \   000001BE   0x2000             MOVS     R0,#+0
   \   000001C0   0x69A1             LDR      R1,[R4, #+24]
   \   000001C2   0xF881 0x0030      STRB     R0,[R1, #+48]
    530              OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
   \   000001C6   0x69A1             LDR      R1,[R4, #+24]
   \   000001C8   0xF881 0x0031      STRB     R0,[R1, #+49]
    531              OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
   \   000001CC   0x2100             MOVS     R1,#+0
   \   000001CE   0x69A0             LDR      R0,[R4, #+24]
   \   000001D0   0x61C1             STR      R1,[R0, #+28]
    532              OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
   \   000001D2   0x6201             STR      R1,[R0, #+32]
    533              OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
   \   000001D4   0x6241             STR      R1,[R0, #+36]
    534              OS_EXIT_CRITICAL();
   \   000001D6   0x4648             MOV      R0,R9
   \   000001D8   0x.... 0x....      BL       OS_CPU_SR_Restore
    535          
    536              return (events_rdy_nbr);
   \                     ??OSEventPendMulti_17: (+1)
   \   000001DC   0xB2A8             UXTH     R0,R5
   \   000001DE   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    537          }
    538          #endif
    539          
    540          /*$PAGE*/
    541          /*
    542          *********************************************************************************************************
    543          *                                             INITIALIZATION
    544          *
    545          * Description: This function is used to initialize the internals of uC/OS-II and MUST be called prior to
    546          *              creating any uC/OS-II object and, prior to calling OSStart().
    547          *
    548          * Arguments  : none
    549          *
    550          * Returns    : none
    551          *********************************************************************************************************
    552          */
    553          

   \                                 In section .text, align 2, keep-with-next
    554          void  OSInit (void)
    555          {
   \                     OSInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    556              OSInitHookBegin();                                           /* Call port specific initialization code   */
   \   00000004   0x.... 0x....      BL       OSInitHookBegin
    557          
    558              OS_InitMisc();                                               /* Initialize miscellaneous variables       */
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable17
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x62A0             STR      R0,[R4, #+40]
   \   00000010   0x7020             STRB     R0,[R4, #+0]
   \   00000012   0x7060             STRB     R0,[R4, #+1]
   \   00000014   0x71A0             STRB     R0,[R4, #+6]
   \   00000016   0x7160             STRB     R0,[R4, #+5]
   \   00000018   0x60E0             STR      R0,[R4, #+12]
   \   0000001A   0x6160             STR      R0,[R4, #+20]
    559          
    560              OS_InitRdyList();                                            /* Initialize the Ready List                */
   \   0000001C   0x7120             STRB     R0,[R4, #+4]
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0xF104 0x0008      ADD      R0,R4,#+8
   \   00000024   0x70A1             STRB     R1,[R4, #+2]
   \   00000026   0x6001             STR      R1,[R0, #+0]
   \   00000028   0x70E1             STRB     R1,[R4, #+3]
   \   0000002A   0x6221             STR      R1,[R4, #+32]
   \   0000002C   0x61A1             STR      R1,[R4, #+24]
    561          
    562              OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
   \   0000002E   0xF504 0x755B      ADD      R5,R4,#+876
   \   00000032   0xF240 0x611C      MOVW     R1,#+1564
   \   00000036   0x4628             MOV      R0,R5
   \   00000038   0x.... 0x....      BL       __aeabi_memclr4
   \   0000003C   0x2180             MOVS     R1,#+128
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000042   0x.... 0x....      BL       __aeabi_memclr4
   \   00000046   0x4629             MOV      R1,R5
   \   00000048   0xF504 0x7272      ADD      R2,R4,#+968
   \   0000004C   0x2004             MOVS     R0,#+4
   \                     ??OSInit_0: (+1)
   \   0000004E   0xF101 0x034C      ADD      R3,R1,#+76
   \   00000052   0x614A             STR      R2,[R1, #+20]
   \   00000054   0x263F             MOVS     R6,#+63
   \   00000056   0x701E             STRB     R6,[R3, #+0]
   \   00000058   0x315C             ADDS     R1,R1,#+92
   \   0000005A   0x2600             MOVS     R6,#+0
   \   0000005C   0x705E             STRB     R6,[R3, #+1]
   \   0000005E   0x325C             ADDS     R2,R2,#+92
   \   00000060   0xF101 0x034C      ADD      R3,R1,#+76
   \   00000064   0x614A             STR      R2,[R1, #+20]
   \   00000066   0x263F             MOVS     R6,#+63
   \   00000068   0x701E             STRB     R6,[R3, #+0]
   \   0000006A   0x315C             ADDS     R1,R1,#+92
   \   0000006C   0x2600             MOVS     R6,#+0
   \   0000006E   0x705E             STRB     R6,[R3, #+1]
   \   00000070   0x325C             ADDS     R2,R2,#+92
   \   00000072   0xF101 0x034C      ADD      R3,R1,#+76
   \   00000076   0x614A             STR      R2,[R1, #+20]
   \   00000078   0x263F             MOVS     R6,#+63
   \   0000007A   0x701E             STRB     R6,[R3, #+0]
   \   0000007C   0x315C             ADDS     R1,R1,#+92
   \   0000007E   0x2600             MOVS     R6,#+0
   \   00000080   0x705E             STRB     R6,[R3, #+1]
   \   00000082   0x325C             ADDS     R2,R2,#+92
   \   00000084   0xF101 0x034C      ADD      R3,R1,#+76
   \   00000088   0x614A             STR      R2,[R1, #+20]
   \   0000008A   0x263F             MOVS     R6,#+63
   \   0000008C   0x701E             STRB     R6,[R3, #+0]
   \   0000008E   0x315C             ADDS     R1,R1,#+92
   \   00000090   0x325C             ADDS     R2,R2,#+92
   \   00000092   0x2600             MOVS     R6,#+0
   \   00000094   0x1E40             SUBS     R0,R0,#+1
   \   00000096   0x705E             STRB     R6,[R3, #+1]
   \   00000098   0xD1D9             BNE.N    ??OSInit_0
   \   0000009A   0x6148             STR      R0,[R1, #+20]
   \   0000009C   0xF101 0x004C      ADD      R0,R1,#+76
   \   000000A0   0x213F             MOVS     R1,#+63
   \   000000A2   0x7001             STRB     R1,[R0, #+0]
   \   000000A4   0x7046             STRB     R6,[R0, #+1]
   \   000000A6   0x6266             STR      R6,[R4, #+36]
   \   000000A8   0x61E5             STR      R5,[R4, #+28]
    563          
    564              OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
   \   000000AA   0xF44F 0x71A0      MOV      R1,#+320
   \   000000AE   0xF104 0x002C      ADD      R0,R4,#+44
   \   000000B2   0x.... 0x....      BL       __aeabi_memclr4
   \   000000B6   0xF104 0x002C      ADD      R0,R4,#+44
   \   000000BA   0xF104 0x024C      ADD      R2,R4,#+76
   \   000000BE   0x2103             MOVS     R1,#+3
   \                     ??OSInit_1: (+1)
   \   000000C0   0xF800 0x6B04      STRB     R6,[R0], #+4
   \   000000C4   0xF840 0x2B0B      STR      R2,[R0], #+11
   \   000000C8   0x233F             MOVS     R3,#+63
   \   000000CA   0xF800 0x3B01      STRB     R3,[R0], #+1
   \   000000CE   0xF800 0x6B10      STRB     R6,[R0], #+16
   \   000000D2   0x3220             ADDS     R2,R2,#+32
   \   000000D4   0xF800 0x6B04      STRB     R6,[R0], #+4
   \   000000D8   0xF840 0x2B0B      STR      R2,[R0], #+11
   \   000000DC   0xF800 0x3B01      STRB     R3,[R0], #+1
   \   000000E0   0xF800 0x6B10      STRB     R6,[R0], #+16
   \   000000E4   0x3220             ADDS     R2,R2,#+32
   \   000000E6   0xF800 0x6B04      STRB     R6,[R0], #+4
   \   000000EA   0xF840 0x2B0B      STR      R2,[R0], #+11
   \   000000EE   0xF800 0x3B01      STRB     R3,[R0], #+1
   \   000000F2   0x3220             ADDS     R2,R2,#+32
   \   000000F4   0x1E49             SUBS     R1,R1,#+1
   \   000000F6   0xF800 0x6B10      STRB     R6,[R0], #+16
   \   000000FA   0xD1E1             BNE.N    ??OSInit_1
   \   000000FC   0x7001             STRB     R1,[R0, #+0]
   \   000000FE   0x6041             STR      R1,[R0, #+4]
   \   00000100   0x7406             STRB     R6,[R0, #+16]
   \   00000102   0x213F             MOVS     R1,#+63
   \   00000104   0x73C1             STRB     R1,[R0, #+15]
   \   00000106   0xF104 0x002C      ADD      R0,R4,#+44
   \   0000010A   0x6120             STR      R0,[R4, #+16]
    565          
    566          #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    567              OS_FlagInit();                                               /* Initialize the event flag structures     */
   \   0000010C   0x.... 0x....      BL       OS_FlagInit
    568          #endif
    569          
    570          #if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    571              OS_MemInit();                                                /* Initialize the memory manager            */
   \   00000110   0x.... 0x....      BL       OS_MemInit
    572          #endif
    573          
    574          #if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    575              OS_QInit();                                                  /* Initialize the message queue structures  */
   \   00000114   0x.... 0x....      BL       OS_QInit
    576          #endif
    577          
    578              OS_InitTaskIdle();                                           /* Create the Idle Task                     */
   \   00000118   0x2003             MOVS     R0,#+3
   \   0000011A   0x9004             STR      R0,[SP, #+16]
   \   0000011C   0x9603             STR      R6,[SP, #+12]
   \   0000011E   0x2080             MOVS     R0,#+128
   \   00000120   0x9002             STR      R0,[SP, #+8]
   \   00000122   0x231F             MOVS     R3,#+31
   \   00000124   0xF504 0x70B6      ADD      R0,R4,#+364
   \   00000128   0x9001             STR      R0,[SP, #+4]
   \   0000012A   0xF504 0x725A      ADD      R2,R4,#+872
   \   0000012E   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000132   0x9000             STR      R0,[SP, #+0]
   \   00000134   0x2100             MOVS     R1,#+0
   \   00000136   0x.... 0x....      ADR.W    R0,OS_TaskIdle
   \   0000013A   0x.... 0x....      BL       OSTaskCreateExt
   \   0000013E   0xAA05             ADD      R2,SP,#+20
   \   00000140   0x.... 0x....      ADR.W    R1,?_0
   \   00000144   0x201F             MOVS     R0,#+31
   \   00000146   0x.... 0x....      BL       OSTaskNameSet
    579          #if OS_TASK_STAT_EN > 0
    580              OS_InitTaskStat();                                           /* Create the Statistic Task                */
    581          #endif
    582          
    583          #if OS_TMR_EN > 0
    584              OSTmr_Init();                                                /* Initialize the Timer Manager             */
    585          #endif
    586          
    587              OSInitHookEnd();                                             /* Call port specific init. code            */
   \   0000014A   0x.... 0x....      BL       OSInitHookEnd
    588          
    589          #if OS_DEBUG_EN > 0
    590              OSDebugInit();
   \   0000014E   0x.... 0x....      BL       OSDebugInit
    591          #endif
    592          }
   \   00000152   0xB006             ADD      SP,SP,#+24
   \   00000154   0xBD70             POP      {R4-R6,PC}       ;; return
    593          /*$PAGE*/
    594          /*
    595          *********************************************************************************************************
    596          *                                              ENTER ISR
    597          *
    598          * Description: This function is used to notify uC/OS-II that you are about to service an interrupt
    599          *              service routine (ISR).  This allows uC/OS-II to keep track of interrupt nesting and thus
    600          *              only perform rescheduling at the last nested ISR.
    601          *
    602          * Arguments  : none
    603          *
    604          * Returns    : none
    605          *
    606          * Notes      : 1) This function should be called ith interrupts already disabled
    607          *              2) Your ISR can directly increment OSIntNesting without calling this function because
    608          *                 OSIntNesting has been declared 'global'.
    609          *              3) You MUST still call OSIntExit() even though you increment OSIntNesting directly.
    610          *              4) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
    611          *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
    612          *                 end of the ISR.
    613          *              5) You are allowed to nest interrupts up to 255 levels deep.
    614          *              6) I removed the OS_ENTER_CRITICAL() and OS_EXIT_CRITICAL() around the increment because
    615          *                 OSIntEnter() is always called with interrupts disabled.
    616          *********************************************************************************************************
    617          */
    618          

   \                                 In section .text, align 2, keep-with-next
    619          void  OSIntEnter (void)
    620          {
    621              if (OSRunning == OS_TRUE) {
   \                     OSIntEnter: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000004   0x7941             LDRB     R1,[R0, #+5]
   \   00000006   0x2901             CMP      R1,#+1
   \   00000008   0xD104             BNE.N    ??OSIntEnter_0
    622                  if (OSIntNesting < 255u) {
   \   0000000A   0x7801             LDRB     R1,[R0, #+0]
   \   0000000C   0x29FF             CMP      R1,#+255
   \   0000000E   0xBF1C             ITT      NE 
   \   00000010   0x1C49             ADDNE    R1,R1,#+1
   \   00000012   0x7001             STRBNE   R1,[R0, #+0]
    623                      OSIntNesting++;                      /* Increment ISR nesting level                        */
    624                  }
    625              }
    626          }
   \                     ??OSIntEnter_0: (+1)
   \   00000014   0x4770             BX       LR               ;; return
    627          /*$PAGE*/
    628          /*
    629          *********************************************************************************************************
    630          *                                               EXIT ISR
    631          *
    632          * Description: This function is used to notify uC/OS-II that you have completed serviving an ISR.  When
    633          *              the last nested ISR has completed, uC/OS-II will call the scheduler to determine whether
    634          *              a new, high-priority task, is ready to run.
    635          *
    636          * Arguments  : none
    637          *
    638          * Returns    : none
    639          *
    640          * Notes      : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
    641          *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
    642          *                 end of the ISR.
    643          *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
    644          *********************************************************************************************************
    645          */
    646          

   \                                 In section .text, align 2, keep-with-next
    647          void  OSIntExit (void)
    648          {
   \                     OSIntExit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    649          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    650              OS_CPU_SR  cpu_sr = 0;
    651          #endif
    652          
    653          
    654          
    655              if (OSRunning == OS_TRUE) {
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable17
   \   00000006   0x7960             LDRB     R0,[R4, #+5]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD12A             BNE.N    ??OSIntExit_0
    656                  OS_ENTER_CRITICAL();
   \   0000000C   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000010   0x4605             MOV      R5,R0
    657                  if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
   \   00000012   0x7820             LDRB     R0,[R4, #+0]
   \   00000014   0xB108             CBZ.N    R0,??OSIntExit_1
    658                      OSIntNesting--;
   \   00000016   0x1E40             SUBS     R0,R0,#+1
   \   00000018   0x7020             STRB     R0,[R4, #+0]
    659                  }
    660                  if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
    661                      if (OSLockNesting == 0) {                      /* ... and not locked.                      */
   \                     ??OSIntExit_1: (+1)
   \   0000001A   0x7820             LDRB     R0,[R4, #+0]
   \   0000001C   0x7861             LDRB     R1,[R4, #+1]
   \   0000001E   0x4308             ORRS     R0,R1,R0
   \   00000020   0xD11A             BNE.N    ??OSIntExit_2
    662                          OS_SchedNew();
   \   00000022   0x7921             LDRB     R1,[R4, #+4]
   \   00000024   0x.... 0x....      ADR.W    R0,OSUnMapTbl
   \   00000028   0x5C09             LDRB     R1,[R1, R0]
   \   0000002A   0x190A             ADDS     R2,R1,R4
   \   0000002C   0x7A12             LDRB     R2,[R2, #+8]
   \   0000002E   0x5C10             LDRB     R0,[R2, R0]
   \   00000030   0xEB00 0x00C1      ADD      R0,R0,R1, LSL #+3
   \   00000034   0x70E0             STRB     R0,[R4, #+3]
    663                          if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
   \   00000036   0x78A1             LDRB     R1,[R4, #+2]
   \   00000038   0x78E0             LDRB     R0,[R4, #+3]
   \   0000003A   0x4288             CMP      R0,R1
   \   0000003C   0xD00C             BEQ.N    ??OSIntExit_2
    664                              OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable17_1
   \   00000042   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000046   0x6220             STR      R0,[R4, #+32]
    665          #if OS_TASK_PROFILE_EN > 0
    666                              OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
   \   00000048   0x6B81             LDR      R1,[R0, #+56]
   \   0000004A   0x1C49             ADDS     R1,R1,#+1
   \   0000004C   0x6381             STR      R1,[R0, #+56]
    667          #endif
    668                              OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
   \   0000004E   0x68E0             LDR      R0,[R4, #+12]
   \   00000050   0x1C40             ADDS     R0,R0,#+1
   \   00000052   0x60E0             STR      R0,[R4, #+12]
    669                              OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
   \   00000054   0x.... 0x....      BL       OSIntCtxSw
    670                          }
    671                      }
    672                  }
    673                  OS_EXIT_CRITICAL();
   \                     ??OSIntExit_2: (+1)
   \   00000058   0x4628             MOV      R0,R5
   \   0000005A   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000005E   0x.... 0x....      B.W      OS_CPU_SR_Restore
    674              }
    675          }
   \                     ??OSIntExit_0: (+1)
   \   00000062   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    676          /*$PAGE*/
    677          /*
    678          *********************************************************************************************************
    679          *                                          PREVENT SCHEDULING
    680          *
    681          * Description: This function is used to prevent rescheduling to take place.  This allows your application
    682          *              to prevent context switches until you are ready to permit context switching.
    683          *
    684          * Arguments  : none
    685          *
    686          * Returns    : none
    687          *
    688          * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
    689          *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
    690          *********************************************************************************************************
    691          */
    692          
    693          #if OS_SCHED_LOCK_EN > 0

   \                                 In section .text, align 2, keep-with-next
    694          void  OSSchedLock (void)
    695          {
   \                     OSSchedLock: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    696          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    697              OS_CPU_SR  cpu_sr = 0;
    698          #endif
    699          
    700          
    701          
    702              if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable17
   \   00000006   0x7960             LDRB     R0,[R4, #+5]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD109             BNE.N    ??OSSchedLock_0
    703                  OS_ENTER_CRITICAL();
   \   0000000C   0x.... 0x....      BL       OS_CPU_SR_Save
    704                  if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
   \   00000010   0x7821             LDRB     R1,[R4, #+0]
   \   00000012   0xB921             CBNZ.N   R1,??OSSchedLock_1
    705                      if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
   \   00000014   0x7861             LDRB     R1,[R4, #+1]
   \   00000016   0x29FF             CMP      R1,#+255
   \   00000018   0xBF1C             ITT      NE 
   \   0000001A   0x1C49             ADDNE    R1,R1,#+1
   \   0000001C   0x7061             STRBNE   R1,[R4, #+1]
    706                          OSLockNesting++;                 /* Increment lock nesting level                       */
    707                      }
    708                  }
    709                  OS_EXIT_CRITICAL();
   \                     ??OSSchedLock_1: (+1)
   \   0000001E   0x....             B.N      ?Subroutine0
    710              }
    711          }
   \                     ??OSSchedLock_0: (+1)
   \   00000020   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xE8BD 0x4010      POP      {R4,LR}
   \   00000004   0x.... 0x....      B.W      OS_CPU_SR_Restore
    712          #endif
    713          
    714          /*$PAGE*/
    715          /*
    716          *********************************************************************************************************
    717          *                                          ENABLE SCHEDULING
    718          *
    719          * Description: This function is used to re-allow rescheduling.
    720          *
    721          * Arguments  : none
    722          *
    723          * Returns    : none
    724          *
    725          * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
    726          *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
    727          *********************************************************************************************************
    728          */
    729          
    730          #if OS_SCHED_LOCK_EN > 0

   \                                 In section .text, align 2, keep-with-next
    731          void  OSSchedUnlock (void)
    732          {
   \                     OSSchedUnlock: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    733          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    734              OS_CPU_SR  cpu_sr = 0;
    735          #endif
    736          
    737          
    738          
    739              if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable17
   \   00000006   0x7960             LDRB     R0,[R4, #+5]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD111             BNE.N    ??OSSchedUnlock_0
    740                  OS_ENTER_CRITICAL();
   \   0000000C   0x.... 0x....      BL       OS_CPU_SR_Save
    741                  if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
   \   00000010   0x7861             LDRB     R1,[R4, #+1]
   \   00000012   0xB161             CBZ.N    R1,??OSSchedUnlock_1
    742                      OSLockNesting--;                               /* Decrement lock nesting level             */
   \   00000014   0x1E49             SUBS     R1,R1,#+1
   \   00000016   0x7061             STRB     R1,[R4, #+1]
    743                      if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
   \   00000018   0xB2C9             UXTB     R1,R1
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xBF04             ITT      EQ 
   \   0000001E   0x7821             LDRBEQ   R1,[R4, #+0]
   \   00000020   0x2900             CMPEQ    R1,#+0
    744                          if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
   \   00000022   0xD104             BNE.N    ??OSSchedUnlock_1
    745                              OS_EXIT_CRITICAL();
   \   00000024   0x.... 0x....      BL       OS_CPU_SR_Restore
    746                              OS_Sched();                            /* See if a HPT is ready                    */
   \   00000028   0xE8BD 0x4010      POP      {R4,LR}
   \   0000002C   0x....             B.N      OS_Sched
    747                          } else {
    748                              OS_EXIT_CRITICAL();
    749                          }
    750                      } else {
    751                          OS_EXIT_CRITICAL();
    752                      }
    753                  } else {
    754                      OS_EXIT_CRITICAL();
   \                     ??OSSchedUnlock_1: (+1)
   \   0000002E   0x....             B.N      ?Subroutine0
    755                  }
    756              }
    757          }
   \                     ??OSSchedUnlock_0: (+1)
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    758          #endif
    759          
    760          /*$PAGE*/
    761          /*
    762          *********************************************************************************************************
    763          *                                          START MULTITASKING
    764          *
    765          * Description: This function is used to start the multitasking process which lets uC/OS-II manages the
    766          *              task that you have created.  Before you can call OSStart(), you MUST have called OSInit()
    767          *              and you MUST have created at least one task.
    768          *
    769          * Arguments  : none
    770          *
    771          * Returns    : none
    772          *
    773          * Note       : OSStartHighRdy() MUST:
    774          *                 a) Call OSTaskSwHook() then,
    775          *                 b) Set OSRunning to OS_TRUE.
    776          *                 c) Load the context of the task pointed to by OSTCBHighRdy.
    777          *                 d_ Execute the task.
    778          *********************************************************************************************************
    779          */
    780          

   \                                 In section .text, align 2, keep-with-next
    781          void  OSStart (void)
    782          {
    783              if (OSRunning == OS_FALSE) {
   \                     OSStart: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000004   0x7941             LDRB     R1,[R0, #+5]
   \   00000006   0xB999             CBNZ.N   R1,??OSStart_0
    784                  OS_SchedNew();                               /* Find highest priority's task priority number   */
   \   00000008   0x7902             LDRB     R2,[R0, #+4]
   \   0000000A   0x.... 0x....      ADR.W    R1,OSUnMapTbl
   \   0000000E   0x5C52             LDRB     R2,[R2, R1]
   \   00000010   0x1813             ADDS     R3,R2,R0
   \   00000012   0x7A1B             LDRB     R3,[R3, #+8]
   \   00000014   0x5C59             LDRB     R1,[R3, R1]
   \   00000016   0xEB01 0x01C2      ADD      R1,R1,R2, LSL #+3
   \   0000001A   0x70C1             STRB     R1,[R0, #+3]
    785                  OSPrioCur     = OSPrioHighRdy;
    786                  OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
   \   0000001C   0x.... 0x....      LDR.W    R2,??DataTable17_1
   \   00000020   0x78C1             LDRB     R1,[R0, #+3]
   \   00000022   0x7081             STRB     R1,[R0, #+2]
   \   00000024   0xF852 0x1021      LDR      R1,[R2, R1, LSL #+2]
   \   00000028   0x6201             STR      R1,[R0, #+32]
    787                  OSTCBCur      = OSTCBHighRdy;
   \   0000002A   0x6181             STR      R1,[R0, #+24]
    788                  OSStartHighRdy();                            /* Execute target specific code to start task     */
   \   0000002C   0x.... 0x....      B.W      OSStartHighRdy
    789              }
    790          }
   \                     ??OSStart_0: (+1)
   \   00000030   0x4770             BX       LR               ;; return
    791          /*$PAGE*/
    792          /*
    793          *********************************************************************************************************
    794          *                                        STATISTICS INITIALIZATION
    795          *
    796          * Description: This function is called by your application to establish CPU usage by first determining
    797          *              how high a 32-bit counter would count to in 1 second if no other tasks were to execute
    798          *              during that time.  CPU usage is then determined by a low priority task which keeps track
    799          *              of this 32-bit counter every second but this time, with other tasks running.  CPU usage is
    800          *              determined by:
    801          *
    802          *                                             OSIdleCtr
    803          *                 CPU Usage (%) = 100 * (1 - ------------)
    804          *                                            OSIdleCtrMax
    805          *
    806          * Arguments  : none
    807          *
    808          * Returns    : none
    809          *********************************************************************************************************
    810          */
    811          
    812          #if OS_TASK_STAT_EN > 0
    813          void  OSStatInit (void)
    814          {
    815          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    816              OS_CPU_SR  cpu_sr = 0;
    817          #endif
    818          
    819          
    820          
    821              OSTimeDly(2);                                /* Synchronize with clock tick                        */
    822              OS_ENTER_CRITICAL();
    823              OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
    824              OS_EXIT_CRITICAL();
    825              OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
    826              OS_ENTER_CRITICAL();
    827              OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
    828              OSStatRdy    = OS_TRUE;
    829              OS_EXIT_CRITICAL();
    830          }
    831          #endif
    832          /*$PAGE*/
    833          /*
    834          *********************************************************************************************************
    835          *                                         PROCESS SYSTEM TICK
    836          *
    837          * Description: This function is used to signal to uC/OS-II the occurrence of a 'system tick' (also known
    838          *              as a 'clock tick').  This function should be called by the ticker ISR but, can also be
    839          *              called by a high priority task.
    840          *
    841          * Arguments  : none
    842          *
    843          * Returns    : none
    844          *********************************************************************************************************
    845          */
    846          

   \                                 In section .text, align 2, keep-with-next
    847          void  OSTimeTick (void)
    848          {
   \                     OSTimeTick: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    849              OS_TCB    *ptcb;
    850          #if OS_TICK_STEP_EN > 0
    851              BOOLEAN    step;
    852          #endif
    853          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    854              OS_CPU_SR  cpu_sr = 0;
    855          #endif
    856          
    857          
    858          
    859          #if OS_TIME_TICK_HOOK_EN > 0
    860              OSTimeTickHook();                                      /* Call user definable hook                     */
   \   00000002   0x.... 0x....      BL       OSTimeTickHook
    861          #endif
    862          #if OS_TIME_GET_SET_EN > 0
    863              OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
   \   00000006   0x.... 0x....      BL       OS_CPU_SR_Save
    864              OSTime++;
   \   0000000A   0x.... 0x....      LDR.W    R4,??DataTable17
   \   0000000E   0x6AA1             LDR      R1,[R4, #+40]
   \   00000010   0x1C49             ADDS     R1,R1,#+1
   \   00000012   0x62A1             STR      R1,[R4, #+40]
    865              OS_EXIT_CRITICAL();
   \   00000014   0x.... 0x....      BL       OS_CPU_SR_Restore
    866          #endif
    867              if (OSRunning == OS_TRUE) {
   \   00000018   0x7960             LDRB     R0,[R4, #+5]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD137             BNE.N    ??OSTimeTick_0
    868          #if OS_TICK_STEP_EN > 0
    869                  switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
   \   0000001E   0x79E0             LDRB     R0,[R4, #+7]
   \   00000020   0xB138             CBZ.N    R0,??OSTimeTick_1
   \   00000022   0x2802             CMP      R0,#+2
   \   00000024   0xD001             BEQ.N    ??OSTimeTick_2
   \   00000026   0xD332             BCC.N    ??OSTimeTick_0
   \   00000028   0xE001             B.N      ??OSTimeTick_3
    870                      case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
    871                           step = OS_TRUE;
    872                           break;
    873          
    874                      case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
    875                           step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
    876                           break;
    877          
    878                      case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
    879                           step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
    880                           OSTickStepState = OS_TICK_STEP_WAIT;
   \                     ??OSTimeTick_2: (+1)
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xE000             B.N      ??OSTimeTick_4
    881                           break;
    882          
    883                      default:                                       /* Invalid case, correct situation              */
    884                           step            = OS_TRUE;
    885                           OSTickStepState = OS_TICK_STEP_DIS;
   \                     ??OSTimeTick_3: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \                     ??OSTimeTick_4: (+1)
   \   00000030   0x71E0             STRB     R0,[R4, #+7]
    886                           break;
    887                  }
    888                  if (step == OS_FALSE) {                            /* Return if waiting for step command           */
    889                      return;
    890                  }
    891          #endif
    892                  ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
   \                     ??OSTimeTick_1: (+1)
   \   00000032   0x6A66             LDR      R6,[R4, #+36]
   \   00000034   0xE012             B.N      ??OSTimeTick_5
    893                  while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
    894                      OS_ENTER_CRITICAL();
    895                      if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
    896                          if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
    897                                                                     /* Check for timeout                            */
    898                              if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
    899                                  ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
    900                                  ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
    901                              } else {
    902                                  ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
   \                     ??OSTimeTick_6: (+1)
   \   00000036   0x7769             STRB     R1,[R5, #+29]
    903                              }
    904          
    905                              if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
   \   00000038   0x7F29             LDRB     R1,[R5, #+28]
   \   0000003A   0x0709             LSLS     R1,R1,#+28
   \   0000003C   0xD40B             BMI.N    ??OSTimeTick_7
    906                                  OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
   \   0000003E   0xF106 0x0134      ADD      R1,R6,#+52
   \   00000042   0x7922             LDRB     R2,[R4, #+4]
   \   00000044   0x788B             LDRB     R3,[R1, #+2]
   \   00000046   0x431A             ORRS     R2,R3,R2
   \   00000048   0x7122             STRB     R2,[R4, #+4]
    907                                  OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   0000004A   0x780A             LDRB     R2,[R1, #+0]
   \   0000004C   0x7849             LDRB     R1,[R1, #+1]
   \   0000004E   0x1912             ADDS     R2,R2,R4
   \   00000050   0x7A13             LDRB     R3,[R2, #+8]
   \   00000052   0x4319             ORRS     R1,R1,R3
   \   00000054   0x7211             STRB     R1,[R2, #+8]
    908                              }
    909                          }
    910                      }
    911                      ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
   \                     ??OSTimeTick_7: (+1)
   \   00000056   0x682E             LDR      R6,[R5, #+0]
    912                      OS_EXIT_CRITICAL();
   \   00000058   0x.... 0x....      BL       OS_CPU_SR_Restore
   \                     ??OSTimeTick_5: (+1)
   \   0000005C   0xF106 0x0514      ADD      R5,R6,#+20
   \   00000060   0x7FA8             LDRB     R0,[R5, #+30]
   \   00000062   0x281F             CMP      R0,#+31
   \   00000064   0xD013             BEQ.N    ??OSTimeTick_0
   \   00000066   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000006A   0x8B69             LDRH     R1,[R5, #+26]
   \   0000006C   0x2900             CMP      R1,#+0
   \   0000006E   0xD0F2             BEQ.N    ??OSTimeTick_7
   \   00000070   0x1E49             SUBS     R1,R1,#+1
   \   00000072   0x8369             STRH     R1,[R5, #+26]
   \   00000074   0xB289             UXTH     R1,R1
   \   00000076   0x2900             CMP      R1,#+0
   \   00000078   0xD1ED             BNE.N    ??OSTimeTick_7
   \   0000007A   0x7F29             LDRB     R1,[R5, #+28]
   \   0000007C   0x2237             MOVS     R2,#+55
   \   0000007E   0x4211             TST      R1,R2
   \   00000080   0xBF1D             ITTTE    NE 
   \   00000082   0xF001 0x01C8      ANDNE    R1,R1,#0xC8
   \   00000086   0x7729             STRBNE   R1,[R5, #+28]
   \   00000088   0x2101             MOVNE    R1,#+1
   \   0000008A   0x2100             MOVEQ    R1,#+0
   \   0000008C   0xE7D3             B.N      ??OSTimeTick_6
    913                  }
    914              }
    915          }
   \                     ??OSTimeTick_0: (+1)
   \   0000008E   0xBD70             POP      {R4-R6,PC}       ;; return
    916          
    917          /*$PAGE*/
    918          /*
    919          *********************************************************************************************************
    920          *                                             GET VERSION
    921          *
    922          * Description: This function is used to return the version number of uC/OS-II.  The returned value
    923          *              corresponds to uC/OS-II's version number multiplied by 100.  In other words, version 2.00
    924          *              would be returned as 200.
    925          *
    926          * Arguments  : none
    927          *
    928          * Returns    : the version number of uC/OS-II multiplied by 100.
    929          *********************************************************************************************************
    930          */
    931          

   \                                 In section .text, align 2, keep-with-next
    932          INT16U  OSVersion (void)
    933          {
    934              return (OS_VERSION);
   \                     OSVersion: (+1)
   \   00000000   0xF44F 0x708F      MOV      R0,#+286
   \   00000004   0x4770             BX       LR               ;; return
    935          }
    936          
    937          /*$PAGE*/
    938          /*
    939          *********************************************************************************************************
    940          *                                            DUMMY FUNCTION
    941          *
    942          * Description: This function doesn't do anything.  It is called by OSTaskDel().
    943          *
    944          * Arguments  : none
    945          *
    946          * Returns    : none
    947          *********************************************************************************************************
    948          */
    949          
    950          #if OS_TASK_DEL_EN > 0

   \                                 In section .text, align 2, keep-with-next
    951          void  OS_Dummy (void)
    952          {
    953          }
   \                     OS_Dummy: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    954          #endif
    955          
    956          /*$PAGE*/
    957          /*
    958          *********************************************************************************************************
    959          *                             MAKE TASK READY TO RUN BASED ON EVENT OCCURING
    960          *
    961          * Description: This function is called by other uC/OS-II services and is used to ready a task that was
    962          *              waiting for an event to occur.
    963          *
    964          * Arguments  : pevent      is a pointer to the event control block corresponding to the event.
    965          *
    966          *              pmsg        is a pointer to a message.  This pointer is used by message oriented services
    967          *                          such as MAILBOXEs and QUEUEs.  The pointer is not used when called by other
    968          *                          service functions.
    969          *
    970          *              msk         is a mask that is used to clear the status byte of the TCB.  For example,
    971          *                          OSSemPost() will pass OS_STAT_SEM, OSMboxPost() will pass OS_STAT_MBOX etc.
    972          *
    973          *              pend_stat   is used to indicate the readied task's pending status:
    974          *
    975          *                          OS_STAT_PEND_OK      Task ready due to a post (or delete), not a timeout or
    976          *                                               an abort.
    977          *                          OS_STAT_PEND_ABORT   Task ready due to an abort.
    978          *
    979          * Returns    : none
    980          *
    981          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
    982          *********************************************************************************************************
    983          */
    984          #if (OS_EVENT_EN)

   \                                 In section .text, align 2, keep-with-next
    985          INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
    986          {
   \                     OS_EventTaskRdy: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    987              OS_TCB  *ptcb;
    988              INT8U    y;
    989              INT8U    x;
    990              INT8U    prio;
    991          #if OS_LOWEST_PRIO > 63
    992              INT16U  *ptbl;
    993          #endif
    994          
    995          
    996          #if OS_LOWEST_PRIO <= 63
    997              y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
   \   00000004   0x.... 0x....      ADR.W    R5,OSUnMapTbl
   \   00000008   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000000A   0x5D40             LDRB     R0,[R0, R5]
    998              x    = OSUnMapTbl[pevent->OSEventTbl[y]];
    999              prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
   \   0000000C   0x1906             ADDS     R6,R0,R4
   1000          #else
   1001              if ((pevent->OSEventGrp & 0xFF) != 0) {             /* Find HPT waiting for message                */
   1002                  y = OSUnMapTbl[ pevent->OSEventGrp & 0xFF];
   1003              } else {
   1004                  y = OSUnMapTbl[(pevent->OSEventGrp >> 8) & 0xFF] + 8;
   1005              }
   1006              ptbl = &pevent->OSEventTbl[y];
   1007              if ((*ptbl & 0xFF) != 0) {
   1008                  x = OSUnMapTbl[*ptbl & 0xFF];
   1009              } else {
   1010                  x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
   1011              }
   1012              prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
   1013          #endif
   1014          
   1015              ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
   1016              ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
   \   0000000E   0xF04F 0x0C00      MOV      R12,#+0
   \   00000012   0x7AF6             LDRB     R6,[R6, #+11]
   \   00000014   0x5D75             LDRB     R5,[R6, R5]
   \   00000016   0x....             LDR.N    R6,??DataTable17_1
   \   00000018   0xEB05 0x05C0      ADD      R5,R5,R0, LSL #+3
   \   0000001C   0xB2ED             UXTB     R5,R5
   \   0000001E   0xF856 0x6025      LDR      R6,[R6, R5, LSL #+2]
   \   00000022   0xF106 0x071C      ADD      R7,R6,#+28
   1017          #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
   1018              ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
   \   00000026   0x60B9             STR      R1,[R7, #+8]
   \   00000028   0xF8A7 0xC012      STRH     R12,[R7, #+18]
   1019          #else
   1020              pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
   1021          #endif
   1022              ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
   1023              ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
   \   0000002C   0x757B             STRB     R3,[R7, #+21]
   \   0000002E   0x7D39             LDRB     R1,[R7, #+20]
   \   00000030   0x4391             BICS     R1,R1,R2
   \   00000032   0x7539             STRB     R1,[R7, #+20]
   1024                                                                  /* See if task is ready (could be susp'd)      */
   1025              if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
   \   00000034   0x7D39             LDRB     R1,[R7, #+20]
   \   00000036   0x0709             LSLS     R1,R1,#+28
   \   00000038   0xD409             BMI.N    ??OS_EventTaskRdy_0
   1026                  OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
   \   0000003A   0x....             LDR.N    R1,??DataTable17
   \   0000003C   0x7EBB             LDRB     R3,[R7, #+26]
   \   0000003E   0x790A             LDRB     R2,[R1, #+4]
   \   00000040   0x431A             ORRS     R2,R3,R2
   1027                  OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
   \   00000042   0x1840             ADDS     R0,R0,R1
   \   00000044   0x710A             STRB     R2,[R1, #+4]
   \   00000046   0x7A01             LDRB     R1,[R0, #+8]
   \   00000048   0x7E7A             LDRB     R2,[R7, #+25]
   \   0000004A   0x4311             ORRS     R1,R2,R1
   \   0000004C   0x7201             STRB     R1,[R0, #+8]
   1028              }
   1029          
   1030              OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
   \                     ??OS_EventTaskRdy_0: (+1)
   \   0000004E   0x4621             MOV      R1,R4
   \   00000050   0x4630             MOV      R0,R6
   \   00000052   0x.... 0x....      BL       OS_EventTaskRemove
   1031          #if (OS_EVENT_MULTI_EN > 0)
   1032              if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
   \   00000056   0x6879             LDR      R1,[R7, #+4]
   \   00000058   0xB119             CBZ.N    R1,??OS_EventTaskRdy_1
   1033                  OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
   \   0000005A   0x4630             MOV      R0,R6
   \   0000005C   0x.... 0x....      BL       OS_EventTaskRemoveMulti
   1034                  ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
   \   00000060   0x603C             STR      R4,[R7, #+0]
   1035              }
   1036          #endif
   1037          
   1038              return (prio);
   \                     ??OS_EventTaskRdy_1: (+1)
   \   00000062   0x4628             MOV      R0,R5
   \   00000064   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1039          }
   1040          #endif
   1041          /*$PAGE*/
   1042          /*
   1043          *********************************************************************************************************
   1044          *                                   MAKE TASK WAIT FOR EVENT TO OCCUR
   1045          *
   1046          * Description: This function is called by other uC/OS-II services to suspend a task because an event has
   1047          *              not occurred.
   1048          *
   1049          * Arguments  : pevent   is a pointer to the event control block for which the task will be waiting for.
   1050          *
   1051          * Returns    : none
   1052          *
   1053          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1054          *********************************************************************************************************
   1055          */
   1056          #if (OS_EVENT_EN)

   \                                 In section .text, align 2, keep-with-next
   1057          void  OS_EventTaskWait (OS_EVENT *pevent)
   1058          {
   1059              INT8U  y;
   1060          
   1061          
   1062              OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
   \                     OS_EventTaskWait: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable17
   \   00000002   0x698A             LDR      R2,[R1, #+24]
   \   00000004   0xF842 0x0F1C      STR      R0,[R2, #+28]!
   1063          
   1064              pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
   \   00000008   0x7E13             LDRB     R3,[R2, #+24]
   \   0000000A   0x7E52             LDRB     R2,[R2, #+25]
   \   0000000C   0x181B             ADDS     R3,R3,R0
   \   0000000E   0xF893 0xC00B      LDRB     R12,[R3, #+11]
   \   00000012   0xEA42 0x020C      ORR      R2,R2,R12
   \   00000016   0x72DA             STRB     R2,[R3, #+11]
   1065              pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
   \   00000018   0x698B             LDR      R3,[R1, #+24]
   \   0000001A   0x7A82             LDRB     R2,[R0, #+10]
   \   0000001C   0xF893 0x3036      LDRB     R3,[R3, #+54]
   \   00000020   0x431A             ORRS     R2,R3,R2
   \   00000022   0x7282             STRB     R2,[R0, #+10]
   1066          
   1067              y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
   \   00000024   0x6988             LDR      R0,[R1, #+24]
   \   00000026   0xF810 0x2F34      LDRB     R2,[R0, #+52]!
   1068              OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
   \   0000002A   0xF890 0xC001      LDRB     R12,[R0, #+1]
   \   0000002E   0x1852             ADDS     R2,R2,R1
   \   00000030   0x7A13             LDRB     R3,[R2, #+8]
   \   00000032   0xEA33 0x030C      BICS     R3,R3,R12
   \   00000036   0x7213             STRB     R3,[R2, #+8]
   1069              if (OSRdyTbl[y] == 0) {
   \   00000038   0xD104             BNE.N    ??OS_EventTaskWait_0
   1070                  OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
   \   0000003A   0x790A             LDRB     R2,[R1, #+4]
   \   0000003C   0x7880             LDRB     R0,[R0, #+2]
   \   0000003E   0xEA22 0x0000      BIC      R0,R2,R0
   \   00000042   0x7108             STRB     R0,[R1, #+4]
   1071              }
   1072          }
   \                     ??OS_EventTaskWait_0: (+1)
   \   00000044   0x4770             BX       LR               ;; return
   1073          #endif
   1074          /*$PAGE*/
   1075          /*
   1076          *********************************************************************************************************
   1077          *                          MAKE TASK WAIT FOR ANY OF MULTIPLE EVENTS TO OCCUR
   1078          *
   1079          * Description: This function is called by other uC/OS-II services to suspend a task because any one of
   1080          *              multiple events has not occurred.
   1081          *
   1082          * Arguments  : pevents_wait     is a pointer to an array of event control blocks, NULL-terminated, for 
   1083          *                               which the task will be waiting for.
   1084          *
   1085          * Returns    : none.
   1086          *
   1087          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1088          *********************************************************************************************************
   1089          */
   1090          #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))

   \                                 In section .text, align 2, keep-with-next
   1091          void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
   1092          {
   \                     OS_EventTaskWaitMulti: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   1093              OS_EVENT **pevents;
   1094              OS_EVENT  *pevent;
   1095              INT8U      y;
   1096          
   1097          
   1098              OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
   \   00000002   0x....             LDR.N    R1,??DataTable17
   \   00000004   0x698A             LDR      R2,[R1, #+24]
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x61D3             STR      R3,[R2, #+28]
   1099              OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
   \   0000000A   0x6210             STR      R0,[R2, #+32]
   1100          
   1101              pevents =  pevents_wait;
   1102              pevent  = *pevents;
   \   0000000C   0x6802             LDR      R2,[R0, #+0]
   \   0000000E   0xE00F             B.N      ??OS_EventTaskWaitMulti_0
   1103              while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
   1104                  pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
   \                     ??OS_EventTaskWaitMulti_1: (+1)
   \   00000010   0x698B             LDR      R3,[R1, #+24]
   \   00000012   0xF813 0x4F34      LDRB     R4,[R3, #+52]!
   \   00000016   0x785B             LDRB     R3,[R3, #+1]
   \   00000018   0x18A4             ADDS     R4,R4,R2
   \   0000001A   0x7AE5             LDRB     R5,[R4, #+11]
   \   0000001C   0x432B             ORRS     R3,R3,R5
   \   0000001E   0x72E3             STRB     R3,[R4, #+11]
   1105                  pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
   \   00000020   0x698C             LDR      R4,[R1, #+24]
   \   00000022   0x7A93             LDRB     R3,[R2, #+10]
   \   00000024   0xF894 0x4036      LDRB     R4,[R4, #+54]
   \   00000028   0x4323             ORRS     R3,R4,R3
   \   0000002A   0x7293             STRB     R3,[R2, #+10]
   1106                  pevents++;
   1107                  pevent = *pevents;
   \   0000002C   0xF850 0x2F04      LDR      R2,[R0, #+4]!
   1108              }
   \                     ??OS_EventTaskWaitMulti_0: (+1)
   \   00000030   0x2A00             CMP      R2,#+0
   \   00000032   0xD1ED             BNE.N    ??OS_EventTaskWaitMulti_1
   1109          
   1110              y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
   \   00000034   0x6988             LDR      R0,[R1, #+24]
   \   00000036   0xF100 0x0334      ADD      R3,R0,#+52
   \   0000003A   0x7818             LDRB     R0,[R3, #+0]
   1111              OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
   \   0000003C   0x785C             LDRB     R4,[R3, #+1]
   \   0000003E   0x1840             ADDS     R0,R0,R1
   \   00000040   0x7A02             LDRB     R2,[R0, #+8]
   \   00000042   0x43A2             BICS     R2,R2,R4
   \   00000044   0x7202             STRB     R2,[R0, #+8]
   1112              if (OSRdyTbl[y] == 0) {
   \   00000046   0xD103             BNE.N    ??OS_EventTaskWaitMulti_2
   1113                  OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
   \   00000048   0x7908             LDRB     R0,[R1, #+4]
   \   0000004A   0x789A             LDRB     R2,[R3, #+2]
   \   0000004C   0x4390             BICS     R0,R0,R2
   \   0000004E   0x7108             STRB     R0,[R1, #+4]
   1114              }
   1115          }
   \                     ??OS_EventTaskWaitMulti_2: (+1)
   \   00000050   0xBC30             POP      {R4,R5}
   \   00000052   0x4770             BX       LR               ;; return
   1116          #endif
   1117          /*$PAGE*/
   1118          /*
   1119          *********************************************************************************************************
   1120          *                                   REMOVE TASK FROM EVENT WAIT LIST
   1121          *
   1122          * Description: Remove a task from an event's wait list.
   1123          *
   1124          * Arguments  : ptcb     is a pointer to the task to remove.
   1125          *
   1126          *              pevent   is a pointer to the event control block.
   1127          *
   1128          * Returns    : none
   1129          *
   1130          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1131          *********************************************************************************************************
   1132          */
   1133          #if (OS_EVENT_EN)

   \                                 In section .text, align 2, keep-with-next
   1134          void  OS_EventTaskRemove (OS_TCB   *ptcb,
   1135                                    OS_EVENT *pevent)
   1136          {
   1137              INT8U  y;
   1138          
   1139          
   1140              y                       =  ptcb->OSTCBY;
   \                     OS_EventTaskRemove: (+1)
   \   00000000   0xF810 0x2F34      LDRB     R2,[R0, #+52]!
   1141              pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
   \   00000004   0xF890 0xC001      LDRB     R12,[R0, #+1]
   \   00000008   0x1852             ADDS     R2,R2,R1
   \   0000000A   0x7AD3             LDRB     R3,[R2, #+11]
   \   0000000C   0xEA33 0x030C      BICS     R3,R3,R12
   \   00000010   0x72D3             STRB     R3,[R2, #+11]
   1142              if (pevent->OSEventTbl[y] == 0) {
   \   00000012   0xD104             BNE.N    ??OS_EventTaskRemove_0
   1143                  pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
   \   00000014   0x7A8A             LDRB     R2,[R1, #+10]
   \   00000016   0x7880             LDRB     R0,[R0, #+2]
   \   00000018   0xEA22 0x0000      BIC      R0,R2,R0
   \   0000001C   0x7288             STRB     R0,[R1, #+10]
   1144              }
   1145          }
   \                     ??OS_EventTaskRemove_0: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
   1146          #endif
   1147          /*$PAGE*/
   1148          /*
   1149          *********************************************************************************************************
   1150          *                             REMOVE TASK FROM MULTIPLE EVENTS WAIT LISTS
   1151          *
   1152          * Description: Remove a task from multiple events' wait lists.
   1153          *
   1154          * Arguments  : ptcb             is a pointer to the task to remove.
   1155          *
   1156          *              pevents_multi    is a pointer to the array of event control blocks, NULL-terminated.
   1157          *
   1158          * Returns    : none
   1159          *
   1160          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1161          *********************************************************************************************************
   1162          */
   1163          #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))

   \                                 In section .text, align 2, keep-with-next
   1164          void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
   1165                                         OS_EVENT **pevents_multi)
   1166          {
   \                     OS_EventTaskRemoveMulti: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   1167              OS_EVENT **pevents;
   1168              OS_EVENT  *pevent;
   1169              INT8U      y;
   1170          #if (OS_LOWEST_PRIO <= 63)
   1171              INT8U      bity;
   1172              INT8U      bitx;
   1173          #else
   1174              INT16U     bity;
   1175              INT16U     bitx;
   1176          #endif
   1177          
   1178          
   1179              y       =  ptcb->OSTCBY;
   \   00000002   0xF810 0x2F34      LDRB     R2,[R0, #+52]!
   1180              bity    =  ptcb->OSTCBBitY;
   \   00000006   0x7883             LDRB     R3,[R0, #+2]
   1181              bitx    =  ptcb->OSTCBBitX;
   \   00000008   0x7840             LDRB     R0,[R0, #+1]
   1182              pevents =  pevents_multi;
   1183              pevent  = *pevents;
   \   0000000A   0x680C             LDR      R4,[R1, #+0]
   \   0000000C   0x43DB             MVNS     R3,R3
   \   0000000E   0xE009             B.N      ??OS_EventTaskRemoveMulti_0
   1184              while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
   1185                  pevent->OSEventTbl[y]  &= ~bitx;
   \                     ??OS_EventTaskRemoveMulti_1: (+1)
   \   00000010   0x1915             ADDS     R5,R2,R4
   \   00000012   0x7AEE             LDRB     R6,[R5, #+11]
   \   00000014   0x4386             BICS     R6,R6,R0
   \   00000016   0x72EE             STRB     R6,[R5, #+11]
   1186                  if (pevent->OSEventTbl[y] == 0) {
   \   00000018   0xD102             BNE.N    ??OS_EventTaskRemoveMulti_2
   1187                      pevent->OSEventGrp &= ~bity;
   \   0000001A   0x7AA5             LDRB     R5,[R4, #+10]
   \   0000001C   0x401D             ANDS     R5,R3,R5
   \   0000001E   0x72A5             STRB     R5,[R4, #+10]
   1188                  }
   1189                  pevents++;
   1190                  pevent = *pevents;
   \                     ??OS_EventTaskRemoveMulti_2: (+1)
   \   00000020   0xF851 0x4F04      LDR      R4,[R1, #+4]!
   1191              }
   \                     ??OS_EventTaskRemoveMulti_0: (+1)
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD1F3             BNE.N    ??OS_EventTaskRemoveMulti_1
   1192          }
   \   00000028   0xBC70             POP      {R4-R6}
   \   0000002A   0x4770             BX       LR               ;; return
   1193          #endif
   1194          /*$PAGE*/
   1195          /*
   1196          *********************************************************************************************************
   1197          *                                 INITIALIZE EVENT CONTROL BLOCK'S WAIT LIST
   1198          *
   1199          * Description: This function is called by other uC/OS-II services to initialize the event wait list.
   1200          *
   1201          * Arguments  : pevent    is a pointer to the event control block allocated to the event.
   1202          *
   1203          * Returns    : none
   1204          *
   1205          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1206          *********************************************************************************************************
   1207          */
   1208          #if (OS_EVENT_EN)

   \                                 In section .text, align 2, keep-with-next
   1209          void  OS_EventWaitListInit (OS_EVENT *pevent)
   1210          {
   1211          #if OS_LOWEST_PRIO <= 63
   1212              INT8U  *ptbl;
   1213          #else
   1214              INT16U *ptbl;
   1215          #endif
   1216              INT8U   i;
   1217          
   1218          
   1219              pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
   \                     OS_EventWaitListInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7281             STRB     R1,[R0, #+10]
   1220              ptbl               = &pevent->OSEventTbl[0];
   1221          
   1222              for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
   1223                  *ptbl++ = 0;
   \   00000004   0x300B             ADDS     R0,R0,#+11
   \   00000006   0x2104             MOVS     R1,#+4
   \   00000008   0x.... 0x....      B.W      __aeabi_memclr
   1224              }
   1225          }
   1226          #endif
   1227          /*$PAGE*/
   1228          /*
   1229          *********************************************************************************************************
   1230          *                                             INITIALIZATION
   1231          *                           INITIALIZE THE FREE LIST OF EVENT CONTROL BLOCKS
   1232          *
   1233          * Description: This function is called by OSInit() to initialize the free list of event control blocks.
   1234          *
   1235          * Arguments  : none
   1236          *
   1237          * Returns    : none
   1238          *********************************************************************************************************
   1239          */
   1240          
   1241          static  void  OS_InitEventList (void)
   1242          {
   1243          #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0)
   1244          #if (OS_MAX_EVENTS > 1)
   1245              INT16U     i;
   1246              OS_EVENT  *pevent1;
   1247              OS_EVENT  *pevent2;
   1248          
   1249          
   1250              OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
   1251              pevent1 = &OSEventTbl[0];
   1252              pevent2 = &OSEventTbl[1];
   1253              for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
   1254                  pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
   1255                  pevent1->OSEventPtr     = pevent2;
   1256          #if OS_EVENT_NAME_SIZE > 1
   1257                  pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
   1258                  pevent1->OSEventName[1] = OS_ASCII_NUL;
   1259          #endif
   1260                  pevent1++;
   1261                  pevent2++;
   1262              }
   1263              pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
   1264              pevent1->OSEventPtr             = (OS_EVENT *)0;
   1265          #if OS_EVENT_NAME_SIZE > 1
   1266              pevent1->OSEventName[0]         = '?';
   1267              pevent1->OSEventName[1]         = OS_ASCII_NUL;
   1268          #endif
   1269              OSEventFreeList                 = &OSEventTbl[0];
   1270          #else
   1271              OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
   1272              OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
   1273              OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
   1274          #if OS_EVENT_NAME_SIZE > 1
   1275              OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
   1276              OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
   1277          #endif
   1278          #endif
   1279          #endif
   1280          }
   1281          /*$PAGE*/
   1282          /*
   1283          *********************************************************************************************************
   1284          *                                             INITIALIZATION
   1285          *                                    INITIALIZE MISCELLANEOUS VARIABLES
   1286          *
   1287          * Description: This function is called by OSInit() to initialize miscellaneous variables.
   1288          *
   1289          * Arguments  : none
   1290          *
   1291          * Returns    : none
   1292          *********************************************************************************************************
   1293          */
   1294          
   1295          static  void  OS_InitMisc (void)
   1296          {
   1297          #if OS_TIME_GET_SET_EN > 0
   1298              OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
   1299          #endif
   1300          
   1301              OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
   1302              OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
   1303          
   1304              OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
   1305          
   1306              OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
   1307          
   1308              OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
   1309              OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
   1310          
   1311          #if OS_TASK_STAT_EN > 0
   1312              OSIdleCtrRun  = 0L;
   1313              OSIdleCtrMax  = 0L;
   1314              OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
   1315          #endif
   1316          }
   1317          /*$PAGE*/
   1318          /*
   1319          *********************************************************************************************************
   1320          *                                             INITIALIZATION
   1321          *                                       INITIALIZE THE READY LIST
   1322          *
   1323          * Description: This function is called by OSInit() to initialize the Ready List.
   1324          *
   1325          * Arguments  : none
   1326          *
   1327          * Returns    : none
   1328          *********************************************************************************************************
   1329          */
   1330          
   1331          static  void  OS_InitRdyList (void)
   1332          {
   1333              INT8U    i;
   1334          #if OS_LOWEST_PRIO <= 63
   1335              INT8U   *prdytbl;
   1336          #else
   1337              INT16U  *prdytbl;
   1338          #endif
   1339          
   1340          
   1341              OSRdyGrp      = 0;                                     /* Clear the ready list                     */
   1342              prdytbl       = &OSRdyTbl[0];
   1343              for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
   1344                  *prdytbl++ = 0;
   1345              }
   1346          
   1347              OSPrioCur     = 0;
   1348              OSPrioHighRdy = 0;
   1349          
   1350              OSTCBHighRdy  = (OS_TCB *)0;
   1351              OSTCBCur      = (OS_TCB *)0;
   1352          }
   1353          
   1354          /*$PAGE*/
   1355          /*
   1356          *********************************************************************************************************
   1357          *                                             INITIALIZATION
   1358          *                                         CREATING THE IDLE TASK
   1359          *
   1360          * Description: This function creates the Idle Task.
   1361          *
   1362          * Arguments  : none
   1363          *
   1364          * Returns    : none
   1365          *********************************************************************************************************
   1366          */
   1367          
   1368          static  void  OS_InitTaskIdle (void)
   1369          {
   1370          #if OS_TASK_NAME_SIZE > 7
   1371              INT8U  err;
   1372          #endif
   1373          
   1374          
   1375          #if OS_TASK_CREATE_EXT_EN > 0
   1376              #if OS_STK_GROWTH == 1
   1377              (void)OSTaskCreateExt(OS_TaskIdle,
   1378                                    (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
   1379                                    &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Top-Of-Stack                     */
   1380                                    OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
   1381                                    OS_TASK_IDLE_ID,
   1382                                    &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
   1383                                    OS_TASK_IDLE_STK_SIZE,
   1384                                    (void *)0,                                 /* No TCB extension                     */
   1385                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
   1386              #else
   1387              (void)OSTaskCreateExt(OS_TaskIdle,
   1388                                    (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
   1389                                    &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
   1390                                    OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
   1391                                    OS_TASK_IDLE_ID,
   1392                                    &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Bottom-Of-Stack                  */
   1393                                    OS_TASK_IDLE_STK_SIZE,
   1394                                    (void *)0,                                 /* No TCB extension                     */
   1395                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
   1396              #endif
   1397          #else
   1398              #if OS_STK_GROWTH == 1
   1399              (void)OSTaskCreate(OS_TaskIdle,
   1400                                 (void *)0,
   1401                                 &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1],
   1402                                 OS_TASK_IDLE_PRIO);
   1403              #else
   1404              (void)OSTaskCreate(OS_TaskIdle,
   1405                                 (void *)0,
   1406                                 &OSTaskIdleStk[0],
   1407                                 OS_TASK_IDLE_PRIO);
   1408              #endif
   1409          #endif
   1410          
   1411          #if OS_TASK_NAME_SIZE > 14
   1412              OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
   1413          #else
   1414          #if OS_TASK_NAME_SIZE > 7
   1415              OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
   1416          #endif
   1417          #endif
   1418          }
   1419          /*$PAGE*/
   1420          /*
   1421          *********************************************************************************************************
   1422          *                                             INITIALIZATION
   1423          *                                      CREATING THE STATISTIC TASK
   1424          *
   1425          * Description: This function creates the Statistic Task.
   1426          *
   1427          * Arguments  : none
   1428          *
   1429          * Returns    : none
   1430          *********************************************************************************************************
   1431          */
   1432          
   1433          #if OS_TASK_STAT_EN > 0
   1434          static  void  OS_InitTaskStat (void)
   1435          {
   1436          #if OS_TASK_NAME_SIZE > 7
   1437              INT8U  err;
   1438          #endif
   1439          
   1440          
   1441          #if OS_TASK_CREATE_EXT_EN > 0
   1442              #if OS_STK_GROWTH == 1
   1443              (void)OSTaskCreateExt(OS_TaskStat,
   1444                                    (void *)0,                                   /* No args passed to OS_TaskStat()*/
   1445                                    &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],   /* Set Top-Of-Stack               */
   1446                                    OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
   1447                                    OS_TASK_STAT_ID,
   1448                                    &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
   1449                                    OS_TASK_STAT_STK_SIZE,
   1450                                    (void *)0,                                   /* No TCB extension               */
   1451                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
   1452              #else
   1453              (void)OSTaskCreateExt(OS_TaskStat,
   1454                                    (void *)0,                                   /* No args passed to OS_TaskStat()*/
   1455                                    &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
   1456                                    OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
   1457                                    OS_TASK_STAT_ID,
   1458                                    &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],   /* Set Bottom-Of-Stack            */
   1459                                    OS_TASK_STAT_STK_SIZE,
   1460                                    (void *)0,                                   /* No TCB extension               */
   1461                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
   1462              #endif
   1463          #else
   1464              #if OS_STK_GROWTH == 1
   1465              (void)OSTaskCreate(OS_TaskStat,
   1466                                 (void *)0,                                      /* No args passed to OS_TaskStat()*/
   1467                                 &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],      /* Set Top-Of-Stack               */
   1468                                 OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
   1469              #else
   1470              (void)OSTaskCreate(OS_TaskStat,
   1471                                 (void *)0,                                      /* No args passed to OS_TaskStat()*/
   1472                                 &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
   1473                                 OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
   1474              #endif
   1475          #endif
   1476          
   1477          #if OS_TASK_NAME_SIZE > 14
   1478              OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
   1479          #else
   1480          #if OS_TASK_NAME_SIZE > 7
   1481              OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
   1482          #endif
   1483          #endif
   1484          }
   1485          #endif
   1486          /*$PAGE*/
   1487          /*
   1488          *********************************************************************************************************
   1489          *                                             INITIALIZATION
   1490          *                            INITIALIZE THE FREE LIST OF TASK CONTROL BLOCKS
   1491          *
   1492          * Description: This function is called by OSInit() to initialize the free list of OS_TCBs.
   1493          *
   1494          * Arguments  : none
   1495          *
   1496          * Returns    : none
   1497          *********************************************************************************************************
   1498          */
   1499          
   1500          static  void  OS_InitTCBList (void)
   1501          {
   1502              INT8U    i;
   1503              OS_TCB  *ptcb1;
   1504              OS_TCB  *ptcb2;
   1505          
   1506          
   1507              OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
   1508              OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
   1509              ptcb1 = &OSTCBTbl[0];
   1510              ptcb2 = &OSTCBTbl[1];
   1511              for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
   1512                  ptcb1->OSTCBNext = ptcb2;
   1513          #if OS_TASK_NAME_SIZE > 1
   1514                  ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
   1515                  ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
   1516          #endif
   1517                  ptcb1++;
   1518                  ptcb2++;
   1519              }
   1520              ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
   1521          #if OS_TASK_NAME_SIZE > 1
   1522              ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
   1523              ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
   1524          #endif
   1525              OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
   1526              OSTCBFreeList           = &OSTCBTbl[0];
   1527          }
   1528          /*$PAGE*/
   1529          /*
   1530          *********************************************************************************************************
   1531          *                                        CLEAR A SECTION OF MEMORY
   1532          *
   1533          * Description: This function is called by other uC/OS-II services to clear a contiguous block of RAM.
   1534          *
   1535          * Arguments  : pdest    is the start of the RAM to clear (i.e. write 0x00 to)
   1536          *
   1537          *              size     is the number of bytes to clear.
   1538          *
   1539          * Returns    : none
   1540          *
   1541          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1542          *              2) Note that we can only clear up to 64K bytes of RAM.  This is not an issue because none
   1543          *                 of the uses of this function gets close to this limit.
   1544          *              3) The clear is done one byte at a time since this will work on any processor irrespective
   1545          *                 of the alignment of the destination.
   1546          *********************************************************************************************************
   1547          */
   1548          

   \                                 In section .text, align 2, keep-with-next
   1549          void  OS_MemClr (INT8U *pdest, INT16U size)
   1550          {
   1551              while (size > 0) {
   \                     OS_MemClr: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xBF18             IT       NE 
   1552                  *pdest++ = (INT8U)0;
   \   00000004   0x.... 0x....      BNE.W    __aeabi_memclr
   1553                  size--;
   1554              }
   1555          }
   \   00000008   0x4770             BX       LR               ;; return
   1556          /*$PAGE*/
   1557          /*
   1558          *********************************************************************************************************
   1559          *                                        COPY A BLOCK OF MEMORY
   1560          *
   1561          * Description: This function is called by other uC/OS-II services to copy a block of memory from one
   1562          *              location to another.
   1563          *
   1564          * Arguments  : pdest    is a pointer to the 'destination' memory block
   1565          *
   1566          *              psrc     is a pointer to the 'source'      memory block
   1567          *
   1568          *              size     is the number of bytes to copy.
   1569          *
   1570          * Returns    : none
   1571          *
   1572          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.  There is
   1573          *                 no provision to handle overlapping memory copy.  However, that's not a problem since this
   1574          *                 is not a situation that will happen.
   1575          *              2) Note that we can only copy up to 64K bytes of RAM
   1576          *              3) The copy is done one byte at a time since this will work on any processor irrespective
   1577          *                 of the alignment of the source and destination.
   1578          *********************************************************************************************************
   1579          */
   1580          

   \                                 In section .text, align 2, keep-with-next
   1581          void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
   1582          {
   \                     OS_MemCopy: (+1)
   \   00000000   0xB12A             CBZ.N    R2,??OS_MemCopy_0
   1583              while (size > 0) {
   1584                  *pdest++ = *psrc++;
   \                     ??OS_MemCopy_1: (+1)
   \   00000002   0xF811 0x3B01      LDRB     R3,[R1], #+1
   \   00000006   0xF800 0x3B01      STRB     R3,[R0], #+1
   1585                  size--;
   \   0000000A   0x1E52             SUBS     R2,R2,#+1
   1586              }
   \   0000000C   0xD1F9             BNE.N    ??OS_MemCopy_1
   1587          }
   \                     ??OS_MemCopy_0: (+1)
   \   0000000E   0x4770             BX       LR               ;; return
   1588          /*$PAGE*/
   1589          /*
   1590          *********************************************************************************************************
   1591          *                                              SCHEDULER
   1592          *
   1593          * Description: This function is called by other uC/OS-II services to determine whether a new, high
   1594          *              priority task has been made ready to run.  This function is invoked by TASK level code
   1595          *              and is not used to reschedule tasks from ISRs (see OSIntExit() for ISR rescheduling).
   1596          *
   1597          * Arguments  : none
   1598          *
   1599          * Returns    : none
   1600          *
   1601          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1602          *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
   1603          *********************************************************************************************************
   1604          */
   1605          

   \                                 In section .text, align 2, keep-with-next
   1606          void  OS_Sched (void)
   1607          {
   \                     OS_Sched: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1608          #if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
   1609              OS_CPU_SR  cpu_sr = 0;
   1610          #endif
   1611          
   1612          
   1613          
   1614              OS_ENTER_CRITICAL();
   \   00000002   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000006   0x4604             MOV      R4,R0
   1615              if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
   1616                  if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
   \   00000008   0x....             LDR.N    R0,??DataTable17
   \   0000000A   0x7801             LDRB     R1,[R0, #+0]
   \   0000000C   0x7842             LDRB     R2,[R0, #+1]
   \   0000000E   0x4311             ORRS     R1,R2,R1
   \   00000010   0xD119             BNE.N    ??OS_Sched_0
   1617                      OS_SchedNew();
   \   00000012   0x7902             LDRB     R2,[R0, #+4]
   \   00000014   0x.... 0x....      ADR.W    R1,OSUnMapTbl
   \   00000018   0x5C52             LDRB     R2,[R2, R1]
   \   0000001A   0x1813             ADDS     R3,R2,R0
   \   0000001C   0x7A1B             LDRB     R3,[R3, #+8]
   \   0000001E   0x5C59             LDRB     R1,[R3, R1]
   \   00000020   0xEB01 0x01C2      ADD      R1,R1,R2, LSL #+3
   \   00000024   0x70C1             STRB     R1,[R0, #+3]
   1618                      if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
   \   00000026   0x7882             LDRB     R2,[R0, #+2]
   \   00000028   0x78C1             LDRB     R1,[R0, #+3]
   \   0000002A   0x4291             CMP      R1,R2
   \   0000002C   0xD00B             BEQ.N    ??OS_Sched_0
   1619                          OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
   \   0000002E   0x....             LDR.N    R2,??DataTable17_1
   \   00000030   0xF852 0x1021      LDR      R1,[R2, R1, LSL #+2]
   \   00000034   0x6201             STR      R1,[R0, #+32]
   1620          #if OS_TASK_PROFILE_EN > 0
   1621                          OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
   \   00000036   0x6B8A             LDR      R2,[R1, #+56]
   \   00000038   0x1C52             ADDS     R2,R2,#+1
   \   0000003A   0x638A             STR      R2,[R1, #+56]
   1622          #endif
   1623                          OSCtxSwCtr++;                          /* Increment context switch counter             */
   \   0000003C   0x68C1             LDR      R1,[R0, #+12]
   \   0000003E   0x1C49             ADDS     R1,R1,#+1
   \   00000040   0x60C1             STR      R1,[R0, #+12]
   1624                          OS_TASK_SW();                          /* Perform a context switch                     */
   \   00000042   0x.... 0x....      BL       OSCtxSw
   1625                      }
   1626                  }
   1627              }
   1628              OS_EXIT_CRITICAL();
   \                     ??OS_Sched_0: (+1)
   \   00000046   0x4620             MOV      R0,R4
   \   00000048                      REQUIRE ?Subroutine0
   \   00000048                      ;; // Fall through to label ?Subroutine0
   1629          }
   1630          
   1631          
   1632          /*
   1633          *********************************************************************************************************
   1634          *                              FIND HIGHEST PRIORITY TASK READY TO RUN
   1635          *
   1636          * Description: This function is called by other uC/OS-II services to determine the highest priority task
   1637          *              that is ready to run.  The global variable 'OSPrioHighRdy' is changed accordingly.
   1638          *
   1639          * Arguments  : none
   1640          *
   1641          * Returns    : none
   1642          *
   1643          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1644          *              2) Interrupts are assumed to be disabled when this function is called.
   1645          *********************************************************************************************************
   1646          */
   1647          
   1648          static  void  OS_SchedNew (void)
   1649          {
   1650          #if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
   1651              INT8U   y;
   1652          
   1653          
   1654              y             = OSUnMapTbl[OSRdyGrp];
   1655              OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
   1656          #else                                            /* We support up to 256 tasks                         */
   1657              INT8U   y;
   1658              INT16U *ptbl;
   1659          
   1660          
   1661              if ((OSRdyGrp & 0xFF) != 0) {
   1662                  y = OSUnMapTbl[OSRdyGrp & 0xFF];
   1663              } else {
   1664                  y = OSUnMapTbl[(OSRdyGrp >> 8) & 0xFF] + 8;
   1665              }
   1666              ptbl = &OSRdyTbl[y];
   1667              if ((*ptbl & 0xFF) != 0) {
   1668                  OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
   1669              } else {
   1670                  OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
   1671              }
   1672          #endif
   1673          }
   1674          
   1675          /*$PAGE*/
   1676          /*
   1677          *********************************************************************************************************
   1678          *                                        COPY AN ASCII STRING
   1679          *
   1680          * Description: This function is called by other uC/OS-II services to copy an ASCII string from a 'source'
   1681          *              string to a 'destination' string.
   1682          *
   1683          * Arguments  : pdest    is a pointer to the string that will be receiving the copy.  Note that there MUST
   1684          *                       be sufficient space in the destination storage area to receive this string.
   1685          *
   1686          *              psrc     is a pointer to the source string.  The source string MUST NOT be greater than
   1687          *                       254 characters.
   1688          *
   1689          * Returns    : The size of the string (excluding the NUL terminating character)
   1690          *
   1691          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1692          *********************************************************************************************************
   1693          */
   1694          
   1695          #if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)

   \                                 In section .text, align 2, keep-with-next
   1696          INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
   1697          {
   1698              INT8U  len;
   1699          
   1700          
   1701              len = 0;
   \                     OS_StrCopy: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0xE004             B.N      ??OS_StrCopy_0
   1702              while (*psrc != OS_ASCII_NUL) {
   1703                  *pdest++ = *psrc++;
   \                     ??OS_StrCopy_1: (+1)
   \   00000004   0xF811 0x3B01      LDRB     R3,[R1], #+1
   \   00000008   0xF800 0x3B01      STRB     R3,[R0], #+1
   1704                  len++;
   \   0000000C   0x1C52             ADDS     R2,R2,#+1
   1705              }
   \                     ??OS_StrCopy_0: (+1)
   \   0000000E   0x780B             LDRB     R3,[R1, #+0]
   \   00000010   0x2B00             CMP      R3,#+0
   \   00000012   0xD1F7             BNE.N    ??OS_StrCopy_1
   1706              *pdest = OS_ASCII_NUL;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x7001             STRB     R1,[R0, #+0]
   1707              return (len);
   \   00000018   0xB2D0             UXTB     R0,R2
   \   0000001A   0x4770             BX       LR               ;; return
   1708          }
   1709          #endif
   1710          /*$PAGE*/
   1711          /*
   1712          *********************************************************************************************************
   1713          *                                DETERMINE THE LENGTH OF AN ASCII STRING
   1714          *
   1715          * Description: This function is called by other uC/OS-II services to determine the size of an ASCII string
   1716          *              (excluding the NUL character).
   1717          *
   1718          * Arguments  : psrc     is a pointer to the string for which we need to know the size.
   1719          *
   1720          * Returns    : The size of the string (excluding the NUL terminating character)
   1721          *
   1722          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1723          *              2) The string to check must be less than 255 characters long.
   1724          *********************************************************************************************************
   1725          */
   1726          
   1727          #if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)

   \                                 In section .text, align 2, keep-with-next
   1728          INT8U  OS_StrLen (INT8U *psrc)
   1729          {
   1730              INT8U  len;
   1731          
   1732          
   1733              len = 0;
   \                     OS_StrLen: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xE000             B.N      ??OS_StrLen_0
   1734              while (*psrc != OS_ASCII_NUL) {
   1735                  psrc++;
   1736                  len++;
   \                     ??OS_StrLen_1: (+1)
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   1737              }
   \                     ??OS_StrLen_0: (+1)
   \   00000006   0xF810 0x2B01      LDRB     R2,[R0], #+1
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xD1FA             BNE.N    ??OS_StrLen_1
   1738              return (len);
   \   0000000E   0xB2C8             UXTB     R0,R1
   \   00000010   0x4770             BX       LR               ;; return
   1739          }
   1740          #endif
   1741          /*$PAGE*/
   1742          /*
   1743          *********************************************************************************************************
   1744          *                                              IDLE TASK
   1745          *
   1746          * Description: This task is internal to uC/OS-II and executes whenever no other higher priority tasks
   1747          *              executes because they are ALL waiting for event(s) to occur.
   1748          *
   1749          * Arguments  : none
   1750          *
   1751          * Returns    : none
   1752          *
   1753          * Note(s)    : 1) OSTaskIdleHook() is called after the critical section to ensure that interrupts will be
   1754          *                 enabled for at least a few instructions.  On some processors (ex. Philips XA), enabling
   1755          *                 and then disabling interrupts didn't allow the processor enough time to have interrupts
   1756          *                 enabled before they were disabled again.  uC/OS-II would thus never recognize
   1757          *                 interrupts.
   1758          *              2) This hook has been added to allow you to do such things as STOP the CPU to conserve
   1759          *                 power.
   1760          *********************************************************************************************************
   1761          */
   1762          

   \                                 In section .text, align 4, keep-with-next
   1763          void  OS_TaskIdle (void *p_arg)
   1764          {
   \                     OS_TaskIdle: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1765          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
   1766              OS_CPU_SR  cpu_sr = 0;
   1767          #endif
   1768          
   1769          
   1770          
   1771              (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
   1772              for (;;) {
   1773                  OS_ENTER_CRITICAL();
   \                     ??OS_TaskIdle_0: (+1)
   \   00000002   0x.... 0x....      BL       OS_CPU_SR_Save
   1774                  OSIdleCtr++;
   \   00000006   0x....             LDR.N    R1,??DataTable17
   \   00000008   0x694A             LDR      R2,[R1, #+20]
   \   0000000A   0x1C52             ADDS     R2,R2,#+1
   \   0000000C   0x614A             STR      R2,[R1, #+20]
   1775                  OS_EXIT_CRITICAL();
   \   0000000E   0x.... 0x....      BL       OS_CPU_SR_Restore
   1776                  OSTaskIdleHook();                        /* Call user definable HOOK                           */
   \   00000012   0x.... 0x....      BL       OSTaskIdleHook
   \   00000016   0xE7F4             B.N      ??OS_TaskIdle_0
   1777              }
   1778          }
   1779          /*$PAGE*/
   1780          /*
   1781          *********************************************************************************************************
   1782          *                                            STATISTICS TASK
   1783          *
   1784          * Description: This task is internal to uC/OS-II and is used to compute some statistics about the
   1785          *              multitasking environment.  Specifically, OS_TaskStat() computes the CPU usage.
   1786          *              CPU usage is determined by:
   1787          *
   1788          *                                          OSIdleCtr
   1789          *                 OSCPUUsage = 100 * (1 - ------------)     (units are in %)
   1790          *                                         OSIdleCtrMax
   1791          *
   1792          * Arguments  : parg     this pointer is not used at this time.
   1793          *
   1794          * Returns    : none
   1795          *
   1796          * Notes      : 1) This task runs at a priority level higher than the idle task.  In fact, it runs at the
   1797          *                 next higher priority, OS_TASK_IDLE_PRIO-1.
   1798          *              2) You can disable this task by setting the configuration #define OS_TASK_STAT_EN to 0.
   1799          *              3) You MUST have at least a delay of 2/10 seconds to allow for the system to establish the
   1800          *                 maximum value for the idle counter.
   1801          *********************************************************************************************************
   1802          */
   1803          
   1804          #if OS_TASK_STAT_EN > 0
   1805          void  OS_TaskStat (void *p_arg)
   1806          {
   1807          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
   1808              OS_CPU_SR  cpu_sr = 0;
   1809          #endif
   1810          
   1811          
   1812          
   1813              (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
   1814              while (OSStatRdy == OS_FALSE) {
   1815                  OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
   1816              }
   1817              OSIdleCtrMax /= 100L;
   1818              if (OSIdleCtrMax == 0L) {
   1819                  OSCPUUsage = 0;
   1820                  (void)OSTaskSuspend(OS_PRIO_SELF);
   1821              }
   1822              for (;;) {
   1823                  OS_ENTER_CRITICAL();
   1824                  OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
   1825                  OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
   1826                  OS_EXIT_CRITICAL();
   1827                  OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
   1828                  OSTaskStatHook();                        /* Invoke user definable hook                         */
   1829          #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
   1830                  OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
   1831          #endif
   1832                  OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
   1833              }
   1834          }
   1835          #endif
   1836          /*$PAGE*/
   1837          /*
   1838          *********************************************************************************************************
   1839          *                                      CHECK ALL TASK STACKS
   1840          *
   1841          * Description: This function is called by OS_TaskStat() to check the stacks of each active task.
   1842          *
   1843          * Arguments  : none
   1844          *
   1845          * Returns    : none
   1846          *********************************************************************************************************
   1847          */
   1848          
   1849          #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)

   \                                 In section .text, align 2, keep-with-next
   1850          void  OS_TaskStatStkChk (void)
   1851          {
   \                     OS_TaskStatStkChk: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   1852              OS_TCB      *ptcb;
   1853              OS_STK_DATA  stk_data;
   1854              INT8U        err;
   1855              INT8U        prio;
   1856          
   1857          
   1858              for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x....             LDR.N    R5,??DataTable17_1
   1859                  err = OSTaskStkChk(prio, &stk_data);
   1860                  if (err == OS_ERR_NONE) {
   \                     ??OS_TaskStatStkChk_0: (+1)
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       OSTaskStkChk
   \   00000010   0xB958             CBNZ.N   R0,??OS_TaskStatStkChk_1
   1861                      ptcb = OSTCBPrioTbl[prio];
   \   00000012   0x6828             LDR      R0,[R5, #+0]
   1862                      if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xBF18             IT       NE 
   \   00000018   0x2801             CMPNE    R0,#+1
   1863                          if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
   \   0000001A   0xD006             BEQ.N    ??OS_TaskStatStkChk_1
   1864          #if OS_TASK_PROFILE_EN > 0
   1865                              #if OS_STK_GROWTH == 1
   1866                              ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
   \   0000001C   0x6881             LDR      R1,[R0, #+8]
   \   0000001E   0x68C2             LDR      R2,[R0, #+12]
   \   00000020   0xEB01 0x0182      ADD      R1,R1,R2, LSL #+2
   \   00000024   0x6441             STR      R1,[R0, #+68]
   1867                              #else
   1868                              ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
   1869                              #endif
   1870                              ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
   \   00000026   0x9901             LDR      R1,[SP, #+4]
   \   00000028   0x6481             STR      R1,[R0, #+72]
   1871          #endif
   1872                          }
   1873                      }
   1874                  }
   1875              }
   \                     ??OS_TaskStatStkChk_1: (+1)
   \   0000002A   0x1C64             ADDS     R4,R4,#+1
   \   0000002C   0x1D2D             ADDS     R5,R5,#+4
   \   0000002E   0x2C20             CMP      R4,#+32
   \   00000030   0xDBEA             BLT.N    ??OS_TaskStatStkChk_0
   1876          }
   \   00000032   0xB003             ADD      SP,SP,#+12
   \   00000034   0xBD30             POP      {R4,R5,PC}       ;; return
   1877          #endif
   1878          /*$PAGE*/
   1879          /*
   1880          *********************************************************************************************************
   1881          *                                            INITIALIZE TCB
   1882          *
   1883          * Description: This function is internal to uC/OS-II and is used to initialize a Task Control Block when
   1884          *              a task is created (see OSTaskCreate() and OSTaskCreateExt()).
   1885          *
   1886          * Arguments  : prio          is the priority of the task being created
   1887          *
   1888          *              ptos          is a pointer to the task's top-of-stack assuming that the CPU registers
   1889          *                            have been placed on the stack.  Note that the top-of-stack corresponds to a
   1890          *                            'high' memory location is OS_STK_GROWTH is set to 1 and a 'low' memory
   1891          *                            location if OS_STK_GROWTH is set to 0.  Note that stack growth is CPU
   1892          *                            specific.
   1893          *
   1894          *              pbos          is a pointer to the bottom of stack.  A NULL pointer is passed if called by
   1895          *                            'OSTaskCreate()'.
   1896          *
   1897          *              id            is the task's ID (0..65535)
   1898          *
   1899          *              stk_size      is the size of the stack (in 'stack units').  If the stack units are INT8Us
   1900          *                            then, 'stk_size' contains the number of bytes for the stack.  If the stack
   1901          *                            units are INT32Us then, the stack contains '4 * stk_size' bytes.  The stack
   1902          *                            units are established by the #define constant OS_STK which is CPU
   1903          *                            specific.  'stk_size' is 0 if called by 'OSTaskCreate()'.
   1904          *
   1905          *              pext          is a pointer to a user supplied memory area that is used to extend the task
   1906          *                            control block.  This allows you to store the contents of floating-point
   1907          *                            registers, MMU registers or anything else you could find useful during a
   1908          *                            context switch.  You can even assign a name to each task and store this name
   1909          *                            in this TCB extension.  A NULL pointer is passed if called by OSTaskCreate().
   1910          *
   1911          *              opt           options as passed to 'OSTaskCreateExt()' or,
   1912          *                            0 if called from 'OSTaskCreate()'.
   1913          *
   1914          * Returns    : OS_ERR_NONE         if the call was successful
   1915          *              OS_ERR_TASK_NO_MORE_TCB  if there are no more free TCBs to be allocated and thus, the task cannot
   1916          *                                  be created.
   1917          *
   1918          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1919          *********************************************************************************************************
   1920          */
   1921          

   \                                 In section .text, align 2, keep-with-next
   1922          INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
   1923          {
   \                     OS_TCBInit: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460F             MOV      R7,R1
   \   00000008   0x4691             MOV      R9,R2
   \   0000000A   0x4698             MOV      R8,R3
   1924              OS_TCB    *ptcb;
   1925          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
   1926              OS_CPU_SR  cpu_sr = 0;
   1927          #endif
   1928          
   1929          
   1930          
   1931              OS_ENTER_CRITICAL();
   \   0000000C   0x.... 0x....      BL       OS_CPU_SR_Save
   1932              ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
   \   00000010   0x....             LDR.N    R5,??DataTable17
   \   00000012   0x69EE             LDR      R6,[R5, #+28]
   1933              if (ptcb != (OS_TCB *)0) {
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD056             BEQ.N    ??OS_TCBInit_0
   1934                  OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
   \   00000018   0x6971             LDR      R1,[R6, #+20]
   \   0000001A   0x61E9             STR      R1,[R5, #+28]
   1935                  OS_EXIT_CRITICAL();
   \   0000001C   0x.... 0x....      BL       OS_CPU_SR_Restore
   1936                  ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
   \   00000020   0x6037             STR      R7,[R6, #+0]
   1937                  ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
   1938                  ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xF106 0x0730      ADD      R7,R6,#+48
   \   00000028   0x70BC             STRB     R4,[R7, #+2]
   \   0000002A   0x7038             STRB     R0,[R7, #+0]
   1939                  ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
   \   0000002C   0x7078             STRB     R0,[R7, #+1]
   1940                  ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
   \   0000002E   0x85F0             STRH     R0,[R6, #+46]
   1941          
   1942          #if OS_TASK_CREATE_EXT_EN > 0
   1943                  ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
   1944                  ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
   1945                  ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
   1946                  ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
   1947                  ptcb->OSTCBId            = id;                     /* Store task ID                            */
   1948          #else
   1949                  pext                     = pext;                   /* Prevent compiler warning if not used     */
   1950                  stk_size                 = stk_size;
   1951                  pbos                     = pbos;
   1952                  opt                      = opt;
   1953                  id                       = id;
   1954          #endif
   1955          
   1956          #if OS_TASK_DEL_EN > 0
   1957                  ptcb->OSTCBDelReq        = OS_ERR_NONE;
   1958          #endif
   1959          
   1960          #if OS_LOWEST_PRIO <= 63
   1961                  ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
   1962                  ptcb->OSTCBX             = (INT8U)(prio & 0x07);
   1963                  ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0x9809             LDR      R0,[SP, #+36]
   \   00000034   0x6070             STR      R0,[R6, #+4]
   \   00000036   0xF004 0x0107      AND      R1,R4,#0x7
   \   0000003A   0x9808             LDR      R0,[SP, #+32]
   \   0000003C   0x60F0             STR      R0,[R6, #+12]
   \   0000003E   0xF8C6 0x9008      STR      R9,[R6, #+8]
   \   00000042   0x980A             LDR      R0,[SP, #+40]
   \   00000044   0x8230             STRH     R0,[R6, #+16]
   \   00000046   0xF8A6 0x8012      STRH     R8,[R6, #+18]
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x71F8             STRB     R0,[R7, #+7]
   \   0000004E   0x70F9             STRB     R1,[R7, #+3]
   \   00000050   0x08E0             LSRS     R0,R4,#+3
   \   00000052   0x7138             STRB     R0,[R7, #+4]
   \   00000054   0xFA02 0xF000      LSL      R0,R2,R0
   \   00000058   0x71B8             STRB     R0,[R7, #+6]
   1964                  ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
   \   0000005A   0xFA02 0xF001      LSL      R0,R2,R1
   \   0000005E   0x7178             STRB     R0,[R7, #+5]
   1965          #else
   1966                  ptcb->OSTCBY             = (INT8U)((prio >> 4) & 0xFF); /* Pre-compute X, Y, BitX and BitY     */
   1967                  ptcb->OSTCBX             = (INT8U) (prio & 0x0F);
   1968                  ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
   1969                  ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
   1970          #endif
   1971          
   1972          #if (OS_EVENT_EN)
   1973                  ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x61F0             STR      R0,[R6, #+28]
   1974          #if (OS_EVENT_MULTI_EN > 0)
   1975                  ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
   \   00000064   0x6230             STR      R0,[R6, #+32]
   1976          #endif
   1977          #endif
   1978          
   1979          #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
   1980                  ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
   \   00000066   0x62B0             STR      R0,[R6, #+40]
   1981          #endif
   1982          
   1983          #if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
   1984                  ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
   \   00000068   0x6270             STR      R0,[R6, #+36]
   1985          #endif
   1986          
   1987          #if OS_TASK_PROFILE_EN > 0
   1988                  ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
   \   0000006A   0x60B8             STR      R0,[R7, #+8]
   1989                  ptcb->OSTCBCyclesStart = 0L;
   \   0000006C   0x6138             STR      R0,[R7, #+16]
   1990                  ptcb->OSTCBCyclesTot   = 0L;
   \   0000006E   0x60F8             STR      R0,[R7, #+12]
   1991                  ptcb->OSTCBStkBase     = (OS_STK *)0;
   \   00000070   0x6178             STR      R0,[R7, #+20]
   1992                  ptcb->OSTCBStkUsed     = 0L;
   \   00000072   0x61B8             STR      R0,[R7, #+24]
   1993          #endif
   1994          
   1995          #if OS_TASK_NAME_SIZE > 1
   1996                  ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
   \   00000074   0x203F             MOVS     R0,#+63
   \   00000076   0x7738             STRB     R0,[R7, #+28]
   1997                  ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x7778             STRB     R0,[R7, #+29]
   1998          #endif
   1999          
   2000                  OSTCBInitHook(ptcb);
   \   0000007C   0x4630             MOV      R0,R6
   \   0000007E   0x.... 0x....      BL       OSTCBInitHook
   2001          
   2002                  OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
   \   00000082   0x4630             MOV      R0,R6
   \   00000084   0x.... 0x....      BL       OSTaskCreateHook
   2003          
   2004                  OS_ENTER_CRITICAL();
   \   00000088   0x.... 0x....      BL       OS_CPU_SR_Save
   2005                  OSTCBPrioTbl[prio] = ptcb;
   \   0000008C   0x....             LDR.N    R1,??DataTable17_1
   \   0000008E   0xF841 0x6024      STR      R6,[R1, R4, LSL #+2]
   2006                  ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
   \   00000092   0x6A69             LDR      R1,[R5, #+36]
   \   00000094   0x6171             STR      R1,[R6, #+20]
   2007                  ptcb->OSTCBPrev    = (OS_TCB *)0;
   \   00000096   0x2100             MOVS     R1,#+0
   \   00000098   0x61B1             STR      R1,[R6, #+24]
   2008                  if (OSTCBList != (OS_TCB *)0) {
   \   0000009A   0x6A69             LDR      R1,[R5, #+36]
   \   0000009C   0xB101             CBZ.N    R1,??OS_TCBInit_1
   2009                      OSTCBList->OSTCBPrev = ptcb;
   \   0000009E   0x618E             STR      R6,[R1, #+24]
   2010                  }
   2011                  OSTCBList               = ptcb;
   \                     ??OS_TCBInit_1: (+1)
   \   000000A0   0x626E             STR      R6,[R5, #+36]
   2012                  OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
   \   000000A2   0x7929             LDRB     R1,[R5, #+4]
   \   000000A4   0x79BA             LDRB     R2,[R7, #+6]
   \   000000A6   0x4311             ORRS     R1,R2,R1
   \   000000A8   0x7129             STRB     R1,[R5, #+4]
   2013                  OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   000000AA   0x7939             LDRB     R1,[R7, #+4]
   \   000000AC   0x797B             LDRB     R3,[R7, #+5]
   \   000000AE   0x1949             ADDS     R1,R1,R5
   \   000000B0   0x7A0A             LDRB     R2,[R1, #+8]
   \   000000B2   0x431A             ORRS     R2,R3,R2
   \   000000B4   0x720A             STRB     R2,[R1, #+8]
   2014                  OSTaskCtr++;                                       /* Increment the #tasks counter             */
   \   000000B6   0x79A9             LDRB     R1,[R5, #+6]
   \   000000B8   0x1C49             ADDS     R1,R1,#+1
   \   000000BA   0x71A9             STRB     R1,[R5, #+6]
   2015                  OS_EXIT_CRITICAL();
   \   000000BC   0x.... 0x....      BL       OS_CPU_SR_Restore
   2016                  return (OS_ERR_NONE);
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   2017              }
   2018              OS_EXIT_CRITICAL();
   \                     ??OS_TCBInit_0: (+1)
   \   000000C6   0x.... 0x....      BL       OS_CPU_SR_Restore
   2019              return (OS_ERR_TASK_NO_MORE_TCB);
   \   000000CA   0x2042             MOVS     R0,#+66
   \   000000CC   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   2020          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x........         DC32     OSTCBPrioTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x75 0x43          DC8 "uC/OS-II Idle"
   \              0x2F 0x4F    
   \              0x53 0x2D    
   \              0x49 0x49    
   \              0x20 0x49    
   \              0x64 0x6C    
   \              0x65 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSEventNameGet
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_StrCopy
      24   OSEventNameSet
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_StrCopy
      40   OSEventPendMulti
        40   -> OS_CPU_SR_Restore
        40   -> OS_CPU_SR_Save
        40   -> OS_EventTaskRemoveMulti
        40   -> OS_EventTaskWaitMulti
        40   -> OS_Sched
      40   OSInit
        40   -> OSDebugInit
        40   -> OSInitHookBegin
        40   -> OSInitHookEnd
        40   -> OSTaskCreateExt
        40   -> OSTaskNameSet
        40   -> OS_FlagInit
        40   -> OS_MemInit
        40   -> OS_QInit
        40   -> __aeabi_memclr4
       0   OSIntEnter
      16   OSIntExit
        16   -> OSIntCtxSw
         0   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
       8   OSSchedLock
         0   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
       8   OSSchedUnlock
         0   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
         0   -> OS_Sched
       0   OSStart
         0   -> OSStartHighRdy
      16   OSTimeTick
        16   -> OSTimeTickHook
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
       0   OSVersion
       0   OS_Dummy
      24   OS_EventTaskRdy
        24   -> OS_EventTaskRemove
        24   -> OS_EventTaskRemoveMulti
       0   OS_EventTaskRemove
      12   OS_EventTaskRemoveMulti
       0   OS_EventTaskWait
       8   OS_EventTaskWaitMulti
       0   OS_EventWaitListInit
         0   -> __aeabi_memclr
       0   OS_MemClr
         0   -> __aeabi_memclr
       0   OS_MemCopy
       8   OS_Sched
         8   -> OSCtxSw
         0   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
       0   OS_StrCopy
       0   OS_StrLen
      32   OS_TCBInit
        32   -> OSTCBInitHook
        32   -> OSTaskCreateHook
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save
       8   OS_TaskIdle
         8   -> OSTaskIdleHook
         8   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
      24   OS_TaskStatStkChk
        24   -> OSTaskStkChk


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable17_1
       8  ?Subroutine0
      16  ?_0
      68  OSEventNameGet
      92  OSEventNameSet
     482  OSEventPendMulti
       4  OSFlagFreeList
     140  OSFlagTbl
     342  OSInit
      22  OSIntEnter
     100  OSIntExit
    2440  OSIntNesting
          OSLockNesting
          OSPrioCur
          OSPrioHighRdy
          OSRdyGrp
          OSRunning
          OSTaskCtr
          OSTickStepState
          OSRdyTbl
          OSCtxSwCtr
          OSEventFreeList
          OSIdleCtr
          OSTCBCur
          OSTCBFreeList
          OSTCBHighRdy
          OSTCBList
          OSTime
          OSEventTbl
          OSTaskIdleStk
          OSTCBTbl
       4  OSMemFreeList
     180  OSMemTbl
       4  OSQFreeList
      96  OSQTbl
      34  OSSchedLock
      50  OSSchedUnlock
      50  OSStart
     128  OSTCBPrioTbl
     144  OSTimeTick
     256  OSUnMapTbl
       6  OSVersion
       2  OS_Dummy
     102  OS_EventTaskRdy
      32  OS_EventTaskRemove
      44  OS_EventTaskRemoveMulti
      70  OS_EventTaskWait
      84  OS_EventTaskWaitMulti
      12  OS_EventWaitListInit
      10  OS_MemClr
      16  OS_MemCopy
      72  OS_Sched
      28  OS_StrCopy
      18  OS_StrLen
     208  OS_TCBInit
      24  OS_TaskIdle
      54  OS_TaskStatStkChk

 
 2 996 bytes in section .bss
 2 454 bytes in section .text
 
 2 454 bytes of CODE memory
 2 996 bytes of DATA memory

Errors: none
Warnings: none
