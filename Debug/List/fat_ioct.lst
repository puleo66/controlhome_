###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       09/Feb/2018  16:14:50
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\HW Projects\ControlHome\CntrHome -
#        RF69w\uC-FatFS\fsl\fat\fat_ioct.c
#    Command line =  
#        "E:\HW Projects\ControlHome\CntrHome -
#        RF69w\uC-FatFS\fsl\fat\fat_ioct.c" -lCN "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Debug\List" -o "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Debug\Obj" --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\APP\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\BSP\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\CPU\inc\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-CPU\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-RTC\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-LIB\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uCOS-II\Ports\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uCOS-II\Source\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\I2C-Out\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Direct_Sw\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Wdt_led\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-LCD\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-RF\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\api\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\config\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\os\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\fsl\fat\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\clib\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\lbl\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\device\mmc\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\file\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-Terminal\src\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-Terminal\inc\" -Oh
#    List file    =  
#        E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\List\fat_ioct.lst
#    Object file  =  
#        E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\Obj\fat_ioct.o
#
###############################################################################

E:\HW Projects\ControlHome\CntrHome - RF69w\uC-FatFS\fsl\fat\fat_ioct.c
      1          /*
      2          **********************************************************************
      3          *                          Micrium, Inc.
      4          *                      949 Crestview Circle
      5          *                     Weston,  FL 33327-1848
      6          *
      7          *                            uC/FS
      8          *
      9          *             (c) Copyright 2001 - 2003, Micrium, Inc.
     10          *                      All rights reserved.
     11          *
     12          ***********************************************************************
     13          
     14          ----------------------------------------------------------------------
     15          File        : fat_ioctc.c
     16          Purpose     : FAT File System Layer IOCTL
     17          ----------------------------------------------------------------------
     18          Known problems or limitations with current version
     19          ----------------------------------------------------------------------
     20          None.
     21          ---------------------------END-OF-HEADER------------------------------
     22          */
     23          
     24          /*********************************************************************
     25          *
     26          *             #include Section
     27          *
     28          **********************************************************************
     29          */
     30          
     31          #include "fs_conf.h"
     32          #include "fs_port.h"
     33          #include "fs_dev.h"
     34          #include "fs_api.h"
     35          #include "fs_fsl.h"
     36          #include "fs_int.h"
     37          #include "fs_os.h"
     38          #include "fs_lbl.h"
     39          #include "fs_fat.h"
     40          #include "fs_clib.h"
     41          
     42          
     43          /*********************************************************************
     44          *
     45          *             #define constants
     46          *
     47          **********************************************************************
     48          */
     49          
     50          #define FS_KNOWNMEDIA_NUM   sizeof(_FS_wd_format_media_table) / sizeof(_FS_wd_format_media_type)
     51          
     52          #ifndef FS_FAT_NOFORMAT
     53            #define FS_FAT_NOFORMAT       0
     54          #endif
     55          
     56          #ifndef FS_FAT_DISKINFO
     57            #define FS_FAT_DISKINFO       1
     58          #endif
     59          
     60          #ifndef FS_SUPPORT_SEC_ACCESS
     61            #define FS_SUPPORT_SEC_ACCESS 1
     62          #endif
     63          
     64          /*********************************************************************
     65          *
     66          *             Local data types
     67          *
     68          **********************************************************************
     69          */
     70          
     71          #if (FS_FAT_NOFORMAT==0)
     72          
     73          typedef struct {
     74            FS_i32  media_id;
     75            FS_u32  totsec32;
     76            FS_u32  hiddsec;
     77            FS_u16  totsec16;
     78            FS_u16  rootentcnt;
     79            FS_u16  fatsz16;
     80            FS_u16  secpertrk;
     81            FS_u16  numheads;
     82            char    secperclus;
     83            char    media; 
     84            char    fsystype;
     85          } _FS_wd_format_media_type;
     86          
     87          
     88          typedef struct {
     89            FS_u32 SecNum;
     90            FS_u32 Num;
     91          } _FS_FAT_ROOTENTCNT ;
     92          
     93          
     94          typedef struct {
     95            FS_u32 SecNum;
     96            FS_u16 Num;
     97          } _FS_FAT_SECPERCLUST;
     98          
     99          
    100          /*********************************************************************
    101          *
    102          *             Local Variables        
    103          *
    104          **********************************************************************
    105          */
    106          
    107          /*  media_id              totsec32       hidsec    totsec16   rootent  fatsz16  secpertrk  numheads secperclus  media   fstype */ 

   \                                 In section .text, align 4, keep-with-next
    108          static const _FS_wd_format_media_type _FS_wd_format_media_table[] = {
   \                     _FS_wd_format_media_table:
   \   00000000   0x000007DA         DC32 2010, 0, 0
   \              0x00000000   
   \              0x00000000   
   \   0000000C   0x0020 0x0040      DC16 32, 64, 1, 4, 4
   \              0x0001 0x0004
   \              0x0004       
   \   00000016   0x01 0xF8          DC8 1, 248, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000001C   0x000007E4         DC32 2020, 0, 0
   \              0x00000000   
   \              0x00000000   
   \   00000028   0x0080 0x0040      DC16 128, 64, 1, 4, 4
   \              0x0001 0x0004
   \              0x0004       
   \   00000032   0x01 0xF8          DC8 1, 248, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000038   0x000007EE         DC32 2030, 0, 0
   \              0x00000000   
   \              0x00000000   
   \   00000044   0x0100 0x0080      DC16 256, 128, 1, 4, 4
   \              0x0001 0x0004
   \              0x0004       
   \   0000004E   0x01 0xF8          DC8 1, 248, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000054   0x000007F8         DC32 2040, 0, 0
   \              0x00000000   
   \              0x00000000   
   \   00000060   0x0200 0x0080      DC16 512, 128, 2, 4, 4
   \              0x0002 0x0004
   \              0x0004       
   \   0000006A   0x01 0xF8          DC8 1, 248, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000070   0x00000802         DC32 2050, 0, 0
   \              0x00000000   
   \              0x00000000   
   \   0000007C   0x0400 0x00E0      DC16 1024, 224, 3, 4, 4
   \              0x0003 0x0004
   \              0x0004       
   \   00000086   0x01 0xF8          DC8 1, 248, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000008C   0x00000BE0         DC32 3040, 0, 0
   \              0x00000000   
   \              0x00000000   
   \   00000098   0x0B40 0x00E0      DC16 2880, 224, 9, 18, 2
   \              0x0009 0x0012
   \              0x0002       
   \   000000A2   0x01 0xF0          DC8 1, 240, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000A8   0x000003F2         DC32 1010, 0, 13
   \              0x00000000   
   \              0x0000000D   
   \   000000B4   0x07C3 0x0100      DC16 1987, 256, 1, 4, 4
   \              0x0001 0x0004
   \              0x0004       
   \   000000BE   0x08 0xF8          DC8 8, 248, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000C4   0x000003FC         DC32 1020, 0, 11
   \              0x00000000   
   \              0x0000000B   
   \   000000D0   0x0F95 0x0100      DC16 3989, 256, 2, 8, 4
   \              0x0002 0x0008
   \              0x0004       
   \   000000DA   0x08 0xF8          DC8 8, 248, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000E0   0x00000406         DC32 1030, 0, 27
   \              0x00000000   
   \              0x0000001B   
   \   000000EC   0x1F25 0x0100      DC16 7973, 256, 2, 8, 4
   \              0x0002 0x0008
   \              0x0004       
   \   000000F6   0x10 0xF8          DC8 16, 248, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000FC   0x00000410         DC32 1040, 0, 25
   \              0x00000000   
   \              0x00000019   
   \   00000108   0x3E67 0x0100      DC16 15975, 256, 3, 16, 4
   \              0x0003 0x0010
   \              0x0004       
   \   00000112   0x10 0xF8          DC8 16, 248, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000118   0x0000041A         DC32 1050, 0, 41
   \              0x00000000   
   \              0x00000029   
   \   00000124   0x7CD7 0x0100      DC16 31959, 256, 3, 16, 4
   \              0x0003 0x0010
   \              0x0004       
   \   0000012E   0x20 0xF8          DC8 32, 248, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000134   0x00000424         DC32 1060, 0, 35
   \              0x00000000   
   \              0x00000023   
   \   00000140   0xF9DD 0x0100      DC16 63965, 256, 6, 16, 8
   \              0x0006 0x0010
   \              0x0008       
   \   0000014A   0x20 0xF8          DC8 32, 248, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000150   0x0000042E         DC32 1070, 127945, 55
   \              0x0001F3C9   
   \              0x00000037   
   \   0000015C   0x0000 0x0100      DC16 0, 256, 12, 32, 8
   \              0x000C 0x0020
   \              0x0008       
   \   00000166   0x20 0xF8          DC8 32, 248, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000016C   0x00000438         DC32 1080, 255953, 47
   \              0x0003E7D1   
   \              0x0000002F   
   \   00000178   0x0000 0x0100      DC16 0, 256, 32, 32, 16
   \              0x0020 0x0020
   \              0x0010       
   \   00000182   0x20 0xF8          DC8 32, 248, 1, 0, 0, 0
   \              0x01 0x00    
   \              0x00 0x00    
   \   00000188   0x00000FDC         DC32 4060, 0, 32
   \              0x00000000   
   \              0x00000020   
   \   00000194   0xF460 0x0200      DC16 62560, 512, 61, 32, 4
   \              0x003D 0x0020
   \              0x0004       
   \   0000019E   0x04 0xF8          DC8 4, 248, 1, 0, 0, 0
   \              0x01 0x00    
   \              0x00 0x00    
   \   000001A4   0x00000FE6         DC32 4070, 125152, 32
   \              0x0001E8E0   
   \              0x00000020   
   \   000001B0   0x0000 0x0200      DC16 0, 512, 122, 32, 8
   \              0x007A 0x0020
   \              0x0008       
   \   000001BA   0x04 0xF8          DC8 4, 248, 1, 0, 0, 0
   \              0x01 0x00    
   \              0x00 0x00    
   \   000001C0   0x00000FF0         DC32 4080, 250592, 32
   \              0x0003D2E0   
   \              0x00000020   
   \   000001CC   0x0000 0x0200      DC16 0, 512, 245, 32, 8
   \              0x00F5 0x0020
   \              0x0008       
   \   000001D6   0x04 0xF8          DC8 4, 248, 1, 0, 0, 0
   \              0x01 0x00    
   \              0x00 0x00    
   \   000001DC   0x000013BA         DC32 5050, 0, 57
   \              0x00000000   
   \              0x00000039   
   \   000001E8   0x7187 0x0200      DC16 29063, 512, 3, 32, 2
   \              0x0003 0x0020
   \              0x0002       
   \   000001F2   0x20 0xF8          DC8 32, 248, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   000001F8   0x000013CE         DC32 5070, 121817, 39
   \              0x0001DBD9   
   \              0x00000027   
   \   00000204   0x0000 0x0200      DC16 0, 512, 12, 32, 8
   \              0x000C 0x0020
   \              0x0008       
   \   0000020E   0x20 0xF8          DC8 32, 248, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000214   0x000013D8         DC32 5080, 245919, 97
   \              0x0003C09F   
   \              0x00000061   
   \   00000220   0x0000 0x0200      DC16 0, 512, 31, 32, 8
   \              0x001F 0x0020
   \              0x0008       
   \   0000022A   0x20 0xF8          DC8 32, 248, 1, 0, 0, 0
   \              0x01 0x00    
   \              0x00 0x00    
   \   00000230   0x000017AC         DC32 6060, 0, 32
   \              0x00000000   
   \              0x00000020   
   \   0000023C   0xF760 0x0200      DC16 63328, 512, 124, 32, 4
   \              0x007C 0x0020
   \              0x0004       
   \   00000246   0x02 0xF8          DC8 2, 248, 1, 0, 0, 0
   \              0x01 0x00    
   \              0x00 0x00    
   \   0000024C   0x000017B6         DC32 6070, 125024, 32
   \              0x0001E860   
   \              0x00000020   
   \   00000258   0x0000 0x0200      DC16 0, 512, 123, 32, 4
   \              0x007B 0x0020
   \              0x0004       
   \   00000262   0x04 0xF8          DC8 4, 248, 1, 0, 0, 0
   \              0x01 0x00    
   \              0x00 0x00    
    109            { FS_MEDIA_RAM_16KB,  0x00000000UL, 0x00000000UL, 0x0020,   0x0040,  0x0001,  0x0004,     0x0004,   0x01, (char) 0xf8, 0 },
    110            { FS_MEDIA_RAM_64KB,  0x00000000UL, 0x00000000UL, 0x0080,   0x0040,  0x0001,  0x0004,     0x0004,   0x01, (char) 0xf8, 0 },
    111            { FS_MEDIA_RAM_128KB, 0x00000000UL, 0x00000000UL, 0x0100,   0x0080,  0x0001,  0x0004,     0x0004,   0x01, (char) 0xf8, 0 },
    112            { FS_MEDIA_RAM_256KB, 0x00000000UL, 0x00000000UL, 0x0200,   0x0080,  0x0002,  0x0004,     0x0004,   0x01, (char) 0xf8, 0 },
    113            { FS_MEDIA_RAM_512KB, 0x00000000UL, 0x00000000UL, 0x0400,   0x00e0,  0x0003,  0x0004,     0x0004,   0x01, (char) 0xf8, 0 },
    114            { FS_MEDIA_FD_144MB,  0x00000000UL, 0x00000000UL, 0x0b40,   0x00e0,  0x0009,  0x0012,     0x0002,   0x01, (char) 0xf0, 0 },
    115            { FS_MEDIA_SMC_1MB,   0x00000000UL, 0x0000000DUL, 0x07c3,   0x0100,  0x0001,  0x0004,     0x0004,   0x08, (char) 0xf8, 0 },
    116            { FS_MEDIA_SMC_2MB,   0x00000000UL, 0x0000000bUL, 0x0f95,   0x0100,  0x0002,  0x0008,     0x0004,   0x08, (char) 0xf8, 0 },
    117            { FS_MEDIA_SMC_4MB,   0x00000000UL, 0x0000001bUL, 0x1f25,   0x0100,  0x0002,  0x0008,     0x0004,   0x10, (char) 0xf8, 0 },
    118            { FS_MEDIA_SMC_8MB,   0x00000000UL, 0x00000019UL, 0x3e67,   0x0100,  0x0003,  0x0010,     0x0004,   0x10, (char) 0xf8, 0 },
    119            { FS_MEDIA_SMC_16MB,  0x00000000UL, 0x00000029UL, 0x7cd7,   0x0100,  0x0003,  0x0010,     0x0004,   0x20, (char) 0xf8, 0 },
    120            { FS_MEDIA_SMC_32MB,  0x00000000UL, 0x00000023UL, 0xf9dd,   0x0100,  0x0006,  0x0010,     0x0008,   0x20, (char) 0xf8, 0 },
    121            { FS_MEDIA_SMC_64MB,  0x0001f3c9UL, 0x00000037UL, 0x0000,   0x0100,  0x000c,  0x0020,     0x0008,   0x20, (char) 0xf8, 0 },
    122            { FS_MEDIA_SMC_128MB, 0x0003e7d1UL, 0x0000002fUL, 0x0000,   0x0100,  0x0020,  0x0020,     0x0010,   0x20, (char) 0xf8, 1 },
    123            { FS_MEDIA_MMC_32MB,  0x00000000UL, 0x00000020UL, 0xf460,   0x0200,  0x003d,  0x0020,     0x0004,   0x04, (char) 0xf8, 1 },
    124            { FS_MEDIA_MMC_64MB,  0x0001e8e0UL, 0x00000020UL, 0x0000,   0x0200,  0x007a,  0x0020,     0x0008,   0x04, (char) 0xf8, 1 },
    125            { FS_MEDIA_MMC_128MB, 0x0003d2e0UL, 0x00000020UL, 0x0000,   0x0200,  0x00f5,  0x0020,     0x0008,   0x04, (char) 0xf8, 1 },
    126            { FS_MEDIA_SD_16MB,   0x00000000UL, 0x00000039UL, 0x7187,   0x0200,  0x0003,  0x0020,     0x0002,   0x20, (char) 0xf8, 0 },
    127            { FS_MEDIA_SD_64MB,   0x0001dbd9UL, 0x00000027UL, 0x0000,   0x0200,  0x000c,  0x0020,     0x0008,   0x20, (char) 0xf8, 0 },
    128            { FS_MEDIA_SD_128MB,  0x0003c09fUL, 0x00000061UL, 0x0000,   0x0200,  0x001f,  0x0020,     0x0008,   0x20, (char) 0xf8, 1 },
    129            { FS_MEDIA_CF_32MB,   0x00000000UL, 0x00000020UL, 0xf760,   0x0200,  0x007c,  0x0020,     0x0004,   0x02, (char) 0xf8, 1 },
    130            { FS_MEDIA_CF_64MB,   0x0001e860UL, 0x00000020UL, 0x0000,   0x0200,  0x007b,  0x0020,     0x0004,   0x04, (char) 0xf8, 1 }
    131          };
    132          
    133          
    134          /* table for getting number of root entries for a given media size */

   \                                 In section .text, align 4, keep-with-next
    135          static const _FS_FAT_ROOTENTCNT _FS_auto_rootcnt[] = {
   \                     _FS_auto_rootcnt:
   \   00000000   0x00000100         DC32 256, 64, 512, 128, 2880, 224, 127945, 256, 4294967295, 512
   \              0x00000040   
   \              0x00000200   
   \              0x00000080   
   \              0x00000B40   
   \              0x000000E0   
   \              0x0001F3C9   
   \              0x00000100   
   \              0xFFFFFFFF   
   \              0x00000200   
    136            {         0x100,     0x40 },
    137            {         0x200,     0x80 },
    138            {      0x0b40UL,     0xe0 },
    139            {  0x0001f3c9UL,    0x100 },
    140            {  0xffffffffUL,    0x200 }
    141          };
    142          
    143          
    144          /* table for calculating cluster size */

   \                                 In section .text, align 4, keep-with-next
    145          static const _FS_FAT_SECPERCLUST _FS_auto_secperclust[] = {
   \                     _FS_auto_secperclust:
   \   00000000   0x00000B40         DC32 2880
   \   00000004   0x0001             DC16 1
   \   00000006   0x00 0x00          DC8 0, 0
   \   00000008   0x00007FA8         DC32 32680
   \   0000000C   0x0002             DC16 2
   \   0000000E   0x00 0x00          DC8 0, 0
   \   00000010   0x00040000         DC32 262144
   \   00000014   0x0004             DC16 4
   \   00000016   0x00 0x00          DC8 0, 0
   \   00000018   0x00080000         DC32 524288
   \   0000001C   0x0008             DC16 8
   \   0000001E   0x00 0x00          DC8 0, 0
   \   00000020   0x00100000         DC32 1048576
   \   00000024   0x0010             DC16 16
   \   00000026   0x00 0x00          DC8 0, 0
   \   00000028   0x01000000         DC32 16777216
   \   0000002C   0x0008             DC16 8
   \   0000002E   0x00 0x00          DC8 0, 0
   \   00000030   0x02000000         DC32 33554432
   \   00000034   0x0010             DC16 16
   \   00000036   0x00 0x00          DC8 0, 0
   \   00000038   0x04000000         DC32 67108864
   \   0000003C   0x0020             DC16 32
   \   0000003E   0x00 0x00          DC8 0, 0
   \   00000040   0xFFFFFFFF         DC32 4294967295
   \   00000044   0x0040             DC16 64
   \   00000046   0x00 0x00          DC8 0, 0
    146            /* medias up to 512MB are formatted with FAT16 */
    147            {     0x0b40UL, 0x0001 },
    148            {      32680UL, 0x0002 },
    149            {     262144UL, 0x0004 },
    150            {     524288UL, 0x0008 },
    151            {    1048576UL, 0x0010 },
    152            /* medias bigger than 512MB are formatted with FAT32 */
    153            {   16777216UL, 0x0008 },
    154            {   33554432UL, 0x0010 },
    155            {   67108864UL, 0x0020 },
    156            { 0xffffffffUL, 0x0040 }
    157          };
    158          
    159          
    160          #endif /* FS_FAT_NOFORMAT==0 */
    161          
    162          /*********************************************************************
    163          *
    164          *             Local functions
    165          *
    166          **********************************************************************
    167          */
    168          
    169          #if (FS_FAT_NOFORMAT==0)
    170          
    171          /*********************************************************************
    172          *
    173          *             _FS_fat_format
    174          *
    175            Description:
    176            FS internal function. Format a media using specified parameters.
    177            Currently this function needs many parameters. The function will be
    178            improved. 
    179          
    180            Parameters:
    181            pDriver     - Pointer to a device driver function table.
    182            Unit        - Unit number.
    183            SecPerClus  - Number of sector per allocation unit.
    184            RootEntCnt  - For FAT12/FAT16, this is the number of 32 byte root
    185                          directory entries. 0 for FAT32.
    186            TotSec16    - 16-bit total count of sectors. If zero, TotSec32 must 
    187                          be none-zero.
    188            TotSec32    - 32-bit total count of sectors. If zero, TotSec16 must 
    189                          be none-zero.
    190            Media       - Media byte.
    191            FATSz16     - 16-bit count of sectors occupied by one FAT. 0 for
    192                          FAT32 volumes, which use FATSz32.
    193            FATSz32     - 32-bit count of sectors occupied by one FAT. This is
    194                          valid for FAT32 medias only.
    195            SecPerTrk   - Sectors per track.
    196            NumHeads    - Number of heads.
    197            HiddSec     - Count of hidden sectors preceding the partition.
    198            FSysType    - ==0 => FAT12
    199                          ==1 => FAT16
    200                          ==2 => FAT32
    201            
    202            Return value:
    203            >=0         - Media has been formatted.
    204            <0          - An error has occured.
    205          */
    206          
    207          

   \                                 In section .text, align 2, keep-with-next
    208          static int _FS_fat_format(const FS__device_type *pDriver,FS_u32 Unit, char SecPerClus, 
    209                                    FS_u16 RootEntCnt, FS_u16 TotSec16, FS_u32 TotSec32, char Media, 
    210                                    FS_u16 FATSz16, FS_u32 FATSz32, FS_u16 SecPerTrk,FS_u16 NumHeads, 
    211                                    FS_u32 HiddSec, char FSysType) {
   \                     _FS_fat_format: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0x4682             MOV      R10,R0
   \   00000006   0xB089             SUB      SP,SP,#+36
   \   00000008   0x468B             MOV      R11,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x461D             MOV      R5,R3
    212            FS__FAT_BPB bpb;
    213            FS_u32 sector;
    214            FS_u32 value;
    215            char *buffer;
    216            int i;
    217            int j;
    218            int n;
    219            
    220            buffer = FS__fat_malloc(FS_FAT_SEC_SIZE);
   \   0000000E   0xF44F 0x7000      MOV      R0,#+512
   \   00000012   0x.... 0x....      BL       FS__fat_malloc
   \   00000016   0x0004             MOVS     R4,R0
    221            if (!buffer) {
   \   00000018   0xF000 0x81C6      BEQ.W    ??_FS_fat_format_0
    222              return -1;
    223            }
    224            FS__CLIB_memset(buffer, 0x00, (FS_size_t)FS_FAT_SEC_SIZE);
   \   0000001C   0xF44F 0x7200      MOV      R2,#+512
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x.... 0x....      BL       FS__CLIB_memset
    225            /* Setup BPB */
    226            FS__CLIB_memset(&bpb, 0x00, (FS_size_t)sizeof(bpb));
   \   00000026   0x2220             MOVS     R2,#+32
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x4668             MOV      R0,SP
   \   0000002C   0x.... 0x....      BL       FS__CLIB_memset
    227            bpb.BytesPerSec = 0x0200;       /* _512_,1024,2048,4096           */
    228            bpb.SecPerClus  = SecPerClus;   /* sec in allocation unit         */
   \   00000030   0xF8DD 0x8068      LDR      R8,[SP, #+104]
   \   00000034   0xF88D 0x601C      STRB     R6,[SP, #+28]
   \   00000038   0xF44F 0x7000      MOV      R0,#+512
   \   0000003C   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    229            if (FSysType != 2) {
   \   00000040   0x46C1             MOV      R9,R8
   \   00000042   0xF1B9 0x0F02      CMP      R9,#+2
   \   00000046   0xBF14             ITE      NE 
   \   00000048   0x2001             MOVNE    R0,#+1
   \   0000004A   0x2020             MOVEQ    R0,#+32
    230              bpb.RsvdSecCnt  = 0x0001;       /* 1 for FAT12 & FAT16            */
    231            }
    232          #if (FS_FAT_NOFAT32==0)
    233            else {
    234              bpb.RsvdSecCnt  = 0x0020;       /* 32 for FAT32                   */
   \   0000004C   0xF8AD 0x001A      STRH     R0,[SP, #+26]
    235            }
    236          #else
    237            /* FAT32 disabled */
    238            else {
    239              FS__fat_free(buffer);
    240              return -1;
    241            }
    242          #endif /* FS_FAT_NOFAT32==0 */
    243            bpb.NumFATs     = 0x02;         /* 2                              */
    244            bpb.RootEntCnt  = RootEntCnt;   /* number of root dir entries     */
   \   00000050   0xF8AD 0x500E      STRH     R5,[SP, #+14]
   \   00000054   0x2002             MOVS     R0,#+2
   \   00000056   0xF88D 0x001D      STRB     R0,[SP, #+29]
    245            bpb.TotSec16    = TotSec16;     /* RSVD+FAT+ROOT+DATA (<64k)      */
    246            bpb.FATSz16     = FATSz16;      /* number of FAT sectors          */
    247            bpb.TotSec32    = TotSec32;     /* RSVD+FAT+ROOT+FATA (>=64k)     */
    248            bpb.Signature   = 0xaa55;       /* 0xAA55 Signature               */
    249          
    250            /* setup BPB specifics for FAT32 */
    251            bpb.FATSz32     = FATSz32;      /* number of FAT sectors          */
    252            bpb.ExtFlags    = 0x0000;       /* mirroring info                 */
    253            bpb.RootClus    = 0x00000002UL; /* root dir clus for FAT32        */
    254            bpb.FSInfo      = 0x0001;       /* position of FSInfo structure   */
    255          
    256            /* 
    257               Prepare buffer with information of the BPB 
    258               offset 0 - 35 is same for FAT12/FAT16 and FAT32 
    259            */
    260          
    261            /* jmpBoot = 0xe9 0x0000 */
    262            buffer[0]   = (char)0xe9;
    263            buffer[1]   = (char)0x00;
    264            buffer[2]   = (char)0x00;
    265            /* OEMName = '        ' */
    266            for (i = 3; i < 11; i++) {
    267              buffer[i] = (char)0x20;
   \   0000005A   0x2220             MOVS     R2,#+32
   \   0000005C   0x9812             LDR      R0,[SP, #+72]
   \   0000005E   0xF8AD 0x0010      STRH     R0,[SP, #+16]
   \   00000062   0x2108             MOVS     R1,#+8
   \   00000064   0x9815             LDR      R0,[SP, #+84]
   \   00000066   0xF8AD 0x0012      STRH     R0,[SP, #+18]
    268            }
    269            /* BytesPerSec */
    270            buffer[11]  = (char)(bpb.BytesPerSec & 0xff);
    271            buffer[12]  = (char)((unsigned int)(bpb.BytesPerSec & 0xff00) >> 8);
    272            /* SecPerClus */
    273            buffer[13]  = (char)bpb.SecPerClus;
    274            /* RsvdSecCnt */
    275            buffer[14]  = (char)(bpb.RsvdSecCnt & 0xff);
    276            buffer[15]  = (char)((unsigned int)(bpb.RsvdSecCnt & 0xff00) >> 8);
    277            /* NumFATs */
    278            buffer[16]  = (char)bpb.NumFATs;
    279            /* RootEntCnt */
    280            buffer[17]  = (char)(bpb.RootEntCnt & 0xff);
    281            buffer[18]  = (char)((unsigned int)(bpb.RootEntCnt & 0xff00) >> 8);
    282            /* TotSec16 */
    283            buffer[19]  = (char)(bpb.TotSec16 & 0xff);
    284            buffer[20]  = (char)((unsigned int)(bpb.TotSec16 & 0xff00) >> 8);
    285            /* Media */
    286            buffer[21]  = Media;
    287            /* FATSz16 */
    288            buffer[22]  = (char)(bpb.FATSz16 & 0xff);
    289            buffer[23]  = (char)((unsigned int)(bpb.FATSz16 & 0xff00) >> 8);
    290            /* SecPerTrk */
    291            buffer[24]  = (char)(SecPerTrk & 0xff);
    292            buffer[25]  = (char)((unsigned int)(SecPerTrk & 0xff00) >> 8);
    293            /* NumHeads */
    294            buffer[26]  = (char)(NumHeads & 0xff);
    295            buffer[27]  = (char)((unsigned int)(NumHeads & 0xff00) >> 8);
    296            /* HiddSec */
    297            buffer[28]  = (char)(HiddSec & 0xff);
    298            buffer[29]  = (char)((FS_u32)(HiddSec & 0x0000ff00UL) >> 8);
    299            buffer[30]  = (char)((FS_u32)(HiddSec & 0x00ff0000UL) >> 16);
    300            buffer[31]  = (char)((FS_u32)(HiddSec & 0xff000000UL) >> 24);
    301            /* TotSec32 */
    302            buffer[32]  = (char)(bpb.TotSec32 & 0xff);
    303            buffer[33]  = (char)((FS_u32)(bpb.TotSec32 & 0x0000ff00UL) >> 8);
   \   0000006A   0xF104 0x0621      ADD      R6,R4,#+33
   \   0000006E   0x9813             LDR      R0,[SP, #+76]
   \   00000070   0x9000             STR      R0,[SP, #+0]
   \   00000072   0xF64A 0x2055      MOVW     R0,#+43605
   \   00000076   0xF8AD 0x0018      STRH     R0,[SP, #+24]
   \   0000007A   0x9816             LDR      R0,[SP, #+88]
   \   0000007C   0x9001             STR      R0,[SP, #+4]
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xF8AD 0x0014      STRH     R0,[SP, #+20]
   \   00000084   0x2002             MOVS     R0,#+2
   \   00000086   0x9002             STR      R0,[SP, #+8]
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0xF8AD 0x0016      STRH     R0,[SP, #+22]
   \   0000008E   0x20E9             MOVS     R0,#+233
   \   00000090   0x7020             STRB     R0,[R4, #+0]
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x7060             STRB     R0,[R4, #+1]
   \   00000096   0x70A0             STRB     R0,[R4, #+2]
   \   00000098   0x1CE0             ADDS     R0,R4,#+3
   \   0000009A   0x.... 0x....      BL       __aeabi_memset
   \   0000009E   0xF8BD 0x000C      LDRH     R0,[SP, #+12]
   \   000000A2   0x72E0             STRB     R0,[R4, #+11]
   \   000000A4   0xF8BD 0x000C      LDRH     R0,[SP, #+12]
   \   000000A8   0x0A00             LSRS     R0,R0,#+8
   \   000000AA   0x7320             STRB     R0,[R4, #+12]
   \   000000AC   0xF89D 0x001C      LDRB     R0,[SP, #+28]
   \   000000B0   0x7360             STRB     R0,[R4, #+13]
   \   000000B2   0xF8BD 0x001A      LDRH     R0,[SP, #+26]
   \   000000B6   0x73A0             STRB     R0,[R4, #+14]
   \   000000B8   0xF8BD 0x001A      LDRH     R0,[SP, #+26]
   \   000000BC   0x0A00             LSRS     R0,R0,#+8
   \   000000BE   0x73E0             STRB     R0,[R4, #+15]
   \   000000C0   0xF89D 0x001D      LDRB     R0,[SP, #+29]
   \   000000C4   0x7420             STRB     R0,[R4, #+16]
   \   000000C6   0xF8BD 0x000E      LDRH     R0,[SP, #+14]
   \   000000CA   0x7460             STRB     R0,[R4, #+17]
   \   000000CC   0xF8BD 0x000E      LDRH     R0,[SP, #+14]
   \   000000D0   0x0A00             LSRS     R0,R0,#+8
   \   000000D2   0x74A0             STRB     R0,[R4, #+18]
   \   000000D4   0xF8BD 0x0010      LDRH     R0,[SP, #+16]
   \   000000D8   0x74E0             STRB     R0,[R4, #+19]
   \   000000DA   0xF8BD 0x0010      LDRH     R0,[SP, #+16]
   \   000000DE   0x0A00             LSRS     R0,R0,#+8
   \   000000E0   0x7520             STRB     R0,[R4, #+20]
   \   000000E2   0x9D14             LDR      R5,[SP, #+80]
   \   000000E4   0x7565             STRB     R5,[R4, #+21]
   \   000000E6   0xF8BD 0x0012      LDRH     R0,[SP, #+18]
   \   000000EA   0x75A0             STRB     R0,[R4, #+22]
   \   000000EC   0xF8BD 0x0012      LDRH     R0,[SP, #+18]
   \   000000F0   0x0A00             LSRS     R0,R0,#+8
   \   000000F2   0x75E0             STRB     R0,[R4, #+23]
   \   000000F4   0x9817             LDR      R0,[SP, #+92]
   \   000000F6   0x7620             STRB     R0,[R4, #+24]
   \   000000F8   0x0A00             LSRS     R0,R0,#+8
   \   000000FA   0x7660             STRB     R0,[R4, #+25]
   \   000000FC   0x9818             LDR      R0,[SP, #+96]
   \   000000FE   0x76A0             STRB     R0,[R4, #+26]
   \   00000100   0x0A00             LSRS     R0,R0,#+8
   \   00000102   0x76E0             STRB     R0,[R4, #+27]
   \   00000104   0x9819             LDR      R0,[SP, #+100]
   \   00000106   0x7720             STRB     R0,[R4, #+28]
   \   00000108   0x0A01             LSRS     R1,R0,#+8
   \   0000010A   0x7761             STRB     R1,[R4, #+29]
   \   0000010C   0x0C01             LSRS     R1,R0,#+16
   \   0000010E   0x77A1             STRB     R1,[R4, #+30]
   \   00000110   0x0E00             LSRS     R0,R0,#+24
   \   00000112   0x77E0             STRB     R0,[R4, #+31]
   \   00000114   0x9800             LDR      R0,[SP, #+0]
   \   00000116   0xF884 0x0020      STRB     R0,[R4, #+32]
   \   0000011A   0x9800             LDR      R0,[SP, #+0]
   \   0000011C   0x0A00             LSRS     R0,R0,#+8
   \   0000011E   0x7030             STRB     R0,[R6, #+0]
    304            buffer[34]  = (char)((FS_u32)(bpb.TotSec32 & 0x00ff0000UL) >> 16);
   \   00000120   0x9800             LDR      R0,[SP, #+0]
   \   00000122   0x0C00             LSRS     R0,R0,#+16
   \   00000124   0x7070             STRB     R0,[R6, #+1]
    305            buffer[35]  = (char)((FS_u32)(bpb.TotSec32 & 0xff000000UL) >> 24);
   \   00000126   0x9800             LDR      R0,[SP, #+0]
   \   00000128   0x0E00             LSRS     R0,R0,#+24
    306          
    307            /* Offset 36 and above have different meanings for FAT12/FAT16 and FAT32 */
    308            if (FSysType != 2) {
   \   0000012A   0xF1B9 0x0F02      CMP      R9,#+2
   \   0000012E   0x70B0             STRB     R0,[R6, #+2]
   \   00000130   0xD01D             BEQ.N    ??_FS_fat_format_1
    309              /* FAT12/FAT16 */
    310              /* DrvNum = 0x00 (floppy) */
    311              buffer[36]  = (char)0x00;  
   \   00000132   0x2000             MOVS     R0,#+0
   \   00000134   0x70F0             STRB     R0,[R6, #+3]
    312              /* Reserved1 = 0x00 (floppy) */
    313              buffer[37]  = (char)0x00;
   \   00000136   0x7130             STRB     R0,[R6, #+4]
    314              /* BootSig = 0x00 (next three fields are not 'present') */
    315              buffer[38]  = (char)0x00;
   \   00000138   0x7170             STRB     R0,[R6, #+5]
    316              /* VolID = 0x00000000 (serial number, e.g. date/time) */
    317              for (i = 39; i < 43; i++) {
    318                buffer[i] = (char)0x00;
   \   0000013A   0x2104             MOVS     R1,#+4
   \   0000013C   0xF104 0x0027      ADD      R0,R4,#+39
   \   00000140   0x.... 0x....      BL       __aeabi_memclr
    319              }
    320              /* VolLab = ' ' */
    321              for (i = 43; i < 54; i++) {
    322                buffer[i] = (char)0x20;
   \   00000144   0x2220             MOVS     R2,#+32
   \   00000146   0x210B             MOVS     R1,#+11
   \   00000148   0xF104 0x002B      ADD      R0,R4,#+43
   \   0000014C   0x.... 0x....      BL       __aeabi_memset
    323              }
    324              /* FilSysType = 'FAT12' */
    325              if (FSysType == 0) {
   \   00000150   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000154   0xD105             BNE.N    ??_FS_fat_format_2
    326                FS__CLIB_strncpy(&buffer[54], "FAT12   ", 8);
   \   00000156   0x2208             MOVS     R2,#+8
   \   00000158   0x.... 0x....      ADR.W    R1,?_0
   \   0000015C   0xF104 0x0036      ADD      R0,R4,#+54
   \   00000160   0xE04C             B.N      ??_FS_fat_format_3
    327              }
    328              else {
    329                FS__CLIB_strncpy(&buffer[54], "FAT16   ", 8);
   \                     ??_FS_fat_format_2: (+1)
   \   00000162   0x2208             MOVS     R2,#+8
   \   00000164   0x.... 0x....      ADR.W    R1,?_1
   \   00000168   0xF104 0x0036      ADD      R0,R4,#+54
   \   0000016C   0xE046             B.N      ??_FS_fat_format_3
    330              }
    331            }
    332          #if (FS_FAT_NOFAT32==0)
    333            else {
    334              /* FAT32 */
    335              /* FATSz32 */
    336              buffer[36]  = (char)(bpb.FATSz32 & 0xff);
   \                     ??_FS_fat_format_1: (+1)
   \   0000016E   0x9801             LDR      R0,[SP, #+4]
   \   00000170   0x70F0             STRB     R0,[R6, #+3]
    337              buffer[37]  = (char)((FS_u32)(bpb.FATSz32 & 0x0000ff00UL) >> 8);
    338              buffer[38]  = (char)((FS_u32)(bpb.FATSz32 & 0x00ff0000UL) >> 16);
    339              buffer[39]  = (char)((FS_u32)(bpb.FATSz32 & 0xff000000UL) >> 24);
    340              /* EXTFlags */
    341              buffer[40]  = (char)(bpb.ExtFlags & 0xff);
    342              buffer[41]  = (char)((unsigned int)(bpb.ExtFlags & 0xff00) >> 8);
    343              /* FSVer = 0:0 */
    344              buffer[42]  = 0x00;
    345              buffer[43]  = 0x00;
    346              /* RootClus */
    347              buffer[44]  = (char)(bpb.RootClus & 0xff);
    348              buffer[45]  = (char)((FS_u32)(bpb.RootClus & 0x0000ff00UL) >> 8);
    349              buffer[46]  = (char)((FS_u32)(bpb.RootClus & 0x00ff0000UL) >> 16);
    350              buffer[47]  = (char)((FS_u32)(bpb.RootClus & 0xff000000UL) >> 24);
    351              /* FSInfo */
    352              buffer[48]  = (char)(bpb.FSInfo & 0xff);
    353              buffer[49]  = (char)((unsigned int)(bpb.FSInfo & 0xff00) >> 8);
    354              /* BkBootSec = 0x0006; */
    355              buffer[50]  = 0x06;
    356              buffer[51]  = 0x00;
    357              /* Reserved */
    358              for (i = 52; i < 64; i++) {
    359                buffer[i] = (char)0x00;
   \   00000172   0x210C             MOVS     R1,#+12
   \   00000174   0x9801             LDR      R0,[SP, #+4]
   \   00000176   0x0A00             LSRS     R0,R0,#+8
   \   00000178   0x7130             STRB     R0,[R6, #+4]
   \   0000017A   0x9801             LDR      R0,[SP, #+4]
   \   0000017C   0x0C00             LSRS     R0,R0,#+16
   \   0000017E   0x7170             STRB     R0,[R6, #+5]
   \   00000180   0x9801             LDR      R0,[SP, #+4]
   \   00000182   0x0E00             LSRS     R0,R0,#+24
   \   00000184   0x71B0             STRB     R0,[R6, #+6]
   \   00000186   0xF8BD 0x0014      LDRH     R0,[SP, #+20]
   \   0000018A   0x71F0             STRB     R0,[R6, #+7]
   \   0000018C   0xF8BD 0x0014      LDRH     R0,[SP, #+20]
   \   00000190   0x0A00             LSRS     R0,R0,#+8
   \   00000192   0x7230             STRB     R0,[R6, #+8]
   \   00000194   0x2000             MOVS     R0,#+0
   \   00000196   0x7270             STRB     R0,[R6, #+9]
   \   00000198   0x72B0             STRB     R0,[R6, #+10]
   \   0000019A   0x9802             LDR      R0,[SP, #+8]
   \   0000019C   0x72F0             STRB     R0,[R6, #+11]
   \   0000019E   0x9802             LDR      R0,[SP, #+8]
   \   000001A0   0x0A00             LSRS     R0,R0,#+8
   \   000001A2   0x7330             STRB     R0,[R6, #+12]
   \   000001A4   0x9802             LDR      R0,[SP, #+8]
   \   000001A6   0x0C00             LSRS     R0,R0,#+16
   \   000001A8   0x7370             STRB     R0,[R6, #+13]
   \   000001AA   0x9802             LDR      R0,[SP, #+8]
   \   000001AC   0x0E00             LSRS     R0,R0,#+24
   \   000001AE   0x73B0             STRB     R0,[R6, #+14]
   \   000001B0   0xF8BD 0x0016      LDRH     R0,[SP, #+22]
   \   000001B4   0x73F0             STRB     R0,[R6, #+15]
   \   000001B6   0xF8BD 0x0016      LDRH     R0,[SP, #+22]
   \   000001BA   0x0A00             LSRS     R0,R0,#+8
   \   000001BC   0x7430             STRB     R0,[R6, #+16]
   \   000001BE   0x2006             MOVS     R0,#+6
   \   000001C0   0x7470             STRB     R0,[R6, #+17]
   \   000001C2   0x2000             MOVS     R0,#+0
   \   000001C4   0x74B0             STRB     R0,[R6, #+18]
   \   000001C6   0xF104 0x0034      ADD      R0,R4,#+52
   \   000001CA   0x.... 0x....      BL       __aeabi_memclr
    360              }
    361              /* DrvNum = 0x00 (floppy) */
    362              buffer[64]  = (char)0x00;
   \   000001CE   0x2000             MOVS     R0,#+0
   \   000001D0   0x77F0             STRB     R0,[R6, #+31]
    363              /* Reserved1 = 0x00 (floppy) */
    364              buffer[65]  = (char)0x00;
   \   000001D2   0x2100             MOVS     R1,#+0
   \   000001D4   0xF104 0x0041      ADD      R0,R4,#+65
   \   000001D8   0x7001             STRB     R1,[R0, #+0]
    365              /* BootSig = 0x00 (next three fields are not 'present') */
    366              buffer[66]  = (char)0x00;
   \   000001DA   0x7041             STRB     R1,[R0, #+1]
    367              /* VolID = 0x00000000 (serial number, e.g. date/time) */
    368              for (i = 67; i < 71; i++) {
    369                buffer[i] = (char)0x00;
   \   000001DC   0xF104 0x0043      ADD      R0,R4,#+67
   \   000001E0   0x2104             MOVS     R1,#+4
   \   000001E2   0x.... 0x....      BL       __aeabi_memclr
    370              }
    371              /* VolLab = ' ' */
    372              for (i = 71; i < 82; i++) {
    373                buffer[i] = (char)0x20;
   \   000001E6   0x2220             MOVS     R2,#+32
   \   000001E8   0x210B             MOVS     R1,#+11
   \   000001EA   0xF104 0x0047      ADD      R0,R4,#+71
   \   000001EE   0x.... 0x....      BL       __aeabi_memset
    374              }
    375              /* FilSysType = 'FAT12' */
    376              FS__CLIB_strncpy(&buffer[82], "FAT32   ", 8);
   \   000001F2   0x2208             MOVS     R2,#+8
   \   000001F4   0x.... 0x....      ADR.W    R1,?_2
   \   000001F8   0xF104 0x0052      ADD      R0,R4,#+82
   \                     ??_FS_fat_format_3: (+1)
   \   000001FC   0x.... 0x....      BL       FS__CLIB_strncpy
    377            }
    378          #endif /* FS_FAT_NOFAT32==0 */
    379            /* Signature = 0xAA55 */
    380            buffer[510] = (char)0x55;
   \   00000200   0xF504 0x76F2      ADD      R6,R4,#+484
   \   00000204   0x2055             MOVS     R0,#+85
   \   00000206   0x76B0             STRB     R0,[R6, #+26]
    381            buffer[511] = (char)0xaa;
    382            /* Write BPB to media */
    383            i = FS__lb_write(pDriver, Unit, 0, (void*)buffer);
    384            if (i < 0) {
   \   00000208   0x4623             MOV      R3,R4
   \   0000020A   0x20AA             MOVS     R0,#+170
   \   0000020C   0x76F0             STRB     R0,[R6, #+27]
   \   0000020E   0x2200             MOVS     R2,#+0
   \   00000210   0x4659             MOV      R1,R11
   \   00000212   0x4650             MOV      R0,R10
   \   00000214   0x.... 0x....      BL       FS__lb_write
   \   00000218   0x2800             CMP      R0,#+0
   \   0000021A   0xF100 0x80C2      BMI.W    ??_FS_fat_format_4
    385              FS__fat_free(buffer);
    386              return -1;
    387            }
    388            if (FSysType == 2) {
   \   0000021E   0xF1B9 0x0F02      CMP      R9,#+2
   \   00000222   0xD108             BNE.N    ??_FS_fat_format_5
    389              /* Write backup BPB */
    390              i = FS__lb_write(pDriver, Unit, 6, (void*)buffer);
    391              if (i<0) {
   \   00000224   0x4623             MOV      R3,R4
   \   00000226   0x2206             MOVS     R2,#+6
   \   00000228   0x4659             MOV      R1,R11
   \   0000022A   0x4650             MOV      R0,R10
   \   0000022C   0x.... 0x....      BL       FS__lb_write
   \   00000230   0x2800             CMP      R0,#+0
   \   00000232   0xF100 0x80B6      BMI.W    ??_FS_fat_format_4
    392                FS__fat_free(buffer);
    393                return -1;
    394              }
    395            }
    396            /*  Init FAT 1 & 2   */
    397            FS__CLIB_memset(buffer, 0x00, (FS_size_t)FS_FAT_SEC_SIZE);
   \                     ??_FS_fat_format_5: (+1)
   \   00000236   0xF44F 0x7200      MOV      R2,#+512
   \   0000023A   0x2100             MOVS     R1,#+0
   \   0000023C   0x4620             MOV      R0,R4
   \   0000023E   0x.... 0x....      BL       FS__CLIB_memset
    398            for (sector = 0; sector < 2 * (bpb.FATSz16 + bpb.FATSz32); sector++) {
   \   00000242   0x2700             MOVS     R7,#+0
   \   00000244   0xE010             B.N      ??_FS_fat_format_6
    399              value = sector % (bpb.FATSz16 + bpb.FATSz32);
    400              if (value != 0) {
   \                     ??_FS_fat_format_7: (+1)
   \   00000246   0xFBB7 0xF1F0      UDIV     R1,R7,R0
   \   0000024A   0xFB00 0x7011      MLS      R0,R0,R1,R7
   \   0000024E   0xB150             CBZ.N    R0,??_FS_fat_format_8
    401                i = FS__lb_write(pDriver, Unit, bpb.RsvdSecCnt + sector, (void*)buffer);
    402                if (i<0) {
   \   00000250   0xF8BD 0x001A      LDRH     R0,[SP, #+26]
   \   00000254   0x183A             ADDS     R2,R7,R0
   \   00000256   0x4623             MOV      R3,R4
   \   00000258   0x4659             MOV      R1,R11
   \   0000025A   0x4650             MOV      R0,R10
   \   0000025C   0x.... 0x....      BL       FS__lb_write
   \   00000260   0x2800             CMP      R0,#+0
   \   00000262   0xF100 0x809E      BMI.W    ??_FS_fat_format_4
    403                  FS__fat_free(buffer);
    404                  return -1;
    405                }
    406              }
    407            }
   \                     ??_FS_fat_format_8: (+1)
   \   00000266   0x1C7F             ADDS     R7,R7,#+1
   \                     ??_FS_fat_format_6: (+1)
   \   00000268   0xF8BD 0x0012      LDRH     R0,[SP, #+18]
   \   0000026C   0x9901             LDR      R1,[SP, #+4]
   \   0000026E   0x1808             ADDS     R0,R1,R0
   \   00000270   0xEBB7 0x0F40      CMP      R7,R0, LSL #+1
   \   00000274   0xD3E7             BCC.N    ??_FS_fat_format_7
    408            buffer[0] = (char)Media;
   \   00000276   0x7025             STRB     R5,[R4, #+0]
    409            buffer[1] = (char)0xff;
   \   00000278   0x25FF             MOVS     R5,#+255
   \   0000027A   0x7065             STRB     R5,[R4, #+1]
    410            buffer[2] = (char)0xff;
   \   0000027C   0x70A5             STRB     R5,[R4, #+2]
    411            if (FSysType != 0) {
   \   0000027E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000282   0xBF18             IT       NE 
   \   00000284   0x70E5             STRBNE   R5,[R4, #+3]
    412              buffer[3] = (char)0xff;
    413            }
    414          #if (FS_FAT_NOFAT32==0)
    415            if (FSysType == 2) {
   \   00000286   0xF1B9 0x0F02      CMP      R9,#+2
   \   0000028A   0xD108             BNE.N    ??_FS_fat_format_9
    416              buffer[4]   = (char)0xff;
   \   0000028C   0x7125             STRB     R5,[R4, #+4]
    417              buffer[5]   = (char)0xff;
   \   0000028E   0x7165             STRB     R5,[R4, #+5]
    418              buffer[6]   = (char)0xff;
   \   00000290   0x71A5             STRB     R5,[R4, #+6]
    419              buffer[7]   = (char)0x0f;
   \   00000292   0x200F             MOVS     R0,#+15
   \   00000294   0x71E0             STRB     R0,[R4, #+7]
    420              buffer[8]   = (char)0xff;
   \   00000296   0x7225             STRB     R5,[R4, #+8]
    421              buffer[9]   = (char)0xff;
   \   00000298   0x7265             STRB     R5,[R4, #+9]
    422              buffer[10]  = (char)0xff;
   \   0000029A   0x72A5             STRB     R5,[R4, #+10]
    423              buffer[11]  = (char)0x0f;
   \   0000029C   0x72E0             STRB     R0,[R4, #+11]
    424            }
    425          #endif /* FS_FAT_NOFAT32==0 */
    426            for (i = 0; i < 2; i++) {
    427              j = FS__lb_write(pDriver, Unit, (FS_u32)bpb.RsvdSecCnt + i * ((FS_u32)bpb.FATSz16+bpb.FATSz32), (void*)buffer);
    428              if (j < 0) {
   \                     ??_FS_fat_format_9: (+1)
   \   0000029E   0x4623             MOV      R3,R4
   \   000002A0   0xF8BD 0x201A      LDRH     R2,[SP, #+26]
   \   000002A4   0x4659             MOV      R1,R11
   \   000002A6   0x4650             MOV      R0,R10
   \   000002A8   0x.... 0x....      BL       FS__lb_write
   \   000002AC   0x2800             CMP      R0,#+0
   \   000002AE   0xD478             BMI.N    ??_FS_fat_format_4
   \   000002B0   0xF8BD 0x001A      LDRH     R0,[SP, #+26]
   \   000002B4   0xF8BD 0x1012      LDRH     R1,[SP, #+18]
   \   000002B8   0x1808             ADDS     R0,R1,R0
   \   000002BA   0x9901             LDR      R1,[SP, #+4]
   \   000002BC   0x180A             ADDS     R2,R1,R0
   \   000002BE   0x4623             MOV      R3,R4
   \   000002C0   0x4659             MOV      R1,R11
   \   000002C2   0x4650             MOV      R0,R10
   \   000002C4   0x.... 0x....      BL       FS__lb_write
   \   000002C8   0x2800             CMP      R0,#+0
   \   000002CA   0xD46A             BMI.N    ??_FS_fat_format_4
    429                FS__fat_free(buffer);
    430                return -1;
    431              }	// two fat table
    432            }
    433            /* Init root directory area */
    434            FS__CLIB_memset(buffer, 0x00, (FS_size_t)FS_FAT_SEC_SIZE);
   \   000002CC   0xF44F 0x7200      MOV      R2,#+512
   \   000002D0   0x2100             MOVS     R1,#+0
   \   000002D2   0x4620             MOV      R0,R4
   \   000002D4   0x.... 0x....      BL       FS__CLIB_memset
    435            if (bpb.RootEntCnt != 0) {
   \   000002D8   0xF8BD 0x000E      LDRH     R0,[SP, #+14]
   \   000002DC   0xB1C0             CBZ.N    R0,??_FS_fat_format_10
    436              /* FAT12/FAT16 */
    437              n = (((FS_u32)bpb.RootEntCnt * 32) / (FS_u32)512);	//n show the sectors accupied by root directory entries
   \   000002DE   0x0140             LSLS     R0,R0,#+5
   \   000002E0   0xEA4F 0x2850      LSR      R8,R0,#+9
    438              for (i = 0; i < n; i++) {
   \   000002E4   0x2700             MOVS     R7,#+0
   \   000002E6   0xF1B8 0x0F01      CMP      R8,#+1
   \   000002EA   0xDB2B             BLT.N    ??_FS_fat_format_11
    439                j = FS__lb_write(pDriver, Unit, bpb.RsvdSecCnt + 2 * bpb.FATSz16 + i, (void*)buffer);	//reserved sectors under fat12/16 is 1
    440                if (j < 0) {
   \                     ??_FS_fat_format_12: (+1)
   \   000002EC   0xF8BD 0x001A      LDRH     R0,[SP, #+26]
   \   000002F0   0xF8BD 0x1012      LDRH     R1,[SP, #+18]
   \   000002F4   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \   000002F8   0x183A             ADDS     R2,R7,R0
   \   000002FA   0x4623             MOV      R3,R4
   \   000002FC   0x4659             MOV      R1,R11
   \   000002FE   0x4650             MOV      R0,R10
   \   00000300   0x.... 0x....      BL       FS__lb_write
   \   00000304   0x2800             CMP      R0,#+0
   \   00000306   0xD44C             BMI.N    ??_FS_fat_format_4
    441                  FS__fat_free(buffer);
    442                  return -1;
    443                }
    444              }
   \   00000308   0x1C7F             ADDS     R7,R7,#+1
   \   0000030A   0x4547             CMP      R7,R8
   \   0000030C   0xDBEE             BLT.N    ??_FS_fat_format_12
   \   0000030E   0xE019             B.N      ??_FS_fat_format_11
    445            }
    446          #if (FS_FAT_NOFAT32==0)
    447            else {
    448              /* FAT32 */
    449              n = bpb.SecPerClus;
   \                     ??_FS_fat_format_10: (+1)
   \   00000310   0xF89D 0x801C      LDRB     R8,[SP, #+28]
    450              for (i = 0; i < n; i++) {
   \   00000314   0x2700             MOVS     R7,#+0
   \   00000316   0xF1B8 0x0F01      CMP      R8,#+1
   \   0000031A   0xDB13             BLT.N    ??_FS_fat_format_11
    451                j = FS__lb_write(pDriver, Unit, bpb.RsvdSecCnt + 2 * bpb.FATSz32 + (bpb.RootClus - 2) * n + i, (void*)buffer);
    452                if (j < 0) {
   \                     ??_FS_fat_format_13: (+1)
   \   0000031C   0xF8BD 0x001A      LDRH     R0,[SP, #+26]
   \   00000320   0x9901             LDR      R1,[SP, #+4]
   \   00000322   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \   00000326   0x9902             LDR      R1,[SP, #+8]
   \   00000328   0x1E89             SUBS     R1,R1,#+2
   \   0000032A   0xFB08 0x0001      MLA      R0,R8,R1,R0
   \   0000032E   0x183A             ADDS     R2,R7,R0
   \   00000330   0x4623             MOV      R3,R4
   \   00000332   0x4659             MOV      R1,R11
   \   00000334   0x4650             MOV      R0,R10
   \   00000336   0x.... 0x....      BL       FS__lb_write
   \   0000033A   0x2800             CMP      R0,#+0
   \   0000033C   0xD431             BMI.N    ??_FS_fat_format_4
    453                  FS__fat_free(buffer);
    454                  return -1;
    455                }
    456              }
   \   0000033E   0x1C7F             ADDS     R7,R7,#+1
   \   00000340   0x4547             CMP      R7,R8
   \   00000342   0xDBEB             BLT.N    ??_FS_fat_format_13
    457            }
    458          #endif /* FS_FAT_NOFAT32==0 */
    459          #if (FS_FAT_NOFAT32==0)
    460            if (FSysType == 2) {
   \                     ??_FS_fat_format_11: (+1)
   \   00000344   0xF1B9 0x0F02      CMP      R9,#+2
   \   00000348   0xD12F             BNE.N    ??_FS_fat_format_14
    461              /* Init FSInfo */
    462              FS__CLIB_memset(buffer, 0x00, (FS_size_t)FS_FAT_SEC_SIZE);
   \   0000034A   0xF44F 0x7200      MOV      R2,#+512
   \   0000034E   0x2100             MOVS     R1,#+0
   \   00000350   0x4620             MOV      R0,R4
   \   00000352   0x.... 0x....      BL       FS__CLIB_memset
    463              /* LeadSig = 0x41615252 */
    464              buffer[0]     = (char)0x52;
   \   00000356   0x2052             MOVS     R0,#+82
   \   00000358   0x7020             STRB     R0,[R4, #+0]
    465              buffer[1]     = (char)0x52;
   \   0000035A   0x7060             STRB     R0,[R4, #+1]
    466              buffer[2]     = (char)0x61;
    467              buffer[3]     = (char)0x41;
    468              /* StructSig = 0x61417272 */
    469              buffer[484]   = (char)0x72;
    470              buffer[485]   = (char)0x72;
    471              buffer[486]   = (char)0x41;
    472              buffer[487]   = (char)0x61;
    473              /* Invalidate last known free cluster count */
    474              buffer[488]   = (char)0xff;
    475              buffer[489]   = (char)0xff;
    476              buffer[490]   = (char)0xff;
    477              buffer[491]   = (char)0xff;
    478              /* Give hint for free cluster search */
    479              buffer[492]   = (char)0xff;
    480              buffer[493]   = (char)0xff;
    481              buffer[494]   = (char)0xff;
    482              buffer[495]   = (char)0xff;
    483              /* TrailSig = 0xaa550000 */
    484              buffer[508]   = (char)0x00;
    485              buffer[509]   = (char)0x00;
    486              buffer[510]   = (char)0x55;
    487              buffer[511]   = (char)0xaa;
    488              i = FS__lb_write(pDriver, Unit, bpb.FSInfo, (void*)buffer);
    489              if (i < 0) {
   \   0000035C   0x4623             MOV      R3,R4
   \   0000035E   0x2061             MOVS     R0,#+97
   \   00000360   0x70A0             STRB     R0,[R4, #+2]
   \   00000362   0x4659             MOV      R1,R11
   \   00000364   0x2041             MOVS     R0,#+65
   \   00000366   0x70E0             STRB     R0,[R4, #+3]
   \   00000368   0x2072             MOVS     R0,#+114
   \   0000036A   0x7030             STRB     R0,[R6, #+0]
   \   0000036C   0x7070             STRB     R0,[R6, #+1]
   \   0000036E   0x2041             MOVS     R0,#+65
   \   00000370   0x70B0             STRB     R0,[R6, #+2]
   \   00000372   0x2061             MOVS     R0,#+97
   \   00000374   0x70F0             STRB     R0,[R6, #+3]
   \   00000376   0x7135             STRB     R5,[R6, #+4]
   \   00000378   0x7175             STRB     R5,[R6, #+5]
   \   0000037A   0x71B5             STRB     R5,[R6, #+6]
   \   0000037C   0x71F5             STRB     R5,[R6, #+7]
   \   0000037E   0x7235             STRB     R5,[R6, #+8]
   \   00000380   0x7275             STRB     R5,[R6, #+9]
   \   00000382   0x72B5             STRB     R5,[R6, #+10]
   \   00000384   0x72F5             STRB     R5,[R6, #+11]
   \   00000386   0x2000             MOVS     R0,#+0
   \   00000388   0x7630             STRB     R0,[R6, #+24]
   \   0000038A   0x7670             STRB     R0,[R6, #+25]
   \   0000038C   0x2055             MOVS     R0,#+85
   \   0000038E   0x76B0             STRB     R0,[R6, #+26]
   \   00000390   0x20AA             MOVS     R0,#+170
   \   00000392   0x76F0             STRB     R0,[R6, #+27]
   \   00000394   0x4650             MOV      R0,R10
   \   00000396   0xF8BD 0x2016      LDRH     R2,[SP, #+22]
   \   0000039A   0x.... 0x....      BL       FS__lb_write
   \   0000039E   0x2800             CMP      R0,#+0
   \   000003A0   0xD503             BPL.N    ??_FS_fat_format_14
    490                FS__fat_free(buffer);
   \                     ??_FS_fat_format_4: (+1)
   \   000003A2   0x4620             MOV      R0,R4
   \   000003A4   0x.... 0x....      BL       FS__fat_free
    491                return -1;
    492              }
    493            }
   \                     ??_FS_fat_format_0: (+1)
   \   000003A8   0x....             B.N      ?Subroutine0
    494          #endif /* FS_FAT_NOFAT32==0 */
    495            FS__fat_free(buffer);
   \                     ??_FS_fat_format_14: (+1)
   \   000003AA   0x4620             MOV      R0,R4
   \   000003AC   0x.... 0x....      BL       FS__fat_free
    496            return 0;
   \   000003B0   0x2000             MOVS     R0,#+0
   \   000003B2   0x....             B.N      ??Subroutine0_0
    497          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??Subroutine0_0: (+1)
   \   00000004   0xB009             ADD      SP,SP,#+36
   \   00000006   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    498          
    499          
    500          /*********************************************************************
    501          *
    502          *             _FS_FAT_AutoFormat
    503          *
    504            Description:
    505            FS internal function. Get information about the media from the 
    506            device driver. Based on that informaton, calculate parameters for
    507            formatting that media and call the format routine.
    508          
    509            Parameters:
    510            Idx         - Index of device in the device information table 
    511                          referred by FS__pDevInfo.
    512            Unit        - Unit number.
    513            
    514            Return value:
    515            >=0         - Media has been formatted.
    516            <0          - An error has occured.
    517          */
    518          

   \                                 In section .text, align 2, keep-with-next
    519          static int _FS_FAT_AutoFormat(int Idx, FS_u32 Unit) {
   \                     _FS_FAT_AutoFormat: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0x4688             MOV      R8,R1
    520            struct {
    521              FS_u32 hiddennum;
    522              FS_u32 headnum;
    523              FS_u32 secnum;
    524              FS_u32 partsize;
    525            } devinfo;
    526            FS_u32 rootentcnt;
    527            FS_u32 fatsz;
    528            FS_u32 rootdirsectors;
    529            FS_u32 tmpval1;
    530            FS_u32 tmpval2;
    531            FS_u32 fatsz32;
    532            FS_u32 totsec32;
    533            FS_u32 resvdseccnt;
    534            FS_u16 totsec16;
    535            FS_u16 fatsz16;
    536            int i;
    537            unsigned char secperclust;
    538            char fsystype;
    539          
    540            /* Get info from device */
    541            devinfo.hiddennum = 0x00001111UL;
    542            devinfo.headnum   = 0x00002222UL;
    543            devinfo.secnum    = 0x00003333UL;
    544            devinfo.partsize  = 0x00004444UL;
    545            i = FS__lb_ioctl(FS__pDevInfo[Idx].devdriver, Unit, FS_CMD_GET_DEVINFO, 0, (void*)&devinfo);
   \   00000006   0x....             LDR.N    R1,??DataTable6
   \   00000008   0xB08D             SUB      SP,SP,#+52
   \   0000000A   0xF241 0x1511      MOVW     R5,#+4369
   \   0000000E   0xF242 0x2622      MOVW     R6,#+8738
   \   00000012   0x9509             STR      R5,[SP, #+36]
   \   00000014   0x960A             STR      R6,[SP, #+40]
   \   00000016   0xF243 0x3433      MOVW     R4,#+13107
   \   0000001A   0x940B             STR      R4,[SP, #+44]
   \   0000001C   0xF244 0x4944      MOVW     R9,#+17476
   \   00000020   0x6809             LDR      R1,[R1, #+0]
   \   00000022   0xF8CD 0x9030      STR      R9,[SP, #+48]
   \   00000026   0xEB01 0x1700      ADD      R7,R1,R0, LSL #+4
   \   0000002A   0xA809             ADD      R0,SP,#+36
   \   0000002C   0x9000             STR      R0,[SP, #+0]
   \   0000002E   0x2300             MOVS     R3,#+0
   \   00000030   0x68B8             LDR      R0,[R7, #+8]
   \   00000032   0xF640 0x72AB      MOVW     R2,#+4011
   \   00000036   0x4641             MOV      R1,R8
   \   00000038   0x.... 0x....      BL       FS__lb_ioctl
    546            if (i) {
   \   0000003C   0xB958             CBNZ.N   R0,??_FS_FAT_AutoFormat_0
    547              return -1;
    548            }
    549            /* Check if the driver really supports FS_CMD_GET_DEVINFO */
    550            if (devinfo.hiddennum == 0x00001111UL) {
   \   0000003E   0x9909             LDR      R1,[SP, #+36]
   \   00000040   0x42A9             CMP      R1,R5
   \   00000042   0xBF04             ITT      EQ 
   \   00000044   0x990A             LDREQ    R1,[SP, #+40]
   \   00000046   0x42B1             CMPEQ    R1,R6
    551              if (devinfo.headnum == 0x00002222UL) {
   \   00000048   0xD108             BNE.N    ??_FS_FAT_AutoFormat_1
    552                if (devinfo.secnum == 0x00003333UL) {
   \   0000004A   0x990B             LDR      R1,[SP, #+44]
   \   0000004C   0x42A1             CMP      R1,R4
   \   0000004E   0xBF04             ITT      EQ 
   \   00000050   0x990C             LDREQ    R1,[SP, #+48]
   \   00000052   0x4549             CMPEQ    R1,R9
    553                  if (devinfo.partsize == 0x00004444UL) {
   \   00000054   0xD102             BNE.N    ??_FS_FAT_AutoFormat_1
    554                    return -1;
   \                     ??_FS_FAT_AutoFormat_0: (+1)
   \   00000056   0xF04F 0x30FF      MOV      R0,#-1
   \   0000005A   0x....             B.N      ?Subroutine1
    555                  }
    556                }
    557              }
    558            }
    559            if (devinfo.partsize <= 1048576UL) {
   \                     ??_FS_FAT_AutoFormat_1: (+1)
   \   0000005C   0x9D0C             LDR      R5,[SP, #+48]
   \   0000005E   0xF5B5 0x1F80      CMP      R5,#+1048576
   \   00000062   0xD803             BHI.N    ??_FS_FAT_AutoFormat_2
    560              fsystype = 1;   /* FAT16 */
   \   00000064   0x2101             MOVS     R1,#+1
   \   00000066   0x.... 0x....      ADR.W    R2,_FS_auto_rootcnt
   \   0000006A   0xE004             B.N      ??_FS_FAT_AutoFormat_3
    561            }
    562          #if (FS_FAT_NOFAT32==0)
    563            else {
    564              fsystype = 2;   /* FAT32 */
   \                     ??_FS_FAT_AutoFormat_2: (+1)
   \   0000006C   0x2102             MOVS     R1,#+2
    565            }
    566          #else
    567            else {
    568              /* FAT32 disabled */
    569              return -1;
    570            }
    571          #endif /* FS_FAT_NOFAT32==0 */
    572          
    573            /* Set correct RootEntCnt & ResvdSecCnt */ 
    574            if (fsystype != 2) {
    575              /* FAT16 */
    576              i = 0;
    577              while (_FS_auto_rootcnt[i].SecNum < devinfo.partsize) {
    578                i++;
    579              }
    580              rootentcnt = (FS_u16)_FS_auto_rootcnt[i].Num;
    581              resvdseccnt = 1;
    582            }
    583          #if (FS_FAT_NOFAT32==0)
    584            else {
    585              /* FAT32 */
    586              rootentcnt = 0;
   \   0000006E   0x2300             MOVS     R3,#+0
    587              resvdseccnt = 0x20;
   \   00000070   0x2620             MOVS     R6,#+32
   \   00000072   0xE008             B.N      ??_FS_FAT_AutoFormat_4
    588            }
   \                     ??_FS_FAT_AutoFormat_5: (+1)
   \   00000074   0x1C40             ADDS     R0,R0,#+1
   \                     ??_FS_FAT_AutoFormat_3: (+1)
   \   00000076   0xF852 0x3030      LDR      R3,[R2, R0, LSL #+3]
   \   0000007A   0x42AB             CMP      R3,R5
   \   0000007C   0xD3FA             BCC.N    ??_FS_FAT_AutoFormat_5
   \   0000007E   0xEB02 0x00C0      ADD      R0,R2,R0, LSL #+3
   \   00000082   0x2601             MOVS     R6,#+1
   \   00000084   0x8883             LDRH     R3,[R0, #+4]
    589          #endif /* FS_FAT_NOFAT32==0 */
    590          
    591            /* Determinate SecPerClust */
    592            i = 0;
   \                     ??_FS_FAT_AutoFormat_4: (+1)
   \   00000086   0x.... 0x....      ADR.W    R2,_FS_auto_secperclust
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x4694             MOV      R12,R2
   \   0000008E   0xE000             B.N      ??_FS_FAT_AutoFormat_6
    593            while (_FS_auto_secperclust[i].SecNum < devinfo.partsize) {
    594              i++;
   \                     ??_FS_FAT_AutoFormat_7: (+1)
   \   00000090   0x1C40             ADDS     R0,R0,#+1
    595            }
   \                     ??_FS_FAT_AutoFormat_6: (+1)
   \   00000092   0xF85C 0xEB08      LDR      LR,[R12], #+8
   \   00000096   0x45AE             CMP      LR,R5
   \   00000098   0xD3FA             BCC.N    ??_FS_FAT_AutoFormat_7
    596            secperclust = (unsigned char) _FS_auto_secperclust[i].Num;
   \   0000009A   0xEB02 0x00C0      ADD      R0,R2,R0, LSL #+3
   \   0000009E   0x8882             LDRH     R2,[R0, #+4]
    597            /* 
    598               FAT16/FAT32 FAT size calculation 
    599               The formula used is following the Microsoft specification
    600               version 1.03 very closely. Therefore the calculated FAT
    601               size can be up to 8 sectors bigger than required for the 
    602               media. This is a waste of up to 8 sectors, but not a problem
    603               regarding correctness of the media's data.
    604            */
    605            rootdirsectors = ((rootentcnt * 32 ) + 511) / 512;
    606            tmpval1 = devinfo.partsize - (resvdseccnt + rootdirsectors);
   \   000000A0   0x1BA8             SUBS     R0,R5,R6
   \   000000A2   0x015E             LSLS     R6,R3,#+5
   \   000000A4   0xF206 0x16FF      ADDW     R6,R6,#+511
   \   000000A8   0xEBA0 0x2056      SUB      R0,R0,R6, LSR #+9
    607            tmpval2 = (256 * secperclust) + 2;
   \   000000AC   0xB2D2             UXTB     R2,R2
   \   000000AE   0x0216             LSLS     R6,R2,#+8
   \   000000B0   0x1CB6             ADDS     R6,R6,#+2
    608          #if (FS_FAT_NOFAT32==0)
    609            if (fsystype == 2) {
   \   000000B2   0x2902             CMP      R1,#+2
   \   000000B4   0xBF08             IT       EQ 
   \   000000B6   0x0876             LSREQ    R6,R6,#+1
    610              tmpval2 = tmpval2 / 2;
    611            }
    612          #endif /* FS_FAT_NOFAT32==0 */
    613            fatsz = (tmpval1 + (tmpval2 - 1)) / tmpval2;
   \   000000B8   0x1830             ADDS     R0,R6,R0
   \   000000BA   0x1E40             SUBS     R0,R0,#+1
   \   000000BC   0xFBB0 0xF0F6      UDIV     R0,R0,R6
    614            if (fsystype != 2) {
   \   000000C0   0x2902             CMP      R1,#+2
   \   000000C2   0xBF1A             ITTE     NE 
   \   000000C4   0x4606             MOVNE    R6,R0
   \   000000C6   0x2000             MOVNE    R0,#+0
   \   000000C8   0x2600             MOVEQ    R6,#+0
    615              fatsz16 = (FS_u16)fatsz;
    616              fatsz32 = 0;
    617            }
    618          #if (FS_FAT_NOFAT32==0)
    619            else {
    620              fatsz16 = 0;
    621              fatsz32 = fatsz;
    622            }
    623          #endif /* FS_FAT_NOFAT32==0 */
    624          
    625            /* Number of total sectors (512 byte units) of the media
    626               This is independent of FAT type (FAT12/FAT16/FAT32) */
    627            if (devinfo.partsize < 0x10000UL) {
   \   000000CA   0xF5B5 0x3F80      CMP      R5,#+65536
   \   000000CE   0xBF3A             ITTE     CC 
   \   000000D0   0x46AC             MOVCC    R12,R5
   \   000000D2   0x2500             MOVCC    R5,#+0
   \   000000D4   0xF04F 0x0C00      MOVCS    R12,#+0
    628              totsec16 = (FS_u16)devinfo.partsize;
    629              totsec32 = 0;
    630            }
    631            else {
    632              totsec16 = 0;
    633              totsec32 = devinfo.partsize;
    634            }
    635            /* Format media using calculated values */
    636            i = _FS_fat_format(FS__pDevInfo[Idx].devdriver,
    637                                  Unit,
    638                                  secperclust,
    639                                  (FS_u16)rootentcnt,
    640                                  totsec16,
    641                                  totsec32,
    642                                  (char)0xf8,
    643                                  fatsz16,
    644                                  fatsz32,
    645                                  (FS_u16)devinfo.secnum,
    646                                  (FS_u16)devinfo.headnum,
    647                                  devinfo.hiddennum,
    648                                  fsystype);
    649            return i;
   \   000000D8   0x9108             STR      R1,[SP, #+32]
   \   000000DA   0x9004             STR      R0,[SP, #+16]
   \   000000DC   0x20F8             MOVS     R0,#+248
   \   000000DE   0x9909             LDR      R1,[SP, #+36]
   \   000000E0   0x9107             STR      R1,[SP, #+28]
   \   000000E2   0x9002             STR      R0,[SP, #+8]
   \   000000E4   0xB2B6             UXTH     R6,R6
   \   000000E6   0x990A             LDR      R1,[SP, #+40]
   \   000000E8   0x9603             STR      R6,[SP, #+12]
   \   000000EA   0xB289             UXTH     R1,R1
   \   000000EC   0x9106             STR      R1,[SP, #+24]
   \   000000EE   0x9501             STR      R5,[SP, #+4]
   \   000000F0   0xFA1F 0xF08C      UXTH     R0,R12
   \   000000F4   0x990B             LDR      R1,[SP, #+44]
   \   000000F6   0xB289             UXTH     R1,R1
   \   000000F8   0x9105             STR      R1,[SP, #+20]
   \   000000FA   0x9000             STR      R0,[SP, #+0]
   \   000000FC   0x4641             MOV      R1,R8
   \   000000FE   0x68B8             LDR      R0,[R7, #+8]
   \   00000100   0x.... 0x....      BL       _FS_fat_format
   \   00000104                      REQUIRE ?Subroutine1
   \   00000104                      ;; // Fall through to label ?Subroutine1
    650          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0xB00D             ADD      SP,SP,#+52
   \   00000002   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    651          
    652          #endif /* FS_FAT_NOFORMAT==0 */
    653          
    654          
    655          #if FS_FAT_DISKINFO
    656          
    657          /*********************************************************************
    658          *
    659          *             _FS_fat_GetTotalFree
    660          *
    661            Description:
    662            FS internal function. Store information about used/unused clusters
    663            in a FS_DISKFREE_T data structure.
    664          
    665            Parameters:
    666            Idx         - Index of device in the device information table 
    667                          referred by FS__pDevInfo.
    668            Unit        - Unit number.
    669            pDiskData   - Pointer to a FS_DISKFREE_T data structure.
    670            
    671            Return value:
    672            ==0         - Information is stored in pDiskData.
    673            <0          - An error has occured.
    674          */
    675          

   \                                 In section .text, align 2, keep-with-next
    676          static int _FS_fat_GetTotalFree(int Idx, FS_u32 Unit, FS_DISKFREE_T *pDiskData) {
   \                     _FS_fat_GetTotalFree: (+1)
   \   00000000   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
    677            FS_u32 freeclust;
    678            FS_u32 usedclust;
    679            FS_u32 totclust;
    680            FS_u32 fatentry;
    681            FS_u32 fatsize;
    682            FS_i32 fatoffs;
    683            FS_i32 bytespersec;
    684            FS_i32 cursec;
    685            FS_i32 fatsec;
    686            FS_i32 lastsec;
    687            FS_i32 fatindex;
    688            int fattype;
    689            int err;
    690            char *buffer;
    691            unsigned char a;
    692            unsigned char b;
    693          #if (FS_FAT_NOFAT32==0)
    694            unsigned char c;
    695            unsigned char d;
    696          #endif
    697            
    698            if (!pDiskData) {
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xB086             SUB      SP,SP,#+24
   \   00000008   0xF000 0x809E      BEQ.W    ??_FS_fat_GetTotalFree_0
    699              return -1;  /* No pointer to a FS_DISKFREE_T structure */
    700            }
    701            buffer = FS__fat_malloc(FS_FAT_SEC_SIZE);
   \   0000000C   0xF44F 0x7000      MOV      R0,#+512
   \   00000010   0x.... 0x....      BL       FS__fat_malloc
   \   00000014   0xEA5F 0x0A00      MOVS     R10,R0
    702            if (!buffer) {
   \   00000018   0xF000 0x8096      BEQ.W    ??_FS_fat_GetTotalFree_0
    703              return -1;
    704            }
    705            fattype = FS__fat_which_type(Idx, Unit);
   \   0000001C   0x9907             LDR      R1,[SP, #+28]
   \   0000001E   0x9806             LDR      R0,[SP, #+24]
   \   00000020   0x.... 0x....      BL       FS__fat_which_type
   \   00000024   0x9002             STR      R0,[SP, #+8]
    706          #if (FS_FAT_NOFAT32!=0)
    707            if (fattype == 2) {
    708              FS__fat_free(buffer);
    709              return -1;
    710            }
    711          #endif /* FS_FAT_NOFAT32!=0 */
    712            fatsize = FS__FAT_aBPBUnit[Idx][Unit].FATSz16;
   \   00000026   0x9906             LDR      R1,[SP, #+24]
   \   00000028   0x....             LDR.N    R0,??DataTable6_1
   \   0000002A   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   0000002E   0x9907             LDR      R1,[SP, #+28]
   \   00000030   0xEB00 0x1541      ADD      R5,R0,R1, LSL #+5
   \   00000034   0x8A68             LDRH     R0,[R5, #+18]
   \   00000036   0x9000             STR      R0,[SP, #+0]
    713            if (fatsize == 0) {
   \   00000038   0xB908             CBNZ.N   R0,??_FS_fat_GetTotalFree_1
    714              fatsize = FS__FAT_aBPBUnit[Idx][Unit].FATSz32;
   \   0000003A   0x6868             LDR      R0,[R5, #+4]
   \   0000003C   0x9000             STR      R0,[SP, #+0]
    715            }
    716            bytespersec = (FS_i32)FS__FAT_aBPBUnit[Idx][Unit].BytesPerSec;
   \                     ??_FS_fat_GetTotalFree_1: (+1)
   \   0000003E   0x89A8             LDRH     R0,[R5, #+12]
   \   00000040   0x9001             STR      R0,[SP, #+4]
    717            /* Calculate total allocation units on disk */
    718            totclust = FS__FAT_aBPBUnit[Idx][Unit].TotSec16;
   \   00000042   0x8A28             LDRH     R0,[R5, #+16]
    719            if (!totclust) {
   \   00000044   0xB900             CBNZ.N   R0,??_FS_fat_GetTotalFree_2
    720              totclust = FS__FAT_aBPBUnit[Idx][Unit].TotSec32;
   \   00000046   0x6828             LDR      R0,[R5, #+0]
    721            }
    722            totclust  -= FS__FAT_aBPBUnit[Idx][Unit].RsvdSecCnt;
    723            totclust  -= 2*fatsize;
    724            usedclust  = FS__FAT_aBPBUnit[Idx][Unit].RootEntCnt;
    725            usedclust *= 0x20;
    726            usedclust /= bytespersec;
    727            totclust  -= usedclust;
    728            totclust  /= FS__FAT_aBPBUnit[Idx][Unit].SecPerClus;
   \                     ??_FS_fat_GetTotalFree_2: (+1)
   \   00000048   0x8B69             LDRH     R1,[R5, #+26]
   \   0000004A   0x9A01             LDR      R2,[SP, #+4]
   \   0000004C   0x1A40             SUBS     R0,R0,R1
   \   0000004E   0x9900             LDR      R1,[SP, #+0]
   \   00000050   0xEBA0 0x0041      SUB      R0,R0,R1, LSL #+1
   \   00000054   0x89E9             LDRH     R1,[R5, #+14]
   \   00000056   0x0149             LSLS     R1,R1,#+5
   \   00000058   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   0000005C   0x1A40             SUBS     R0,R0,R1
   \   0000005E   0x7F29             LDRB     R1,[R5, #+28]
   \   00000060   0xFBB0 0xF0F1      UDIV     R0,R0,R1
    729            /* Scan FAT for free and used entries */
    730            cursec     = 0;
    731            fatsec     = 0;
    732            lastsec    = -1;
    733            fatentry   = 0xffffUL;
    734            freeclust  = 0;
    735            usedclust  = 0;
   \   00000064   0x9901             LDR      R1,[SP, #+4]
   \   00000066   0x9003             STR      R0,[SP, #+12]
   \   00000068   0x2600             MOVS     R6,#+0
   \   0000006A   0x1E49             SUBS     R1,R1,#+1
   \   0000006C   0x46B0             MOV      R8,R6
   \   0000006E   0xF04F 0x30FF      MOV      R0,#-1
   \   00000072   0x2700             MOVS     R7,#+0
   \   00000074   0x9104             STR      R1,[SP, #+16]
   \   00000076   0xE002             B.N      ??_FS_fat_GetTotalFree_3
    736            while (1) {
    737              if (cursec >= (FS_i32)totclust) {
    738                break;  /* Last cluster reached */
    739              }
    740              if (fatsec >= (FS_i32)fatsize + FS__FAT_aBPBUnit[Idx][Unit].RsvdSecCnt) {
    741                break;  /* End of FAT reached */
    742              }
    743              if (fattype == 1) {
    744                fatindex = (cursec + 2) + ((cursec + 2) / 2);    /* FAT12 */
    745              }
    746              else if (fattype == 2) {
    747                fatindex = (cursec + 2) * 4;               /* FAT32 */
    748              }
    749              else {
    750                fatindex = (cursec + 2) * 2;               /* FAT16 */
    751              }
    752              fatsec = FS__FAT_aBPBUnit[Idx][Unit].RsvdSecCnt + (fatindex / bytespersec);
    753              fatoffs = fatindex % bytespersec;
    754              if (fatsec != lastsec) {
    755                err = FS__lb_read(FS__pDevInfo[Idx].devdriver, Unit, fatsec, (void*)buffer);
    756                if (err < 0) {
    757                  err = FS__lb_read(FS__pDevInfo[Idx].devdriver, Unit, fatsize + fatsec, (void*)buffer);
    758                  if (err < 0) {
    759                    FS__fat_free(buffer);
    760                    return -1;
    761                  }
    762                  /* Try to repair original FAT sector with contents of copy */
    763                  FS__lb_write(FS__pDevInfo[Idx].devdriver, Unit, fatsec, (void*)buffer);
    764                }
    765                lastsec = fatsec;
    766              }
    767              if (fattype == 1) {
    768                if (fatoffs == (bytespersec - 1)) {
    769                  a = buffer[fatoffs];
    770                  err = FS__lb_read(FS__pDevInfo[Idx].devdriver, Unit, fatsec+1, (void*)buffer);
    771                  if (err < 0) {
    772                    err = FS__lb_read(FS__pDevInfo[Idx].devdriver, Unit, fatsize + fatsec + 1, (void*)buffer);
    773                    if (err < 0) {
    774                      FS__fat_free(buffer);
    775                      return -1;
    776                    }
    777                    /* Try to repair original FAT sector with contents of copy */
    778                    FS__lb_write(FS__pDevInfo[Idx].devdriver, Unit, fatsec + 1, (void*)buffer);
    779                  }
    780                  lastsec = fatsec + 1;
    781                  b = buffer[0];
    782                }
    783                else {
    784                  a = buffer[fatoffs];
    785                  b = buffer[fatoffs + 1];
    786                }
    787                if (cursec & 1) {
    788                  fatentry = ((a & 0xf0) >> 4 ) + 16 * b;
    789                }
    790                else {
    791                  fatentry = a + 256 * (b & 0x0f);
    792                }
    793                fatentry &= 0x0fff;
    794              }
    795          #if (FS_FAT_NOFAT32==0)
    796              else if (fattype == 2) {
    797                a = buffer[fatoffs];
    798                b = buffer[fatoffs + 1];
    799                c = buffer[fatoffs + 2];
    800                d = buffer[fatoffs + 3];
    801                fatentry = a + 0x100UL * b + 0x10000UL * c + 0x1000000UL * d;
    802                fatentry &= 0x0fffffffUL;
    803              }
    804          #endif /* FS_FAT_NOFAT32==0 */
    805              else {
    806                a = buffer[fatoffs];
    807                b = buffer[fatoffs + 1];
    808                fatentry = a + 256 * b;
    809                fatentry &= 0xffffUL;
    810              }
    811              cursec++;
   \                     ??_FS_fat_GetTotalFree_4: (+1)
   \   00000078   0x1C76             ADDS     R6,R6,#+1
    812              if (fatentry == 0) {
   \   0000007A   0xB901             CBNZ.N   R1,??_FS_fat_GetTotalFree_3
    813                freeclust++;
   \   0000007C   0x1C7F             ADDS     R7,R7,#+1
    814              }
   \                     ??_FS_fat_GetTotalFree_3: (+1)
   \   0000007E   0x9903             LDR      R1,[SP, #+12]
   \   00000080   0x428E             CMP      R6,R1
   \   00000082   0xBFBF             ITTTT    LT 
   \   00000084   0x8B69             LDRHLT   R1,[R5, #+26]
   \   00000086   0x9A00             LDRLT    R2,[SP, #+0]
   \   00000088   0x188A             ADDLT    R2,R1,R2
   \   0000008A   0x4590             CMPLT    R8,R2
   \   0000008C   0xF280 0x8089      BGE.W    ??_FS_fat_GetTotalFree_5
   \   00000090   0x9B02             LDR      R3,[SP, #+8]
   \   00000092   0x1CB2             ADDS     R2,R6,#+2
   \   00000094   0x2B01             CMP      R3,#+1
   \   00000096   0xD105             BNE.N    ??_FS_fat_GetTotalFree_6
   \   00000098   0xEB02 0x72D2      ADD      R2,R2,R2, LSR #+31
   \   0000009C   0xEB06 0x0262      ADD      R2,R6,R2, ASR #+1
   \   000000A0   0x1C92             ADDS     R2,R2,#+2
   \   000000A2   0xE003             B.N      ??_FS_fat_GetTotalFree_7
   \                     ??_FS_fat_GetTotalFree_6: (+1)
   \   000000A4   0x2B02             CMP      R3,#+2
   \   000000A6   0xBF0C             ITE      EQ 
   \   000000A8   0x0092             LSLEQ    R2,R2,#+2
   \   000000AA   0x0052             LSLNE    R2,R2,#+1
   \                     ??_FS_fat_GetTotalFree_7: (+1)
   \   000000AC   0x9B01             LDR      R3,[SP, #+4]
   \   000000AE   0xFB92 0xF3F3      SDIV     R3,R2,R3
   \   000000B2   0xEB03 0x0801      ADD      R8,R3,R1
   \   000000B6   0x9901             LDR      R1,[SP, #+4]
   \   000000B8   0x4580             CMP      R8,R0
   \   000000BA   0xFB01 0x2B13      MLS      R11,R1,R3,R2
   \   000000BE   0xD01D             BEQ.N    ??_FS_fat_GetTotalFree_8
   \   000000C0   0x....             LDR.N    R0,??DataTable6
   \   000000C2   0x9906             LDR      R1,[SP, #+24]
   \   000000C4   0x6800             LDR      R0,[R0, #+0]
   \   000000C6   0xEB00 0x1401      ADD      R4,R0,R1, LSL #+4
   \   000000CA   0x9907             LDR      R1,[SP, #+28]
   \   000000CC   0x68A0             LDR      R0,[R4, #+8]
   \   000000CE   0x4653             MOV      R3,R10
   \   000000D0   0x4642             MOV      R2,R8
   \   000000D2   0x.... 0x....      BL       FS__lb_read
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD50F             BPL.N    ??_FS_fat_GetTotalFree_9
   \   000000DA   0x9800             LDR      R0,[SP, #+0]
   \   000000DC   0x9907             LDR      R1,[SP, #+28]
   \   000000DE   0xEB08 0x0200      ADD      R2,R8,R0
   \   000000E2   0x68A0             LDR      R0,[R4, #+8]
   \   000000E4   0x4653             MOV      R3,R10
   \   000000E6   0x.... 0x....      BL       FS__lb_read
   \   000000EA   0x2800             CMP      R0,#+0
   \   000000EC   0xD429             BMI.N    ??_FS_fat_GetTotalFree_10
   \   000000EE   0x9907             LDR      R1,[SP, #+28]
   \   000000F0   0x68A0             LDR      R0,[R4, #+8]
   \   000000F2   0x4653             MOV      R3,R10
   \   000000F4   0x4642             MOV      R2,R8
   \   000000F6   0x.... 0x....      BL       FS__lb_write
   \                     ??_FS_fat_GetTotalFree_9: (+1)
   \   000000FA   0x4640             MOV      R0,R8
   \                     ??_FS_fat_GetTotalFree_8: (+1)
   \   000000FC   0x9A02             LDR      R2,[SP, #+8]
   \   000000FE   0x2A01             CMP      R2,#+1
   \   00000100   0xEB0B 0x010A      ADD      R1,R11,R10
   \   00000104   0xD137             BNE.N    ??_FS_fat_GetTotalFree_11
   \   00000106   0x9A04             LDR      R2,[SP, #+16]
   \   00000108   0xF891 0x9000      LDRB     R9,[R1, #+0]
   \   0000010C   0x4593             CMP      R11,R2
   \   0000010E   0xD126             BNE.N    ??_FS_fat_GetTotalFree_12
   \   00000110   0x....             LDR.N    R0,??DataTable6
   \   00000112   0x9906             LDR      R1,[SP, #+24]
   \   00000114   0x6800             LDR      R0,[R0, #+0]
   \   00000116   0xEB00 0x1401      ADD      R4,R0,R1, LSL #+4
   \   0000011A   0xF108 0x0B01      ADD      R11,R8,#+1
   \   0000011E   0x9907             LDR      R1,[SP, #+28]
   \   00000120   0x68A0             LDR      R0,[R4, #+8]
   \   00000122   0x4653             MOV      R3,R10
   \   00000124   0x465A             MOV      R2,R11
   \   00000126   0x.... 0x....      BL       FS__lb_read
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD513             BPL.N    ??_FS_fat_GetTotalFree_13
   \   0000012E   0x9800             LDR      R0,[SP, #+0]
   \   00000130   0x9907             LDR      R1,[SP, #+28]
   \   00000132   0x4440             ADD      R0,R8,R0
   \   00000134   0x1C42             ADDS     R2,R0,#+1
   \   00000136   0x68A0             LDR      R0,[R4, #+8]
   \   00000138   0x4653             MOV      R3,R10
   \   0000013A   0x.... 0x....      BL       FS__lb_read
   \   0000013E   0x2800             CMP      R0,#+0
   \   00000140   0xD503             BPL.N    ??_FS_fat_GetTotalFree_14
   \                     ??_FS_fat_GetTotalFree_10: (+1)
   \   00000142   0x4650             MOV      R0,R10
   \   00000144   0x.... 0x....      BL       FS__fat_free
   \                     ??_FS_fat_GetTotalFree_0: (+1)
   \   00000148   0x....             B.N      ?Subroutine0
   \                     ??_FS_fat_GetTotalFree_14: (+1)
   \   0000014A   0x9907             LDR      R1,[SP, #+28]
   \   0000014C   0x68A0             LDR      R0,[R4, #+8]
   \   0000014E   0x4653             MOV      R3,R10
   \   00000150   0x465A             MOV      R2,R11
   \   00000152   0x.... 0x....      BL       FS__lb_write
   \                     ??_FS_fat_GetTotalFree_13: (+1)
   \   00000156   0xF89A 0x1000      LDRB     R1,[R10, #+0]
   \   0000015A   0x4658             MOV      R0,R11
   \   0000015C   0xE000             B.N      ??_FS_fat_GetTotalFree_15
   \                     ??_FS_fat_GetTotalFree_12: (+1)
   \   0000015E   0x7849             LDRB     R1,[R1, #+1]
   \                     ??_FS_fat_GetTotalFree_15: (+1)
   \   00000160   0x07F2             LSLS     R2,R6,#+31
   \   00000162   0xBF59             ITTEE    PL 
   \   00000164   0xF001 0x010F      ANDPL    R1,R1,#0xF
   \   00000168   0xEB09 0x2101      ADDPL    R1,R9,R1, LSL #+8
   \   0000016C   0xEA4F 0x1219      LSRMI    R2,R9,#+4
   \   00000170   0xEB02 0x1101      ADDMI    R1,R2,R1, LSL #+4
   \   00000174   0xE780             B.N      ??_FS_fat_GetTotalFree_4
   \                     ??_FS_fat_GetTotalFree_11: (+1)
   \   00000176   0x2A02             CMP      R2,#+2
   \   00000178   0xEB0B 0x020A      ADD      R2,R11,R10
   \   0000017C   0x7809             LDRB     R1,[R1, #+0]
   \   0000017E   0x7852             LDRB     R2,[R2, #+1]
   \   00000180   0xEB01 0x2102      ADD      R1,R1,R2, LSL #+8
   \   00000184   0xF47F 0xAF78      BNE.W    ??_FS_fat_GetTotalFree_4
   \   00000188   0xEB0B 0x020A      ADD      R2,R11,R10
   \   0000018C   0x7892             LDRB     R2,[R2, #+2]
   \   0000018E   0xEB01 0x4102      ADD      R1,R1,R2, LSL #+16
   \   00000192   0xEB0B 0x020A      ADD      R2,R11,R10
   \   00000196   0x78D2             LDRB     R2,[R2, #+3]
   \   00000198   0xEB01 0x6102      ADD      R1,R1,R2, LSL #+24
   \   0000019C   0x0109             LSLS     R1,R1,#+4
   \   0000019E   0x0909             LSRS     R1,R1,#+4
   \   000001A0   0xE76A             B.N      ??_FS_fat_GetTotalFree_4
    815              else {
    816                usedclust++;
    817              }
    818            }
    819            FS__fat_free(buffer);
   \                     ??_FS_fat_GetTotalFree_5: (+1)
   \   000001A2   0x4650             MOV      R0,R10
   \   000001A4   0x.... 0x....      BL       FS__fat_free
    820            pDiskData->total_clusters      = totclust;
   \   000001A8   0x9908             LDR      R1,[SP, #+32]
   \   000001AA   0x9803             LDR      R0,[SP, #+12]
   \   000001AC   0x6008             STR      R0,[R1, #+0]
    821            pDiskData->avail_clusters      = freeclust;
   \   000001AE   0x9808             LDR      R0,[SP, #+32]
   \   000001B0   0x6047             STR      R7,[R0, #+4]
    822            pDiskData->sectors_per_cluster = FS__FAT_aBPBUnit[Idx][Unit].SecPerClus;
   \   000001B2   0x9908             LDR      R1,[SP, #+32]
   \   000001B4   0x7F28             LDRB     R0,[R5, #+28]
   \   000001B6   0x8108             STRH     R0,[R1, #+8]
    823            pDiskData->bytes_per_sector    = (FS_u16)bytespersec;
   \   000001B8   0x9908             LDR      R1,[SP, #+32]
   \   000001BA   0x9801             LDR      R0,[SP, #+4]
   \   000001BC   0x8148             STRH     R0,[R1, #+10]
    824            return 0;
   \   000001BE   0xB009             ADD      SP,SP,#+36
   \   000001C0   0x2000             MOVS     R0,#+0
   \   000001C2   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    825          }
    826          
    827          #endif /* FS_FAT_DISKINFO */
    828          
    829          
    830          /*********************************************************************
    831          *
    832          *             Global functions
    833          *
    834          **********************************************************************
    835          */
    836          
    837          /*********************************************************************
    838          *
    839          *             FS__fat_ioctl
    840          *
    841            Description:
    842            FS internal function. Execute device command. The FAT layer checks
    843            first, if it has to process the command (e.g. format). Any other
    844            command is passed to the device driver.
    845          
    846            Parameters:
    847            Idx         - Index of device in the device information table 
    848                          referred by FS__pDevInfo.
    849            Unit        - Unit number.
    850            Cmd         - Command to be executed.
    851            Aux         - Parameter depending on command.
    852            pBuffer     - Pointer to a buffer used for the command.
    853            
    854            Return value:
    855            Command specific. In general a negative value means an error.
    856          */
    857          

   \                                 In section .text, align 4, keep-with-next
    858          int FS__fat_ioctl(int Idx, FS_u32 Unit, FS_i32 Cmd, FS_i32 Aux, void *pBuffer) {
   \                     FS__fat_ioctl: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0x4680             MOV      R8,R0
    859            int x;
    860          #if ((FS_SUPPORT_SEC_ACCESS) || (FS_FAT_NOFORMAT==0))
    861            int i;
    862          #endif
    863          #if (FS_FAT_NOFORMAT==0)
    864            int j;
    865          #endif
    866          
    867            FS__lb_ioctl(FS__pDevInfo[Idx].devdriver, Unit, FS_CMD_INC_BUSYCNT, 0, (void*)0);  /* Turn on busy signal */
   \   00000006   0x4835             LDR.N    R0,??FS__fat_ioctl_0
   \   00000008   0xB089             SUB      SP,SP,#+36
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0xEB00 0x1508      ADD      R5,R0,R8, LSL #+4
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x9000             STR      R0,[SP, #+0]
   \   00000014   0x4617             MOV      R7,R2
   \   00000016   0x4699             MOV      R9,R3
   \   00000018   0x68A8             LDR      R0,[R5, #+8]
   \   0000001A   0x460C             MOV      R4,R1
   \   0000001C   0x2300             MOVS     R3,#+0
   \   0000001E   0xF640 0x32B9      MOVW     R2,#+3001
   \   00000022   0x.... 0x....      BL       FS__lb_ioctl
    868          #if (FS_FAT_NOFORMAT==0)
    869            if (Cmd == FS_CMD_FORMAT_MEDIA) {
   \   00000026   0xF640 0x00AE      MOVW     R0,#+2222
   \   0000002A   0x4287             CMP      R7,R0
   \   0000002C   0xD15E             BNE.N    ??FS__fat_ioctl_1
    870              j = 0;
   \   0000002E   0x.... 0x....      ADR.W    R6,_FS_wd_format_media_table
   \   00000032   0x2700             MOVS     R7,#+0
   \   00000034   0x4630             MOV      R0,R6
    871              while (1) {
    872                if (j >= FS_KNOWNMEDIA_NUM) {
    873                  break;  /* Not a known media */
    874                }
    875                if (_FS_wd_format_media_table[j].media_id == Aux) {
   \                     ??FS__fat_ioctl_2: (+1)
   \   00000036   0xF850 0x1B1C      LDR      R1,[R0], #+28
   \   0000003A   0x4549             CMP      R1,R9
   \   0000003C   0xBF1E             ITTT     NE 
   \   0000003E   0x1C7F             ADDNE    R7,R7,#+1
   \   00000040   0xF850 0x1B1C      LDRNE    R1,[R0], #+28
   \   00000044   0x4549             CMPNE    R1,R9
    876                  break;  /* Media found in the list */
    877                }
    878                j++;
   \   00000046   0xD002             BEQ.N    ??FS__fat_ioctl_3
   \   00000048   0x1C7F             ADDS     R7,R7,#+1
   \   0000004A   0x2F16             CMP      R7,#+22
   \   0000004C   0xD3F3             BCC.N    ??FS__fat_ioctl_2
    879              }	//find the right media
    880              if (j >= FS_KNOWNMEDIA_NUM) {	//can't find the right media
   \                     ??FS__fat_ioctl_3: (+1)
   \   0000004E   0x2F16             CMP      R7,#+22
   \   00000050   0xF080 0x808C      BCS.W    ??FS__fat_ioctl_4
    881                FS__lb_ioctl(FS__pDevInfo[Idx].devdriver, Unit, FS_CMD_DEC_BUSYCNT, 0, (void*)0);  /* Turn off busy signal */
    882                return -1;
    883              }
    884              i = FS__lb_status(FS__pDevInfo[Idx].devdriver, Unit);	//get status of device, if ok return 1
    885              if (i >= 0) {
   \   00000054   0x68A8             LDR      R0,[R5, #+8]
   \   00000056   0x4621             MOV      R1,R4
   \   00000058   0x.... 0x....      BL       FS__lb_status
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xF100 0x8085      BMI.W    ??FS__fat_ioctl_4
    886                x = _FS_fat_format(FS__pDevInfo[Idx].devdriver,
    887                                    Unit,
    888                                    _FS_wd_format_media_table[j].secperclus,
    889                                    _FS_wd_format_media_table[j].rootentcnt,
    890                                    _FS_wd_format_media_table[j].totsec16,
    891                                    _FS_wd_format_media_table[j].totsec32,
    892                                    _FS_wd_format_media_table[j].media,
    893                                    _FS_wd_format_media_table[j].fatsz16,
    894                                    0,
    895                                    _FS_wd_format_media_table[j].secpertrk,
    896                                    _FS_wd_format_media_table[j].numheads,
    897                                    _FS_wd_format_media_table[j].hiddsec,
    898                                    _FS_wd_format_media_table[j].fsystype);
   \   00000062   0xEBC7 0x00C7      RSB      R0,R7,R7, LSL #+3
   \   00000066   0xEB06 0x0080      ADD      R0,R6,R0, LSL #+2
   \   0000006A   0x7E01             LDRB     R1,[R0, #+24]
   \   0000006C   0x9108             STR      R1,[SP, #+32]
   \   0000006E   0x6881             LDR      R1,[R0, #+8]
   \   00000070   0x9107             STR      R1,[SP, #+28]
   \   00000072   0x8A81             LDRH     R1,[R0, #+20]
   \   00000074   0x9106             STR      R1,[SP, #+24]
   \   00000076   0x8A41             LDRH     R1,[R0, #+18]
   \   00000078   0x9105             STR      R1,[SP, #+20]
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0x9104             STR      R1,[SP, #+16]
   \   0000007E   0x8A01             LDRH     R1,[R0, #+16]
   \   00000080   0x9103             STR      R1,[SP, #+12]
   \   00000082   0x7DC1             LDRB     R1,[R0, #+23]
   \   00000084   0x9102             STR      R1,[SP, #+8]
   \   00000086   0x6841             LDR      R1,[R0, #+4]
   \   00000088   0x9101             STR      R1,[SP, #+4]
   \   0000008A   0x8981             LDRH     R1,[R0, #+12]
   \   0000008C   0x9100             STR      R1,[SP, #+0]
   \   0000008E   0x89C3             LDRH     R3,[R0, #+14]
   \   00000090   0x7D82             LDRB     R2,[R0, #+22]
   \   00000092   0x68A8             LDR      R0,[R5, #+8]
   \   00000094   0x4621             MOV      R1,R4
   \   00000096   0x.... 0x....      BL       _FS_fat_format
   \   0000009A   0x4681             MOV      R9,R0
    899                i = FS__lb_ioctl(FS__pDevInfo[Idx].devdriver, Unit, FS_CMD_FLUSH_CACHE, 0, (void*)0);
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x9000             STR      R0,[SP, #+0]
   \   000000A0   0x2300             MOVS     R3,#+0
   \   000000A2   0x68A8             LDR      R0,[R5, #+8]
   \   000000A4   0xF44F 0x727A      MOV      R2,#+1000
   \   000000A8   0x4621             MOV      R1,R4
   \   000000AA   0x.... 0x....      BL       FS__lb_ioctl
    900                if (i < 0) {
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xF100 0x8084      BMI.W    ??FS__fat_ioctl_5
    901                  x = i;
    902                }
    903                else {
    904                  /* Invalidate BPB */
    905                  for (i = 0; i < (int)FS__maxdev; i++) {
   \   000000B4   0x480A             LDR.N    R0,??FS__fat_ioctl_0+0x4
   \   000000B6   0x6800             LDR      R0,[R0, #+0]
   \   000000B8   0x2801             CMP      R0,#+1
   \   000000BA   0xF2C0 0x8080      BLT.W    ??FS__fat_ioctl_6
   \   000000BE   0x4909             LDR.N    R1,??FS__fat_ioctl_0+0x8
   \   000000C0   0x2700             MOVS     R7,#+0
    906                    for (j = 0; j < (int)FS__fat_maxunit; j++) {
   \                     ??FS__fat_ioctl_7: (+1)
   \   000000C2   0x4A09             LDR.N    R2,??FS__fat_ioctl_0+0xC
   \   000000C4   0x6812             LDR      R2,[R2, #+0]
   \   000000C6   0x2A01             CMP      R2,#+1
   \   000000C8   0xDB04             BLT.N    ??FS__fat_ioctl_8
   \   000000CA   0x460B             MOV      R3,R1
    907                        FS__FAT_aBPBUnit[i][j].Signature = 0x0000;
   \                     ??FS__fat_ioctl_9: (+1)
   \   000000CC   0x1E52             SUBS     R2,R2,#+1
   \   000000CE   0xF823 0x7B20      STRH     R7,[R3], #+32
   \   000000D2   0xD1FB             BNE.N    ??FS__fat_ioctl_9
    908                    }
    909                  }
   \                     ??FS__fat_ioctl_8: (+1)
   \   000000D4   0x3120             ADDS     R1,R1,#+32
   \   000000D6   0x1E40             SUBS     R0,R0,#+1
   \   000000D8   0xD071             BEQ.N    ??FS__fat_ioctl_6
   \   000000DA   0xE7F2             B.N      ??FS__fat_ioctl_7
   \                     ??FS__fat_ioctl_0:
   \   000000DC   0x........         DC32     FS__pDevInfo
   \   000000E0   0x........         DC32     FS__maxdev
   \   000000E4   0x........         DC32     FS__FAT_aBPBUnit+0x18
   \   000000E8   0x........         DC32     FS__fat_maxunit
    910                }
    911              }
    912              else {
    913                FS__lb_ioctl(FS__pDevInfo[Idx].devdriver, Unit, FS_CMD_DEC_BUSYCNT, 0, (void*)0);  /* Turn off busy signal */
    914                return -1;
    915              }
    916            }
    917            else if (Cmd == FS_CMD_FORMAT_AUTO) {
   \                     ??FS__fat_ioctl_1: (+1)
   \   000000EC   0xF640 0x101D      MOVW     R0,#+2333
   \   000000F0   0x4287             CMP      R7,R0
   \   000000F2   0xD116             BNE.N    ??FS__fat_ioctl_10
    918              i = FS__lb_status(FS__pDevInfo[Idx].devdriver, Unit);
    919              if (i >= 0) {
   \   000000F4   0x68A8             LDR      R0,[R5, #+8]
   \   000000F6   0x4621             MOV      R1,R4
   \   000000F8   0x.... 0x....      BL       FS__lb_status
   \   000000FC   0x2800             CMP      R0,#+0
   \   000000FE   0xD453             BMI.N    ??FS__fat_ioctl_11
    920                x = _FS_FAT_AutoFormat(Idx, Unit);
   \   00000100   0x4621             MOV      R1,R4
   \   00000102   0x4640             MOV      R0,R8
   \   00000104   0x.... 0x....      BL       _FS_FAT_AutoFormat
   \   00000108   0x4681             MOV      R9,R0
    921                i = FS__lb_ioctl(FS__pDevInfo[Idx].devdriver, Unit, FS_CMD_FLUSH_CACHE, 0, (void*)0);
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0x9000             STR      R0,[SP, #+0]
   \   0000010E   0x2300             MOVS     R3,#+0
   \   00000110   0x68A8             LDR      R0,[R5, #+8]
   \   00000112   0xF44F 0x727A      MOV      R2,#+1000
   \   00000116   0x4621             MOV      R1,R4
   \   00000118   0x.... 0x....      BL       FS__lb_ioctl
    922                if (i < 0) {
   \   0000011C   0x2800             CMP      R0,#+0
   \   0000011E   0xD54E             BPL.N    ??FS__fat_ioctl_6
    923                  x = i;
   \   00000120   0xE04C             B.N      ??FS__fat_ioctl_5
    924                }
    925              }
    926              else {
    927                x = -1;
    928              }
    929            }
   \                     ??FS__fat_ioctl_10: (+1)
   \   00000122   0x9E10             LDR      R6,[SP, #+64]
    930          #else /* FS_FAT_NOFORMAT==0 */
    931            if (Cmd == FS_CMD_FORMAT_MEDIA) {
    932              x = -1;  /* Format command is not supported */
    933            }
    934          #endif /* FS_FAT_NOFORMAT==0 */
    935          #if FS_FAT_DISKINFO
    936            else if (Cmd == FS_CMD_GET_DISKFREE) {
   \   00000124   0xF5B7 0x6F7A      CMP      R7,#+4000
   \   00000128   0xD117             BNE.N    ??FS__fat_ioctl_12
    937              i = FS__fat_checkunit(Idx, Unit);
    938              if (i > 0) {
   \   0000012A   0x4621             MOV      R1,R4
   \   0000012C   0x4640             MOV      R0,R8
   \   0000012E   0x.... 0x....      BL       FS__fat_checkunit
   \   00000132   0x2801             CMP      R0,#+1
   \   00000134   0xDB38             BLT.N    ??FS__fat_ioctl_11
    939                x = _FS_fat_GetTotalFree(Idx, Unit, (FS_DISKFREE_T*)pBuffer);
   \   00000136   0x4632             MOV      R2,R6
   \   00000138   0x4621             MOV      R1,R4
   \   0000013A   0x4640             MOV      R0,R8
   \   0000013C   0x.... 0x....      BL       _FS_fat_GetTotalFree
   \   00000140   0x4681             MOV      R9,R0
    940                i = FS__lb_ioctl(FS__pDevInfo[Idx].devdriver, Unit, FS_CMD_FLUSH_CACHE, 0, (void*)0);
   \   00000142   0x2000             MOVS     R0,#+0
   \   00000144   0x9000             STR      R0,[SP, #+0]
   \   00000146   0x2300             MOVS     R3,#+0
   \   00000148   0x68A8             LDR      R0,[R5, #+8]
   \   0000014A   0xF44F 0x727A      MOV      R2,#+1000
   \   0000014E   0x4621             MOV      R1,R4
   \   00000150   0x.... 0x....      BL       FS__lb_ioctl
    941                if (i < 0) {
   \   00000154   0x2800             CMP      R0,#+0
   \   00000156   0xD532             BPL.N    ??FS__fat_ioctl_6
    942                  x = i;
   \   00000158   0xE030             B.N      ??FS__fat_ioctl_5
    943                }
    944              }
    945              else {
    946                x = -1;
    947              }
    948            }
    949          #else /* FS_FAT_DISKINFO==0 */
    950            else if (Cmd == FS_CMD_GET_DISKFREE) {
    951              x = -1; /* Diskinfo command not supported */
    952            }
    953          #endif /* FS_FAT_DISKINFO */
    954          #if FS_SUPPORT_SEC_ACCESS
    955            else if ((Cmd == FS_CMD_READ_SECTOR) || (Cmd == FS_CMD_WRITE_SECTOR)) {
   \                     ??FS__fat_ioctl_12: (+1)
   \   0000015A   0xF240 0x484C      MOVW     R8,#+1100
   \   0000015E   0x4547             CMP      R7,R8
   \   00000160   0xBF1C             ITT      NE 
   \   00000162   0xF240 0x4056      MOVWNE   R0,#+1110
   \   00000166   0x4287             CMPNE    R7,R0
   \   00000168   0xD121             BNE.N    ??FS__fat_ioctl_13
    956              if (!pBuffer) {
   \   0000016A   0xB95E             CBNZ.N   R6,??FS__fat_ioctl_14
    957                FS__lb_ioctl(FS__pDevInfo[Idx].devdriver, Unit, FS_CMD_DEC_BUSYCNT, 0, (void*)0);
   \                     ??FS__fat_ioctl_4: (+1)
   \   0000016C   0x2000             MOVS     R0,#+0
   \   0000016E   0x9000             STR      R0,[SP, #+0]
   \   00000170   0x2300             MOVS     R3,#+0
   \   00000172   0x68A8             LDR      R0,[R5, #+8]
   \   00000174   0xF640 0x32BA      MOVW     R2,#+3002
   \   00000178   0x4621             MOV      R1,R4
   \   0000017A   0x.... 0x....      BL       FS__lb_ioctl
    958                return -1;
   \   0000017E   0xF04F 0x30FF      MOV      R0,#-1
   \   00000182   0x....             B.N      ?Subroutine2
    959              }
    960              i = FS__lb_status(FS__pDevInfo[Idx].devdriver, Unit);
    961              if (i >= 0) {
   \                     ??FS__fat_ioctl_14: (+1)
   \   00000184   0x68A8             LDR      R0,[R5, #+8]
   \   00000186   0x4621             MOV      R1,R4
   \   00000188   0x.... 0x....      BL       FS__lb_status
   \   0000018C   0x2800             CMP      R0,#+0
   \   0000018E   0xD40B             BMI.N    ??FS__fat_ioctl_11
    962                if (Cmd == FS_CMD_READ_SECTOR) {
   \   00000190   0x68A8             LDR      R0,[R5, #+8]
   \   00000192   0x4547             CMP      R7,R8
   \   00000194   0x4633             MOV      R3,R6
   \   00000196   0x464A             MOV      R2,R9
   \   00000198   0x4621             MOV      R1,R4
   \   0000019A   0xD102             BNE.N    ??FS__fat_ioctl_15
    963                  x = FS__lb_read(FS__pDevInfo[Idx].devdriver, Unit, Aux, pBuffer);
   \   0000019C   0x.... 0x....      BL       FS__lb_read
   \   000001A0   0xE00C             B.N      ??FS__fat_ioctl_5
    964                }
    965                else {
    966                  x = FS__lb_write(FS__pDevInfo[Idx].devdriver, Unit, Aux, pBuffer);
   \                     ??FS__fat_ioctl_15: (+1)
   \   000001A2   0x.... 0x....      BL       FS__lb_write
   \   000001A6   0xE009             B.N      ??FS__fat_ioctl_5
    967                }
    968              }
    969              else {
    970                x = -1;
   \                     ??FS__fat_ioctl_11: (+1)
   \   000001A8   0xF04F 0x39FF      MOV      R9,#-1
   \   000001AC   0xE007             B.N      ??FS__fat_ioctl_6
    971              }
    972            }
    973          #else /* FS_SUPPORT_SEC_ACCESS */
    974            else if ((Cmd == FS_CMD_READ_SECTOR) || (Cmd == FS_CMD_WRITE_SECTOR)) {
    975              FS__lb_ioctl(FS__pDevInfo[Idx].devdriver, Unit, FS_CMD_DEC_BUSYCNT, 0, (void*)0);
    976              return -1;
    977            }
    978          #endif /* FS_SUPPORT_SEC_ACCESS */
    979            else {
    980              /* Maybe command for driver */
    981              x = FS__lb_ioctl(FS__pDevInfo[Idx].devdriver, Unit, Cmd, Aux, (void*)pBuffer);
   \                     ??FS__fat_ioctl_13: (+1)
   \   000001AE   0x9600             STR      R6,[SP, #+0]
   \   000001B0   0x464B             MOV      R3,R9
   \   000001B2   0x68A8             LDR      R0,[R5, #+8]
   \   000001B4   0x463A             MOV      R2,R7
   \   000001B6   0x4621             MOV      R1,R4
   \   000001B8   0x.... 0x....      BL       FS__lb_ioctl
   \                     ??FS__fat_ioctl_5: (+1)
   \   000001BC   0x4681             MOV      R9,R0
    982            }
    983            FS__lb_ioctl(FS__pDevInfo[Idx].devdriver, Unit, FS_CMD_DEC_BUSYCNT, 0, (void*)0);  /* Turn off busy signal */
   \                     ??FS__fat_ioctl_6: (+1)
   \   000001BE   0x2000             MOVS     R0,#+0
   \   000001C0   0x9000             STR      R0,[SP, #+0]
   \   000001C2   0x2300             MOVS     R3,#+0
   \   000001C4   0x68A8             LDR      R0,[R5, #+8]
   \   000001C6   0xF640 0x32BA      MOVW     R2,#+3002
   \   000001CA   0x4621             MOV      R1,R4
   \   000001CC   0x.... 0x....      BL       FS__lb_ioctl
    984            return x;
   \   000001D0   0x4648             MOV      R0,R9
   \   000001D2                      REQUIRE ?Subroutine2
   \   000001D2                      ;; // Fall through to label ?Subroutine2
    985          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0xB009             ADD      SP,SP,#+36
   \   00000002   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     FS__pDevInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     FS__FAT_aBPBUnit

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x46 0x41          DC8 "FAT12   "
   \              0x54 0x31    
   \              0x32 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x46 0x41          DC8 "FAT16   "
   \              0x54 0x31    
   \              0x36 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x46 0x41          DC8 "FAT32   "
   \              0x54 0x33    
   \              0x32 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    986          
    987          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      64   FS__fat_ioctl
        64   -> FS__fat_checkunit
        64   -> FS__lb_ioctl
        64   -> FS__lb_read
        64   -> FS__lb_status
        64   -> FS__lb_write
        64   -> _FS_FAT_AutoFormat
        64   -> _FS_fat_GetTotalFree
        64   -> _FS_fat_format
      80   _FS_FAT_AutoFormat
        80   -> FS__lb_ioctl
        80   -> _FS_fat_format
      72   _FS_fat_GetTotalFree
        72   -> FS__fat_free
        72   -> FS__fat_malloc
        72   -> FS__fat_which_type
        72   -> FS__lb_read
        72   -> FS__lb_write
      72   _FS_fat_format
        72   -> FS__CLIB_memset
        72   -> FS__CLIB_strncpy
        72   -> FS__fat_free
        72   -> FS__fat_malloc
        72   -> FS__lb_write
        72   -> __aeabi_memclr
        72   -> __aeabi_memset


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
      10  ?Subroutine0
       6  ?Subroutine1
       6  ?Subroutine2
      12  ?_0
      12  ?_1
      12  ?_2
     466  FS__fat_ioctl
     260  _FS_FAT_AutoFormat
      40  _FS_auto_rootcnt
      72  _FS_auto_secperclust
     454  _FS_fat_GetTotalFree
     948  _FS_fat_format
     616  _FS_wd_format_media_table

 
 2 922 bytes in section .text
 
 2 922 bytes of CODE memory

Errors: none
Warnings: none
