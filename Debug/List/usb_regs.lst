###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       09/Feb/2018  16:15:17
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\HW Projects\ControlHome\CntrHome - RF69w\uc-terminal\src\usb_regs.c
#    Command line =  
#        "E:\HW Projects\ControlHome\CntrHome -
#        RF69w\uc-terminal\src\usb_regs.c" -lCN "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Debug\List" -o "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Debug\Obj" --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\APP\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\BSP\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\CPU\inc\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-CPU\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-RTC\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-LIB\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uCOS-II\Ports\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uCOS-II\Source\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\I2C-Out\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Direct_Sw\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Wdt_led\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-LCD\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-RF\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\api\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\config\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\os\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\fsl\fat\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\clib\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\lbl\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\device\mmc\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\file\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-Terminal\src\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-Terminal\inc\" -Oh
#    List file    =  
#        E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\List\usb_regs.lst
#    Object file  =  
#        E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\Obj\usb_regs.o
#
###############################################################################

E:\HW Projects\ControlHome\CntrHome - RF69w\uc-terminal\src\usb_regs.c
      1          /******************** (C) COPYRIGHT 2011 STMicroelectronics ********************
      2          * File Name          : usb_regs.c
      3          * Author             : MCD Application Team
      4          * Version            : V3.3.0
      5          * Date               : 21-March-2011
      6          * Description        : Interface functions to USB cell registers
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          #ifndef STM32F10X_CL
     16          
     17          /* Includes ------------------------------------------------------------------*/
     18          #include "includes.h"
     19          #if USBD_MODULE == DEF_ENABLED
     20          
     21          /* Private typedef -----------------------------------------------------------*/
     22          /* Private define ------------------------------------------------------------*/
     23          /* Private macro -------------------------------------------------------------*/
     24          /* Private variables ---------------------------------------------------------*/
     25          /* Extern variables ----------------------------------------------------------*/
     26          /* Private function prototypes -----------------------------------------------*/
     27          /* Private functions ---------------------------------------------------------*/
     28          
     29          /*******************************************************************************
     30          * Function Name  : SetCNTR.
     31          * Description    : Set the CNTR register value.
     32          * Input          : wRegValue: new register value.
     33          * Output         : None.
     34          * Return         : None.
     35          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     36          void SetCNTR(INT16U wRegValue)
     37          {
     38            _SetCNTR(wRegValue);
   \                     SetCNTR: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable44  ;; 0x40005c40
   \   00000004   0x6008             STR      R0,[R1, #+0]
     39          }
   \   00000006   0x4770             BX       LR               ;; return
     40          
     41          /*******************************************************************************
     42          * Function Name  : GetCNTR.
     43          * Description    : returns the CNTR register value.
     44          * Input          : None.
     45          * Output         : None.
     46          * Return         : CNTR register Value.
     47          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     48          INT16U GetCNTR(void)
     49          {
     50            return(_GetCNTR());
   \                     GetCNTR: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable44  ;; 0x40005c40
   \   00000004   0x....             B.N      ?Subroutine5
     51          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0xB280             UXTH     R0,R0
   \   00000004   0x4770             BX       LR               ;; return
     52          
     53          /*******************************************************************************
     54          * Function Name  : SetISTR.
     55          * Description    : Set the ISTR register value.
     56          * Input          : wRegValue: new register value.
     57          * Output         : None.
     58          * Return         : None.
     59          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     60          void SetISTR(INT16U wRegValue)
     61          {
     62            _SetISTR(wRegValue);
   \                     SetISTR: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable44_1  ;; 0x40005c44
   \   00000004   0x6008             STR      R0,[R1, #+0]
     63          }
   \   00000006   0x4770             BX       LR               ;; return
     64          
     65          /*******************************************************************************
     66          * Function Name  : GetISTR
     67          * Description    : Returns the ISTR register value.
     68          * Input          : None.
     69          * Output         : None.
     70          * Return         : ISTR register Value
     71          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     72          INT16U GetISTR(void)
     73          {
     74            return(_GetISTR());
   \                     GetISTR: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable44_1  ;; 0x40005c44
   \   00000004                      REQUIRE ?Subroutine5
   \   00000004                      ;; // Fall through to label ?Subroutine5
     75          }
     76          
     77          /*******************************************************************************
     78          * Function Name  : GetFNR
     79          * Description    : Returns the FNR register value.
     80          * Input          : None.
     81          * Output         : None.
     82          * Return         : FNR register Value
     83          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     84          INT16U GetFNR(void)
     85          {
     86            return(_GetFNR());
   \                     GetFNR: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable44_2  ;; 0x40005c48
   \   00000004   0x....             B.N      ?Subroutine5
     87          }
     88          
     89          /*******************************************************************************
     90          * Function Name  : SetDADDR
     91          * Description    : Set the DADDR register value.
     92          * Input          : wRegValue: new register value.
     93          * Output         : None.
     94          * Return         : None.
     95          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     96          void SetDADDR(INT16U wRegValue)
     97          {
     98            _SetDADDR(wRegValue);
   \                     SetDADDR: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable44_3  ;; 0x40005c4c
   \   00000004   0x6008             STR      R0,[R1, #+0]
     99          }
   \   00000006   0x4770             BX       LR               ;; return
    100          
    101          /*******************************************************************************
    102          * Function Name  : GetDADDR
    103          * Description    : Returns the DADDR register value.
    104          * Input          : None.
    105          * Output         : None.
    106          * Return         : DADDR register Value
    107          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    108          INT16U GetDADDR(void)
    109          {
    110            return(_GetDADDR());
   \                     GetDADDR: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable44_3  ;; 0x40005c4c
   \   00000004   0x....             B.N      ?Subroutine5
    111          }
    112          
    113          /*******************************************************************************
    114          * Function Name  : SetBTABLE
    115          * Description    : Set the BTABLE.
    116          * Input          : wRegValue: New register value.
    117          * Output         : None.
    118          * Return         : None.
    119          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    120          void SetBTABLE(INT16U wRegValue)
    121          {
    122            _SetBTABLE(wRegValue);
   \                     SetBTABLE: (+1)
   \   00000000   0xF64F 0x71F8      MOVW     R1,#+65528
   \   00000004   0x4008             ANDS     R0,R1,R0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable44_4  ;; 0x40005c50
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    123          }
   \   0000000C   0x4770             BX       LR               ;; return
    124          
    125          /*******************************************************************************
    126          * Function Name  : GetBTABLE.
    127          * Description    : Returns the BTABLE register value.
    128          * Input          : None. 
    129          * Output         : None.
    130          * Return         : BTABLE address.
    131          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    132          INT16U GetBTABLE(void)
    133          {
    134            return(_GetBTABLE());
   \                     GetBTABLE: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable44_4  ;; 0x40005c50
   \   00000004   0x....             B.N      ?Subroutine5
    135          }
    136          
    137          /*******************************************************************************
    138          * Function Name  : SetENDPOINT
    139          * Description    : Set the Endpoint register value.
    140          * Input          : bEpNum: Endpoint Number. 
    141          *                  wRegValue.
    142          * Output         : None.
    143          * Return         : None.
    144          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    145          void SetENDPOINT(INT8U bEpNum, INT16U wRegValue)
    146          {
    147            _SetENDPOINT(bEpNum, wRegValue);
   \                     SetENDPOINT: (+1)
   \   00000000   0x.... 0x....      LDR.W    R2,??DataTable44_5  ;; 0x40005c00
   \   00000004   0x....             B.N      ??Subroutine6_0
    148          }

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine6_0: (+1)
   \   00000000   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   00000004   0x4770             BX       LR               ;; return
    149          
    150          /*******************************************************************************
    151          * Function Name  : GetENDPOINT
    152          * Description    : Return the Endpoint register value.
    153          * Input          : bEpNum: Endpoint Number. 
    154          * Output         : None.
    155          * Return         : Endpoint register value.
    156          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    157          INT16U GetENDPOINT(INT8U bEpNum)
    158          {
    159            return(_GetENDPOINT(bEpNum));
   \                     GetENDPOINT: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable44_5  ;; 0x40005c00
   \   00000004   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000008   0xB280             UXTH     R0,R0
   \   0000000A   0x4770             BX       LR               ;; return
    160          }
    161          
    162          /*******************************************************************************
    163          * Function Name  : SetEPType
    164          * Description    : sets the type in the endpoint register.
    165          * Input          : bEpNum: Endpoint Number. 
    166          *                  wType: type definition.
    167          * Output         : None.
    168          * Return         : None.
    169          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    170          void SetEPType(INT8U bEpNum, INT16U wType)
    171          {
    172            _SetEPType(bEpNum, wType);
   \                     SetEPType: (+1)
   \   00000000   0x.... 0x....      LDR.W    R2,??DataTable44_5  ;; 0x40005c00
   \   00000004   0xF852 0x3020      LDR      R3,[R2, R0, LSL #+2]
   \   00000008   0xF648 0x1C8F      MOVW     R12,#+35215
   \   0000000C   0xEA0C 0x0303      AND      R3,R12,R3
   \   00000010   0x4319             ORRS     R1,R1,R3
   \   00000012   0x....             B.N      ??Subroutine6_0
    173          }
    174          
    175          /*******************************************************************************
    176          * Function Name  : GetEPType
    177          * Description    : Returns the endpoint type.
    178          * Input          : bEpNum: Endpoint Number. 
    179          * Output         : None.
    180          * Return         : Endpoint Type
    181          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    182          INT16U GetEPType(INT8U bEpNum)
    183          {
    184            return(_GetEPType(bEpNum));
   \                     GetEPType: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable44_5  ;; 0x40005c00
   \   00000004   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000008   0xF400 0x60C0      AND      R0,R0,#0x600
   \   0000000C   0x4770             BX       LR               ;; return
    185          }
    186          
    187          /*******************************************************************************
    188          * Function Name  : SetEPTxStatus
    189          * Description    : Set the status of Tx endpoint.
    190          * Input          : bEpNum: Endpoint Number. 
    191          *                  wState: new state.
    192          * Output         : None.
    193          * Return         : None.
    194          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    195          void SetEPTxStatus(INT8U bEpNum, INT16U wState)
    196          {
    197            _SetEPTxStatus(bEpNum, wState);
   \                     SetEPTxStatus: (+1)
   \   00000000   0x.... 0x....      LDR.W    R2,??DataTable44_5  ;; 0x40005c00
   \   00000004   0xF852 0x3020      LDR      R3,[R2, R0, LSL #+2]
   \   00000008   0xF648 0x7CBF      MOVW     R12,#+36799
   \   0000000C   0xEA0C 0x0303      AND      R3,R12,R3
   \   00000010   0xEA5F 0x6CC1      LSLS     R12,R1,#+27
   \   00000014   0xBF48             IT       MI 
   \   00000016   0xF083 0x0310      EORMI    R3,R3,#0x10
   \   0000001A   0x0689             LSLS     R1,R1,#+26
   \   0000001C   0xBF48             IT       MI 
   \   0000001E   0xF083 0x0320      EORMI    R3,R3,#0x20
   \   00000022   0x....             B.N      ?Subroutine4
    198          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0xF443 0x4100      ORR      R1,R3,#0x8000
   \                     ??Subroutine4_0: (+1)
   \   00000004   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000008                      REQUIRE ??Subroutine6_0
   \   00000008                      ;; // Fall through to label ??Subroutine6_0
    199          
    200          /*******************************************************************************
    201          * Function Name  : SetEPRxStatus
    202          * Description    : Set the status of Rx endpoint.
    203          * Input          : bEpNum: Endpoint Number. 
    204          *                  wState: new state.
    205          * Output         : None.
    206          * Return         : None.
    207          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    208          void SetEPRxStatus(INT8U bEpNum, INT16U wState)
    209          {
    210            _SetEPRxStatus(bEpNum, wState);
   \                     SetEPRxStatus: (+1)
   \   00000000   0x.... 0x....      LDR.W    R2,??DataTable44_5  ;; 0x40005c00
   \   00000004   0xF852 0x3020      LDR      R3,[R2, R0, LSL #+2]
   \   00000008   0xF64B 0x7C8F      MOVW     R12,#+49039
   \   0000000C   0xEA0C 0x0303      AND      R3,R12,R3
   \   00000010   0xEA5F 0x4CC1      LSLS     R12,R1,#+19
   \   00000014   0xBF48             IT       MI 
   \   00000016   0xF483 0x5380      EORMI    R3,R3,#0x1000
   \   0000001A   0x0489             LSLS     R1,R1,#+18
   \   0000001C   0xBF48             IT       MI 
   \   0000001E   0xF483 0x5300      EORMI    R3,R3,#0x2000
   \   00000022                      REQUIRE ?Subroutine4
   \   00000022                      ;; // Fall through to label ?Subroutine4
    211          }
    212          
    213          /*******************************************************************************
    214          * Function Name  : SetDouBleBuffEPStall
    215          * Description    : sets the status for Double Buffer Endpoint to STALL
    216          * Input          : bEpNum: Endpoint Number. 
    217          *                  bDir: Endpoint direction.
    218          * Output         : None.
    219          * Return         : None.
    220          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    221          void SetDouBleBuffEPStall(INT8U bEpNum, INT8U bDir)
    222          {
    223            INT16U Endpoint_DTOG_Status;
    224            Endpoint_DTOG_Status = GetENDPOINT(bEpNum);
   \                     SetDouBleBuffEPStall: (+1)
   \   00000000   0x.... 0x....      LDR.W    R2,??DataTable44_5  ;; 0x40005c00
   \   00000004   0xF852 0x3020      LDR      R3,[R2, R0, LSL #+2]
   \   00000008   0xB29B             UXTH     R3,R3
    225            if (bDir == EP_DBUF_OUT)
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xBF08             IT       EQ 
   \   0000000E   0xF423 0x5180      BICEQ    R1,R3,#0x1000
    226            { /* OUT double buffered endpoint */
    227              _SetENDPOINT(bEpNum, Endpoint_DTOG_Status & ~EPRX_DTOG1);
   \   00000012   0xD003             BEQ.N    ??SetDouBleBuffEPStall_0
    228            }
    229            else if (bDir == EP_DBUF_IN)
   \   00000014   0x2902             CMP      R1,#+2
   \   00000016   0xD103             BNE.N    ??SetDouBleBuffEPStall_1
    230            { /* IN double buffered endpoint */
    231              _SetENDPOINT(bEpNum, Endpoint_DTOG_Status & ~EPTX_DTOG1);
   \   00000018   0xF023 0x0110      BIC      R1,R3,#0x10
   \                     ??SetDouBleBuffEPStall_0: (+1)
   \   0000001C   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
    232            }
    233          }
   \                     ??SetDouBleBuffEPStall_1: (+1)
   \   00000020   0x4770             BX       LR               ;; return
    234          
    235          /*******************************************************************************
    236          * Function Name  : GetEPTxStatus
    237          * Description    : Returns the endpoint Tx status.
    238          * Input          : bEpNum: Endpoint Number. 
    239          * Output         : None.
    240          * Return         : Endpoint TX Status
    241          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    242          INT16U GetEPTxStatus(INT8U bEpNum)
    243          {
    244            return(_GetEPTxStatus(bEpNum));
   \                     GetEPTxStatus: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable44_5  ;; 0x40005c00
   \   00000004   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000008   0xF000 0x0030      AND      R0,R0,#0x30
   \   0000000C   0x4770             BX       LR               ;; return
    245          }
    246          
    247          /*******************************************************************************
    248          * Function Name  : GetEPRxStatus
    249          * Description    : Returns the endpoint Rx status.
    250          * Input          : bEpNum: Endpoint Number. 
    251          * Output         : None.
    252          * Return         : Endpoint RX Status
    253          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    254          INT16U GetEPRxStatus(INT8U bEpNum)
    255          {
    256            return(_GetEPRxStatus(bEpNum));
   \                     GetEPRxStatus: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable44_5  ;; 0x40005c00
   \   00000004   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000008   0xF400 0x5040      AND      R0,R0,#0x3000
   \   0000000C   0x4770             BX       LR               ;; return
    257          }
    258          
    259          /*******************************************************************************
    260          * Function Name  : SetEPTxValid
    261          * Description    : Valid the endpoint Tx Status.
    262          * Input          : bEpNum: Endpoint Number.  
    263          * Output         : None.
    264          * Return         : None.
    265          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    266          void SetEPTxValid(INT8U bEpNum)
    267          {
    268            _SetEPTxStatus(bEpNum, EP_TX_VALID);
   \                     SetEPTxValid: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable44_5  ;; 0x40005c00
   \   00000004   0xF851 0x2020      LDR      R2,[R1, R0, LSL #+2]
   \   00000008   0xF648 0x73BF      MOVW     R3,#+36799
   \   0000000C   0x401A             ANDS     R2,R3,R2
   \   0000000E   0xF082 0x0230      EOR      R2,R2,#0x30
   \   00000012   0xF442 0x4200      ORR      R2,R2,#0x8000
   \   00000016   0x....             B.N      ??Subroutine7_0
    269          }

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine7_0: (+1)
   \   00000000   0xF042 0x0280      ORR      R2,R2,#0x80
   \                     ??Subroutine7_1: (+1)
   \   00000004   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \   00000008   0x4770             BX       LR               ;; return
    270          
    271          /*******************************************************************************
    272          * Function Name  : SetEPRxValid
    273          * Description    : Valid the endpoint Rx Status.
    274          * Input          : bEpNum: Endpoint Number. 
    275          * Output         : None.
    276          * Return         : None.
    277          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    278          void SetEPRxValid(INT8U bEpNum)
    279          {
    280            _SetEPRxStatus(bEpNum, EP_RX_VALID);
   \                     SetEPRxValid: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable44_5  ;; 0x40005c00
   \   00000004   0xF851 0x2020      LDR      R2,[R1, R0, LSL #+2]
   \   00000008   0xF64B 0x738F      MOVW     R3,#+49039
   \   0000000C   0x401A             ANDS     R2,R3,R2
   \   0000000E   0xF482 0x5240      EOR      R2,R2,#0x3000
   \   00000012   0xF442 0x4200      ORR      R2,R2,#0x8000
   \   00000016   0x....             B.N      ??Subroutine7_0
    281          }
    282          
    283          /*******************************************************************************
    284          * Function Name  : SetEP_KIND
    285          * Description    : Clear the EP_KIND bit.
    286          * Input          : bEpNum: Endpoint Number. 
    287          * Output         : None.
    288          * Return         : None.
    289          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    290          void SetEP_KIND(INT8U bEpNum)
    291          {
    292            _SetEP_KIND(bEpNum);
   \                     SetEP_KIND: (+1)
   \   00000000   0x....             B.N      ?Subroutine0
    293          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable44_5  ;; 0x40005c00
   \   00000004   0xF851 0x2020      LDR      R2,[R1, R0, LSL #+2]
   \   00000008   0xF648 0x738F      MOVW     R3,#+36751
   \   0000000C   0x401A             ANDS     R2,R3,R2
   \   0000000E   0xF442 0x4201      ORR      R2,R2,#0x8100
   \   00000012                      REQUIRE ??Subroutine7_0
   \   00000012                      ;; // Fall through to label ??Subroutine7_0
    294          
    295          /*******************************************************************************
    296          * Function Name  : ClearEP_KIND
    297          * Description    : set the  EP_KIND bit.
    298          * Input          : bEpNum: Endpoint Number. 
    299          * Output         : None.
    300          * Return         : None.
    301          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    302          void ClearEP_KIND(INT8U bEpNum)
    303          {
    304            _ClearEP_KIND(bEpNum);
   \                     ClearEP_KIND: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable44_5  ;; 0x40005c00
   \   00000004   0xF851 0x2020      LDR      R2,[R1, R0, LSL #+2]
   \   00000008   0xF648 0x638F      MOVW     R3,#+36495
   \   0000000C   0x401A             ANDS     R2,R3,R2
   \   0000000E   0xF442 0x4200      ORR      R2,R2,#0x8000
   \   00000012   0x....             B.N      ??Subroutine7_0
    305          }
    306          /*******************************************************************************
    307          * Function Name  : Clear_Status_Out
    308          * Description    : Clear the Status Out of the related Endpoint
    309          * Input          : bEpNum: Endpoint Number. 
    310          * Output         : None.
    311          * Return         : None.
    312          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    313          void Clear_Status_Out(INT8U bEpNum)
    314          {
    315            _ClearEP_KIND(bEpNum);
   \                     Clear_Status_Out: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable44_5  ;; 0x40005c00
   \   00000004   0xF851 0x2020      LDR      R2,[R1, R0, LSL #+2]
   \   00000008   0xF648 0x638F      MOVW     R3,#+36495
   \   0000000C   0x401A             ANDS     R2,R3,R2
   \   0000000E   0xF442 0x4200      ORR      R2,R2,#0x8000
   \   00000012   0x....             B.N      ??Subroutine7_0
    316          }
    317          /*******************************************************************************
    318          * Function Name  : Set_Status_Out
    319          * Description    : Set the Status Out of the related Endpoint
    320          * Input          : bEpNum: Endpoint Number. 
    321          * Output         : None.
    322          * Return         : None.
    323          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    324          void Set_Status_Out(INT8U bEpNum)
   \                     Set_Status_Out: (+1)
   \   00000000   0xBF00             Nop      
    325          {
    326            _SetEP_KIND(bEpNum);
   \   00000002                      REQUIRE ?Subroutine0
   \   00000002                      ;; // Fall through to label ?Subroutine0
    327          }
    328          /*******************************************************************************
    329          * Function Name  : SetEPDoubleBuff
    330          * Description    : Enable the double buffer feature for the endpoint. 
    331          * Input          : bEpNum: Endpoint Number. 
    332          * Output         : None.
    333          * Return         : None.
    334          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    335          void SetEPDoubleBuff(INT8U bEpNum)
    336          {
    337            _SetEP_KIND(bEpNum);
   \                     SetEPDoubleBuff: (+1)
   \   00000000   0x....             B.N      ?Subroutine0
    338          }
    339          /*******************************************************************************
    340          * Function Name  : ClearEPDoubleBuff
    341          * Description    : Disable the double buffer feature for the endpoint. 
    342          * Input          : bEpNum: Endpoint Number. 
    343          * Output         : None.
    344          * Return         : None.
    345          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    346          void ClearEPDoubleBuff(INT8U bEpNum)
    347          {
    348            _ClearEP_KIND(bEpNum);
   \                     ClearEPDoubleBuff: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable44_5  ;; 0x40005c00
   \   00000004   0xF851 0x2020      LDR      R2,[R1, R0, LSL #+2]
   \   00000008   0xF648 0x638F      MOVW     R3,#+36495
   \   0000000C   0x401A             ANDS     R2,R3,R2
   \   0000000E   0xF442 0x4200      ORR      R2,R2,#0x8000
   \   00000012   0x....             B.N      ??Subroutine7_0
    349          }
    350          /*******************************************************************************
    351          * Function Name  : GetTxStallStatus
    352          * Description    : Returns the Stall status of the Tx endpoint.
    353          * Input          : bEpNum: Endpoint Number. 
    354          * Output         : None.
    355          * Return         : Tx Stall status.
    356          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    357          INT16U GetTxStallStatus(INT8U bEpNum)
    358          {
    359            return(_GetTxStallStatus(bEpNum));
   \                     GetTxStallStatus: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable44_5  ;; 0x40005c00
   \   00000004   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000008   0xF000 0x0030      AND      R0,R0,#0x30
   \   0000000C   0x2810             CMP      R0,#+16
   \   0000000E   0xBF0C             ITE      EQ 
   \   00000010   0x2001             MOVEQ    R0,#+1
   \   00000012   0x2000             MOVNE    R0,#+0
   \   00000014   0x4770             BX       LR
    360          }
    361          /*******************************************************************************
    362          * Function Name  : GetRxStallStatus
    363          * Description    : Returns the Stall status of the Rx endpoint. 
    364          * Input          : bEpNum: Endpoint Number. 
    365          * Output         : None.
    366          * Return         : Rx Stall status.
    367          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    368          INT16U GetRxStallStatus(INT8U bEpNum)
    369          {
    370            return(_GetRxStallStatus(bEpNum));
   \                     GetRxStallStatus: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable44_5  ;; 0x40005c00
   \   00000004   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000008   0xF400 0x5040      AND      R0,R0,#0x3000
   \   0000000C   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000010   0xBF0C             ITE      EQ 
   \   00000012   0x2001             MOVEQ    R0,#+1
   \   00000014   0x2000             MOVNE    R0,#+0
   \   00000016   0x4770             BX       LR
    371          }
    372          /*******************************************************************************
    373          * Function Name  : ClearEP_CTR_RX
    374          * Description    : Clear the CTR_RX bit.
    375          * Input          : bEpNum: Endpoint Number. 
    376          * Output         : None.
    377          * Return         : None.
    378          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    379          void ClearEP_CTR_RX(INT8U bEpNum)
    380          {
    381            _ClearEP_CTR_RX(bEpNum);
   \                     ClearEP_CTR_RX: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable44_5  ;; 0x40005c00
   \   00000004   0xF851 0x2020      LDR      R2,[R1, R0, LSL #+2]
   \   00000008   0xF640 0x738F      MOVW     R3,#+3983
   \   0000000C   0x401A             ANDS     R2,R3,R2
   \   0000000E   0x....             B.N      ??Subroutine7_1
    382          }
    383          /*******************************************************************************
    384          * Function Name  : ClearEP_CTR_TX
    385          * Description    : Clear the CTR_TX bit.
    386          * Input          : bEpNum: Endpoint Number. 
    387          * Output         : None.
    388          * Return         : None.
    389          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    390          void ClearEP_CTR_TX(INT8U bEpNum)
    391          {
    392            _ClearEP_CTR_TX(bEpNum);
   \                     ClearEP_CTR_TX: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable44_5  ;; 0x40005c00
   \   00000004   0xF851 0x2020      LDR      R2,[R1, R0, LSL #+2]
   \   00000008   0xF648 0x730F      MOVW     R3,#+36623
   \   0000000C   0x401A             ANDS     R2,R3,R2
   \   0000000E   0x....             B.N      ??Subroutine7_1
    393          }
    394          /*******************************************************************************
    395          * Function Name  : ToggleDTOG_RX
    396          * Description    : Toggle the DTOG_RX bit.
    397          * Input          : bEpNum: Endpoint Number. 
    398          * Output         : None.
    399          * Return         : None.
    400          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    401          void ToggleDTOG_RX(INT8U bEpNum)
    402          {
    403            _ToggleDTOG_RX(bEpNum);
   \                     ToggleDTOG_RX: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable44_5  ;; 0x40005c00
   \   00000004   0xF851 0x2020      LDR      R2,[R1, R0, LSL #+2]
   \   00000008   0xF648 0x738F      MOVW     R3,#+36751
   \   0000000C   0x401A             ANDS     R2,R3,R2
   \   0000000E   0xF442 0x4240      ORR      R2,R2,#0xC000
   \   00000012   0x....             B.N      ??Subroutine7_0
    404          }
    405          /*******************************************************************************
    406          * Function Name  : ToggleDTOG_TX
    407          * Description    : Toggle the DTOG_TX bit.
    408          * Input          : bEpNum: Endpoint Number. 
    409          * Output         : None.
    410          * Return         : None.
    411          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    412          void ToggleDTOG_TX(INT8U bEpNum)
    413          {
    414            _ToggleDTOG_TX(bEpNum);
   \                     ToggleDTOG_TX: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable44_5  ;; 0x40005c00
   \   00000004   0xF851 0x2020      LDR      R2,[R1, R0, LSL #+2]
   \   00000008   0xF648 0x738F      MOVW     R3,#+36751
   \   0000000C   0x401A             ANDS     R2,R3,R2
   \   0000000E   0xF442 0x4200      ORR      R2,R2,#0x8000
   \   00000012   0xF042 0x02C0      ORR      R2,R2,#0xC0
   \   00000016   0x....             B.N      ??Subroutine7_1
    415          }
    416          /*******************************************************************************
    417          * Function Name  : ClearDTOG_RX.
    418          * Description    : Clear the DTOG_RX bit.
    419          * Input          : bEpNum: Endpoint Number. 
    420          * Output         : None.
    421          * Return         : None.
    422          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    423          void ClearDTOG_RX(INT8U bEpNum)
    424          {
    425            _ClearDTOG_RX(bEpNum);
   \                     ClearDTOG_RX: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable44_5  ;; 0x40005c00
   \   00000004   0xF851 0x2020      LDR      R2,[R1, R0, LSL #+2]
   \   00000008   0x0452             LSLS     R2,R2,#+17
   \   0000000A   0xD50A             BPL.N    ??ClearDTOG_RX_0
   \   0000000C   0xF851 0x2020      LDR      R2,[R1, R0, LSL #+2]
   \   00000010   0xF648 0x738F      MOVW     R3,#+36751
   \   00000014   0x401A             ANDS     R2,R3,R2
   \   00000016   0xF442 0x4240      ORR      R2,R2,#0xC000
   \   0000001A   0xF042 0x0280      ORR      R2,R2,#0x80
   \   0000001E   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    426          }
   \                     ??ClearDTOG_RX_0: (+1)
   \   00000022   0x4770             BX       LR               ;; return
    427          /*******************************************************************************
    428          * Function Name  : ClearDTOG_TX.
    429          * Description    : Clear the DTOG_TX bit.
    430          * Input          : bEpNum: Endpoint Number. 
    431          * Output         : None.
    432          * Return         : None.
    433          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    434          void ClearDTOG_TX(INT8U bEpNum)
    435          {
    436            _ClearDTOG_TX(bEpNum);
   \                     ClearDTOG_TX: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable44_5  ;; 0x40005c00
   \   00000004   0xF851 0x2020      LDR      R2,[R1, R0, LSL #+2]
   \   00000008   0x0652             LSLS     R2,R2,#+25
   \   0000000A   0xD50A             BPL.N    ??ClearDTOG_TX_0
   \   0000000C   0xF851 0x2020      LDR      R2,[R1, R0, LSL #+2]
   \   00000010   0xF648 0x738F      MOVW     R3,#+36751
   \   00000014   0x401A             ANDS     R2,R3,R2
   \   00000016   0xF442 0x4200      ORR      R2,R2,#0x8000
   \   0000001A   0xF042 0x02C0      ORR      R2,R2,#0xC0
   \   0000001E   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    437          }
   \                     ??ClearDTOG_TX_0: (+1)
   \   00000022   0x4770             BX       LR               ;; return
    438          /*******************************************************************************
    439          * Function Name  : SetEPAddress
    440          * Description    : Set the endpoint address.
    441          * Input          : bEpNum: Endpoint Number.
    442          *                  bAddr: New endpoint address.
    443          * Output         : None.
    444          * Return         : None.
    445          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    446          void SetEPAddress(INT8U bEpNum, INT8U bAddr)
    447          {
    448            _SetEPAddress(bEpNum, bAddr);
   \                     SetEPAddress: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable44_5  ;; 0x40005c00
   \   00000002   0xF852 0x3020      LDR      R3,[R2, R0, LSL #+2]
   \   00000006   0xF648 0x7C8F      MOVW     R12,#+36751
   \   0000000A   0xEA0C 0x0303      AND      R3,R12,R3
   \   0000000E   0x4319             ORRS     R1,R1,R3
   \   00000010   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000014   0x....             B.N      ??Subroutine4_0
    449          }
    450          /*******************************************************************************
    451          * Function Name  : GetEPAddress
    452          * Description    : Get the endpoint address.
    453          * Input          : bEpNum: Endpoint Number. 
    454          * Output         : None.
    455          * Return         : Endpoint address.
    456          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    457          INT8U GetEPAddress(INT8U bEpNum)
    458          {
    459            return(_GetEPAddress(bEpNum));
   \                     GetEPAddress: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable44_5  ;; 0x40005c00
   \   00000002   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000006   0xF000 0x000F      AND      R0,R0,#0xF
   \   0000000A   0x4770             BX       LR               ;; return
    460          }
    461          /*******************************************************************************
    462          * Function Name  : SetEPTxAddr
    463          * Description    : Set the endpoint Tx buffer address.
    464          * Input          : bEpNum: Endpoint Number.
    465          *                  wAddr: new address. 
    466          * Output         : None.
    467          * Return         : None.
    468          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    469          void SetEPTxAddr(INT8U bEpNum, INT16U wAddr)
    470          {
    471            _SetEPTxAddr(bEpNum, wAddr);
   \                     SetEPTxAddr: (+1)
   \   00000000   0x....             B.N      ?Subroutine1
    472          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable44_4  ;; 0x40005c50
   \   00000002   0x6812             LDR      R2,[R2, #+0]
   \   00000004   0xB292             UXTH     R2,R2
   \   00000006   0xEB02 0x00C0      ADD      R0,R2,R0, LSL #+3
   \   0000000A   0x....             LDR.N    R2,??DataTable44_9  ;; 0x40006000
   \   0000000C                      REQUIRE ??Subroutine8_0
   \   0000000C                      ;; // Fall through to label ??Subroutine8_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine8_0: (+1)
   \   00000000   0x0849             LSRS     R1,R1,#+1
   \   00000002   0x0049             LSLS     R1,R1,#+1
   \                     ??Subroutine8_1: (+1)
   \   00000004   0xF842 0x1010      STR      R1,[R2, R0, LSL #+1]
   \   00000008   0x4770             BX       LR               ;; return
    473          /*******************************************************************************
    474          * Function Name  : SetEPRxAddr
    475          * Description    : Set the endpoint Rx buffer address.
    476          * Input          : bEpNum: Endpoint Number.
    477          *                  wAddr: new address.
    478          * Output         : None.
    479          * Return         : None.
    480          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    481          void SetEPRxAddr(INT8U bEpNum, INT16U wAddr)
    482          {
    483            _SetEPRxAddr(bEpNum, wAddr);
   \                     SetEPRxAddr: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable44_4  ;; 0x40005c50
   \   00000002   0x6812             LDR      R2,[R2, #+0]
   \   00000004   0xB292             UXTH     R2,R2
   \   00000006   0xEB02 0x00C0      ADD      R0,R2,R0, LSL #+3
   \   0000000A   0x....             LDR.N    R2,??DataTable44_6  ;; 0x40006008
   \   0000000C   0x....             B.N      ??Subroutine8_0
    484          }
    485          /*******************************************************************************
    486          * Function Name  : GetEPTxAddr
    487          * Description    : Returns the endpoint Tx buffer address.
    488          * Input          : bEpNum: Endpoint Number. 
    489          * Output         : None.
    490          * Return         : Rx buffer address. 
    491          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    492          INT16U GetEPTxAddr(INT8U bEpNum)
    493          {
    494            return(_GetEPTxAddr(bEpNum));
   \                     GetEPTxAddr: (+1)
   \   00000000   0x....             B.N      ?Subroutine3
    495          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable44_4  ;; 0x40005c50
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xB289             UXTH     R1,R1
   \   00000006   0xEB01 0x00C0      ADD      R0,R1,R0, LSL #+3
   \   0000000A   0x....             LDR.N    R1,??DataTable44_9  ;; 0x40006000
   \   0000000C                      REQUIRE ??Subroutine9_0
   \   0000000C                      ;; // Fall through to label ??Subroutine9_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine9_0: (+1)
   \   00000000   0xF851 0x0010      LDR      R0,[R1, R0, LSL #+1]
   \   00000004   0xB280             UXTH     R0,R0
   \   00000006   0x4770             BX       LR               ;; return
    496          /*******************************************************************************
    497          * Function Name  : GetEPRxAddr.
    498          * Description    : Returns the endpoint Rx buffer address.
    499          * Input          : bEpNum: Endpoint Number. 
    500          * Output         : None.
    501          * Return         : Rx buffer address.
    502          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    503          INT16U GetEPRxAddr(INT8U bEpNum)
    504          {
    505            return(_GetEPRxAddr(bEpNum));
   \                     GetEPRxAddr: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable44_4  ;; 0x40005c50
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xB289             UXTH     R1,R1
   \   00000006   0xEB01 0x00C0      ADD      R0,R1,R0, LSL #+3
   \   0000000A   0x....             LDR.N    R1,??DataTable44_6  ;; 0x40006008
   \   0000000C   0x....             B.N      ??Subroutine9_0
    506          }
    507          /*******************************************************************************
    508          * Function Name  : SetEPTxCount.
    509          * Description    : Set the Tx count.
    510          * Input          : bEpNum: Endpoint Number.
    511          *                  wCount: new count value.
    512          * Output         : None.
    513          * Return         : None.
    514          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    515          void SetEPTxCount(INT8U bEpNum, INT16U wCount)
    516          {
    517            _SetEPTxCount(bEpNum, wCount);
   \                     SetEPTxCount: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable44_4  ;; 0x40005c50
   \   00000002   0x6812             LDR      R2,[R2, #+0]
   \   00000004   0xB292             UXTH     R2,R2
   \   00000006   0xEB02 0x00C0      ADD      R0,R2,R0, LSL #+3
   \   0000000A   0x....             LDR.N    R2,??DataTable44_7  ;; 0x40006004
   \   0000000C   0x....             B.N      ??Subroutine8_1
    518          }
    519          /*******************************************************************************
    520          * Function Name  : SetEPCountRxReg.
    521          * Description    : Set the Count Rx Register value.
    522          * Input          : *pdwReg: point to the register.
    523          *                  wCount: the new register value.
    524          * Output         : None.
    525          * Return         : None.
    526          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    527          void SetEPCountRxReg(INT32U *pdwReg, INT16U wCount)
    528          {
    529            _SetEPCountRxReg(dwReg, wCount);
   \                     SetEPCountRxReg: (+1)
   \   00000000   0x293F             CMP      R1,#+63
   \   00000002   0xDB09             BLT.N    ??SetEPCountRxReg_0
   \   00000004   0x094A             LSRS     R2,R1,#+5
   \   00000006   0x231F             MOVS     R3,#+31
   \   00000008   0x4219             TST      R1,R3
   \   0000000A   0xBF08             IT       EQ 
   \   0000000C   0x1E52             SUBEQ    R2,R2,#+1
   \   0000000E   0x0412             LSLS     R2,R2,#+16
   \   00000010   0x0991             LSRS     R1,R2,#+6
   \   00000012   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000016   0xE005             B.N      ??SetEPCountRxReg_1
   \                     ??SetEPCountRxReg_0: (+1)
   \   00000018   0x084A             LSRS     R2,R1,#+1
   \   0000001A   0x07C9             LSLS     R1,R1,#+31
   \   0000001C   0xBF48             IT       MI 
   \   0000001E   0x1C52             ADDMI    R2,R2,#+1
   \   00000020   0x0412             LSLS     R2,R2,#+16
   \   00000022   0x0991             LSRS     R1,R2,#+6
   \                     ??SetEPCountRxReg_1: (+1)
   \   00000024   0x6001             STR      R1,[R0, #+0]
    530          }
   \   00000026   0x4770             BX       LR               ;; return
    531          /*******************************************************************************
    532          * Function Name  : SetEPRxCount
    533          * Description    : Set the Rx count.
    534          * Input          : bEpNum: Endpoint Number. 
    535          *                  wCount: the new count value.
    536          * Output         : None.
    537          * Return         : None.
    538          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    539          void SetEPRxCount(INT8U bEpNum, INT16U wCount)
    540          {
    541            _SetEPRxCount(bEpNum, wCount);
   \                     SetEPRxCount: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable44_4  ;; 0x40005c50
   \   00000002   0x6812             LDR      R2,[R2, #+0]
   \   00000004   0xB292             UXTH     R2,R2
   \   00000006   0xEB02 0x00C0      ADD      R0,R2,R0, LSL #+3
   \   0000000A   0x....             LDR.N    R2,??DataTable44_8  ;; 0x4000600c
   \   0000000C   0x293F             CMP      R1,#+63
   \   0000000E   0xEB02 0x0240      ADD      R2,R2,R0, LSL #+1
   \   00000012   0xDB09             BLT.N    ??SetEPRxCount_0
   \   00000014   0x0948             LSRS     R0,R1,#+5
   \   00000016   0x231F             MOVS     R3,#+31
   \   00000018   0x4219             TST      R1,R3
   \   0000001A   0xBF08             IT       EQ 
   \   0000001C   0x1E40             SUBEQ    R0,R0,#+1
   \   0000001E   0x0400             LSLS     R0,R0,#+16
   \   00000020   0x0980             LSRS     R0,R0,#+6
   \   00000022   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000026   0xE005             B.N      ??SetEPRxCount_1
   \                     ??SetEPRxCount_0: (+1)
   \   00000028   0x0848             LSRS     R0,R1,#+1
   \   0000002A   0x07C9             LSLS     R1,R1,#+31
   \   0000002C   0xBF48             IT       MI 
   \   0000002E   0x1C40             ADDMI    R0,R0,#+1
   \   00000030   0x0400             LSLS     R0,R0,#+16
   \   00000032   0x0980             LSRS     R0,R0,#+6
   \                     ??SetEPRxCount_1: (+1)
   \   00000034   0x6010             STR      R0,[R2, #+0]
    542          }
   \   00000036   0x4770             BX       LR               ;; return
    543          /*******************************************************************************
    544          * Function Name  : GetEPTxCount
    545          * Description    : Get the Tx count.
    546          * Input          : bEpNum: Endpoint Number. 
    547          * Output         : None
    548          * Return         : Tx count value.
    549          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    550          INT16U GetEPTxCount(INT8U bEpNum)
    551          {
    552            return(_GetEPTxCount(bEpNum));
   \                     GetEPTxCount: (+1)
   \   00000000   0x....             B.N      ?Subroutine2
    553          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable44_4  ;; 0x40005c50
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xB289             UXTH     R1,R1
   \   00000006   0xEB01 0x00C0      ADD      R0,R1,R0, LSL #+3
   \   0000000A   0x....             LDR.N    R1,??DataTable44_7  ;; 0x40006004
   \   0000000C                      REQUIRE ??Subroutine10_0
   \   0000000C                      ;; // Fall through to label ??Subroutine10_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine10_0: (+1)
   \   00000000   0xF851 0x0010      LDR      R0,[R1, R0, LSL #+1]
   \   00000004   0x0580             LSLS     R0,R0,#+22
   \   00000006   0x0D80             LSRS     R0,R0,#+22
   \   00000008   0x4770             BX       LR               ;; return
    554          /*******************************************************************************
    555          * Function Name  : GetEPRxCount
    556          * Description    : Get the Rx count.
    557          * Input          : bEpNum: Endpoint Number. 
    558          * Output         : None.
    559          * Return         : Rx count value.
    560          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    561          INT16U GetEPRxCount(INT8U bEpNum)
    562          {
    563            return(_GetEPRxCount(bEpNum));
   \                     GetEPRxCount: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable44_4  ;; 0x40005c50
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xB289             UXTH     R1,R1
   \   00000006   0xEB01 0x00C0      ADD      R0,R1,R0, LSL #+3
   \   0000000A   0x....             LDR.N    R1,??DataTable44_8  ;; 0x4000600c
   \   0000000C   0x....             B.N      ??Subroutine10_0
    564          }
    565          /*******************************************************************************
    566          * Function Name  : SetEPDblBuffAddr
    567          * Description    : Set the addresses of the buffer 0 and 1.
    568          * Input          : bEpNum: Endpoint Number.  
    569          *                  wBuf0Addr: new address of buffer 0. 
    570          *                  wBuf1Addr: new address of buffer 1.
    571          * Output         : None.
    572          * Return         : None.
    573          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    574          void SetEPDblBuffAddr(INT8U bEpNum, INT16U wBuf0Addr, INT16U wBuf1Addr)
    575          {
   \                     SetEPDblBuffAddr: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    576            _SetEPDblBuffAddr(bEpNum, wBuf0Addr, wBuf1Addr);
   \   00000002   0x....             LDR.N    R3,??DataTable44_4  ;; 0x40005c50
   \   00000004   0x....             LDR.N    R5,??DataTable44_9  ;; 0x40006000
   \   00000006   0x681C             LDR      R4,[R3, #+0]
   \   00000008   0x0849             LSRS     R1,R1,#+1
   \   0000000A   0xB2A4             UXTH     R4,R4
   \   0000000C   0x0049             LSLS     R1,R1,#+1
   \   0000000E   0xEB04 0x04C0      ADD      R4,R4,R0, LSL #+3
   \   00000012   0xF845 0x1014      STR      R1,[R5, R4, LSL #+1]
   \   00000016   0x0851             LSRS     R1,R2,#+1
   \   00000018   0x681A             LDR      R2,[R3, #+0]
   \   0000001A   0xB292             UXTH     R2,R2
   \   0000001C   0xEB02 0x00C0      ADD      R0,R2,R0, LSL #+3
   \   00000020   0x....             LDR.N    R2,??DataTable44_6  ;; 0x40006008
   \   00000022   0x0049             LSLS     R1,R1,#+1
   \   00000024   0xF842 0x1010      STR      R1,[R2, R0, LSL #+1]
    577          }
   \   00000028   0xBC30             POP      {R4,R5}
   \   0000002A   0x4770             BX       LR               ;; return
    578          /*******************************************************************************
    579          * Function Name  : SetEPDblBuf0Addr
    580          * Description    : Set the Buffer 1 address.
    581          * Input          : bEpNum: Endpoint Number
    582          *                  wBuf0Addr: new address.
    583          * Output         : None.
    584          * Return         : None.
    585          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    586          void SetEPDblBuf0Addr(INT8U bEpNum, INT16U wBuf0Addr)
   \                     SetEPDblBuf0Addr: (+1)
   \   00000000   0xBF00             Nop      
    587          {
    588            _SetEPDblBuf0Addr(bEpNum, wBuf0Addr);
   \   00000002                      REQUIRE ?Subroutine1
   \   00000002                      ;; // Fall through to label ?Subroutine1
    589          }
    590          /*******************************************************************************
    591          * Function Name  : SetEPDblBuf1Addr
    592          * Description    : Set the Buffer 1 address.
    593          * Input          : bEpNum: Endpoint Number
    594          *                  wBuf1Addr: new address.
    595          * Output         : None.
    596          * Return         : None.
    597          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    598          void SetEPDblBuf1Addr(INT8U bEpNum, INT16U wBuf1Addr)
    599          {
    600            _SetEPDblBuf1Addr(bEpNum, wBuf1Addr);
   \                     SetEPDblBuf1Addr: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable44_4  ;; 0x40005c50
   \   00000002   0x6812             LDR      R2,[R2, #+0]
   \   00000004   0xB292             UXTH     R2,R2
   \   00000006   0xEB02 0x00C0      ADD      R0,R2,R0, LSL #+3
   \   0000000A   0x....             LDR.N    R2,??DataTable44_6  ;; 0x40006008
   \   0000000C   0x....             B.N      ??Subroutine8_0
    601          }
    602          /*******************************************************************************
    603          * Function Name  : GetEPDblBuf0Addr
    604          * Description    : Returns the address of the Buffer 0.
    605          * Input          : bEpNum: Endpoint Number.
    606          * Output         : None.
    607          * Return         : None.
    608          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    609          INT16U GetEPDblBuf0Addr(INT8U bEpNum)
   \                     GetEPDblBuf0Addr: (+1)
   \   00000000   0xBF00             Nop      
    610          {
    611            return(_GetEPDblBuf0Addr(bEpNum));
   \   00000002                      REQUIRE ?Subroutine3
   \   00000002                      ;; // Fall through to label ?Subroutine3
    612          }
    613          /*******************************************************************************
    614          * Function Name  : GetEPDblBuf1Addr
    615          * Description    : Returns the address of the Buffer 1.
    616          * Input          : bEpNum: Endpoint Number.
    617          * Output         : None.
    618          * Return         : Address of the Buffer 1.
    619          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    620          INT16U GetEPDblBuf1Addr(INT8U bEpNum)
    621          {
    622            return(_GetEPDblBuf1Addr(bEpNum));
   \                     GetEPDblBuf1Addr: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable44_4  ;; 0x40005c50
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xB289             UXTH     R1,R1
   \   00000006   0xEB01 0x00C0      ADD      R0,R1,R0, LSL #+3
   \   0000000A   0x....             LDR.N    R1,??DataTable44_6  ;; 0x40006008
   \   0000000C   0x....             B.N      ??Subroutine9_0
    623          }
    624          /*******************************************************************************
    625          * Function Name  : SetEPDblBuffCount
    626          * Description    : Set the number of bytes for a double Buffer 
    627          *                  endpoint.
    628          * Input          : bEpNum,bDir, wCount
    629          * Output         : None.
    630          * Return         : None.
    631          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    632          void SetEPDblBuffCount(INT8U bEpNum, INT8U bDir, INT16U wCount)
    633          {
   \                     SetEPDblBuffCount: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    634            _SetEPDblBuffCount(bEpNum, bDir, wCount);
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD12C             BNE.N    ??SetEPDblBuffCount_0
   \   00000006   0x....             LDR.N    R3,??DataTable44_4  ;; 0x40005c50
   \   00000008   0x....             LDR.N    R4,??DataTable44_7  ;; 0x40006004
   \   0000000A   0x00C1             LSLS     R1,R0,#+3
   \   0000000C   0x6818             LDR      R0,[R3, #+0]
   \   0000000E   0xB280             UXTH     R0,R0
   \   00000010   0x1808             ADDS     R0,R1,R0
   \   00000012   0x2A3F             CMP      R2,#+63
   \   00000014   0xEB04 0x0540      ADD      R5,R4,R0, LSL #+1
   \   00000018   0xDB1B             BLT.N    ??SetEPDblBuffCount_1
   \   0000001A   0x0950             LSRS     R0,R2,#+5
   \   0000001C   0x261F             MOVS     R6,#+31
   \   0000001E   0x4232             TST      R2,R6
   \   00000020   0xBF08             IT       EQ 
   \   00000022   0x1E40             SUBEQ    R0,R0,#+1
   \   00000024   0x0400             LSLS     R0,R0,#+16
   \   00000026   0x0980             LSRS     R0,R0,#+6
   \   00000028   0xF440 0x4000      ORR      R0,R0,#0x8000
   \                     ??SetEPDblBuffCount_2: (+1)
   \   0000002C   0x6028             STR      R0,[R5, #+0]
   \   0000002E   0x6818             LDR      R0,[R3, #+0]
   \   00000030   0xB280             UXTH     R0,R0
   \   00000032   0x1808             ADDS     R0,R1,R0
   \   00000034   0x....             LDR.N    R1,??DataTable44_8  ;; 0x4000600c
   \   00000036   0x2A3F             CMP      R2,#+63
   \   00000038   0xEB01 0x0140      ADD      R1,R1,R0, LSL #+1
   \   0000003C   0xDB22             BLT.N    ??SetEPDblBuffCount_3
   \   0000003E   0x0950             LSRS     R0,R2,#+5
   \   00000040   0x231F             MOVS     R3,#+31
   \   00000042   0x421A             TST      R2,R3
   \   00000044   0xBF08             IT       EQ 
   \   00000046   0x1E40             SUBEQ    R0,R0,#+1
   \   00000048   0x0400             LSLS     R0,R0,#+16
   \   0000004A   0x0980             LSRS     R0,R0,#+6
   \   0000004C   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000050   0xE01E             B.N      ??SetEPDblBuffCount_4
   \                     ??SetEPDblBuffCount_1: (+1)
   \   00000052   0x0850             LSRS     R0,R2,#+1
   \   00000054   0x07D6             LSLS     R6,R2,#+31
   \   00000056   0xBF48             IT       MI 
   \   00000058   0x1C40             ADDMI    R0,R0,#+1
   \   0000005A   0x0400             LSLS     R0,R0,#+16
   \   0000005C   0x0980             LSRS     R0,R0,#+6
   \   0000005E   0xE7E5             B.N      ??SetEPDblBuffCount_2
   \                     ??SetEPDblBuffCount_0: (+1)
   \   00000060   0x2902             CMP      R1,#+2
   \   00000062   0xD116             BNE.N    ??SetEPDblBuffCount_5
   \   00000064   0x....             LDR.N    R3,??DataTable44_4  ;; 0x40005c50
   \   00000066   0x....             LDR.N    R4,??DataTable44_7  ;; 0x40006004
   \   00000068   0x00C1             LSLS     R1,R0,#+3
   \   0000006A   0x6818             LDR      R0,[R3, #+0]
   \   0000006C   0xB280             UXTH     R0,R0
   \   0000006E   0x1808             ADDS     R0,R1,R0
   \   00000070   0xF844 0x2010      STR      R2,[R4, R0, LSL #+1]
   \   00000074   0x6818             LDR      R0,[R3, #+0]
   \   00000076   0xB280             UXTH     R0,R0
   \   00000078   0x1808             ADDS     R0,R1,R0
   \   0000007A   0x....             LDR.N    R1,??DataTable44_8  ;; 0x4000600c
   \   0000007C   0xF841 0x2010      STR      R2,[R1, R0, LSL #+1]
    635          }
   \   00000080   0xBC70             POP      {R4-R6}
   \   00000082   0x4770             BX       LR
   \                     ??SetEPDblBuffCount_3: (+1)
   \   00000084   0x0850             LSRS     R0,R2,#+1
   \   00000086   0x07D2             LSLS     R2,R2,#+31
   \   00000088   0xBF48             IT       MI 
   \   0000008A   0x1C40             ADDMI    R0,R0,#+1
   \   0000008C   0x0400             LSLS     R0,R0,#+16
   \   0000008E   0x0980             LSRS     R0,R0,#+6
   \                     ??SetEPDblBuffCount_4: (+1)
   \   00000090   0x6008             STR      R0,[R1, #+0]
   \                     ??SetEPDblBuffCount_5: (+1)
   \   00000092   0xBC70             POP      {R4-R6}
   \   00000094   0x4770             BX       LR               ;; return
    636          /*******************************************************************************
    637          * Function Name  : SetEPDblBuf0Count
    638          * Description    : Set the number of bytes in the buffer 0 of a double Buffer 
    639          *                  endpoint.
    640          * Input          : bEpNum, bDir,  wCount
    641          * Output         : None.
    642          * Return         : None.
    643          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    644          void SetEPDblBuf0Count(INT8U bEpNum, INT8U bDir, INT16U wCount)
    645          {
    646            _SetEPDblBuf0Count(bEpNum, bDir, wCount);
   \                     SetEPDblBuf0Count: (+1)
   \   00000000   0x2901             CMP      R1,#+1
   \   00000002   0xD11B             BNE.N    ??SetEPDblBuf0Count_0
   \   00000004   0x....             LDR.N    R1,??DataTable44_4  ;; 0x40005c50
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0xB289             UXTH     R1,R1
   \   0000000A   0xEB01 0x00C0      ADD      R0,R1,R0, LSL #+3
   \   0000000E   0x....             LDR.N    R1,??DataTable44_7  ;; 0x40006004
   \   00000010   0x2A3F             CMP      R2,#+63
   \   00000012   0xEB01 0x0140      ADD      R1,R1,R0, LSL #+1
   \   00000016   0xDB09             BLT.N    ??SetEPDblBuf0Count_1
   \   00000018   0x0950             LSRS     R0,R2,#+5
   \   0000001A   0x231F             MOVS     R3,#+31
   \   0000001C   0x421A             TST      R2,R3
   \   0000001E   0xBF08             IT       EQ 
   \   00000020   0x1E40             SUBEQ    R0,R0,#+1
   \   00000022   0x0400             LSLS     R0,R0,#+16
   \   00000024   0x0980             LSRS     R0,R0,#+6
   \   00000026   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   0000002A   0xE005             B.N      ??SetEPDblBuf0Count_2
   \                     ??SetEPDblBuf0Count_1: (+1)
   \   0000002C   0x0850             LSRS     R0,R2,#+1
   \   0000002E   0x07D2             LSLS     R2,R2,#+31
   \   00000030   0xBF48             IT       MI 
   \   00000032   0x1C40             ADDMI    R0,R0,#+1
   \   00000034   0x0400             LSLS     R0,R0,#+16
   \   00000036   0x0980             LSRS     R0,R0,#+6
   \                     ??SetEPDblBuf0Count_2: (+1)
   \   00000038   0x6008             STR      R0,[R1, #+0]
   \   0000003A   0x4770             BX       LR
   \                     ??SetEPDblBuf0Count_0: (+1)
   \   0000003C   0x2902             CMP      R1,#+2
   \   0000003E   0xD107             BNE.N    ??SetEPDblBuf0Count_3
   \   00000040   0x....             LDR.N    R1,??DataTable44_4  ;; 0x40005c50
   \   00000042   0x6809             LDR      R1,[R1, #+0]
   \   00000044   0xB289             UXTH     R1,R1
   \   00000046   0xEB01 0x00C0      ADD      R0,R1,R0, LSL #+3
   \   0000004A   0x....             LDR.N    R1,??DataTable44_7  ;; 0x40006004
   \   0000004C   0xF841 0x2010      STR      R2,[R1, R0, LSL #+1]
    647          }
   \                     ??SetEPDblBuf0Count_3: (+1)
   \   00000050   0x4770             BX       LR               ;; return
    648          /*******************************************************************************
    649          * Function Name  : SetEPDblBuf1Count
    650          * Description    : Set the number of bytes in the buffer 0 of a double Buffer 
    651          *                  endpoint.
    652          * Input          : bEpNum,  bDir,  wCount
    653          * Output         : None.
    654          * Return         : None.
    655          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    656          void SetEPDblBuf1Count(INT8U bEpNum, INT8U bDir, INT16U wCount)
    657          {
    658            _SetEPDblBuf1Count(bEpNum, bDir, wCount);
   \                     SetEPDblBuf1Count: (+1)
   \   00000000   0x2901             CMP      R1,#+1
   \   00000002   0xD11B             BNE.N    ??SetEPDblBuf1Count_0
   \   00000004   0x....             LDR.N    R1,??DataTable44_4  ;; 0x40005c50
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0xB289             UXTH     R1,R1
   \   0000000A   0xEB01 0x00C0      ADD      R0,R1,R0, LSL #+3
   \   0000000E   0x....             LDR.N    R1,??DataTable44_8  ;; 0x4000600c
   \   00000010   0x2A3F             CMP      R2,#+63
   \   00000012   0xEB01 0x0140      ADD      R1,R1,R0, LSL #+1
   \   00000016   0xDB09             BLT.N    ??SetEPDblBuf1Count_1
   \   00000018   0x0950             LSRS     R0,R2,#+5
   \   0000001A   0x231F             MOVS     R3,#+31
   \   0000001C   0x421A             TST      R2,R3
   \   0000001E   0xBF08             IT       EQ 
   \   00000020   0x1E40             SUBEQ    R0,R0,#+1
   \   00000022   0x0400             LSLS     R0,R0,#+16
   \   00000024   0x0980             LSRS     R0,R0,#+6
   \   00000026   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   0000002A   0xE005             B.N      ??SetEPDblBuf1Count_2
   \                     ??SetEPDblBuf1Count_1: (+1)
   \   0000002C   0x0850             LSRS     R0,R2,#+1
   \   0000002E   0x07D2             LSLS     R2,R2,#+31
   \   00000030   0xBF48             IT       MI 
   \   00000032   0x1C40             ADDMI    R0,R0,#+1
   \   00000034   0x0400             LSLS     R0,R0,#+16
   \   00000036   0x0980             LSRS     R0,R0,#+6
   \                     ??SetEPDblBuf1Count_2: (+1)
   \   00000038   0x6008             STR      R0,[R1, #+0]
   \   0000003A   0x4770             BX       LR
   \                     ??SetEPDblBuf1Count_0: (+1)
   \   0000003C   0x2902             CMP      R1,#+2
   \   0000003E   0xD107             BNE.N    ??SetEPDblBuf1Count_3
   \   00000040   0x....             LDR.N    R1,??DataTable44_4  ;; 0x40005c50
   \   00000042   0x6809             LDR      R1,[R1, #+0]
   \   00000044   0xB289             UXTH     R1,R1
   \   00000046   0xEB01 0x00C0      ADD      R0,R1,R0, LSL #+3
   \   0000004A   0x....             LDR.N    R1,??DataTable44_8  ;; 0x4000600c
   \   0000004C   0xF841 0x2010      STR      R2,[R1, R0, LSL #+1]
    659          }
   \                     ??SetEPDblBuf1Count_3: (+1)
   \   00000050   0x4770             BX       LR               ;; return
    660          /*******************************************************************************
    661          * Function Name  : GetEPDblBuf0Count
    662          * Description    : Returns the number of byte received in the buffer 0 of a double
    663          *                  Buffer endpoint.
    664          * Input          : bEpNum: Endpoint Number.
    665          * Output         : None.
    666          * Return         : Endpoint Buffer 0 count
    667          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    668          INT16U GetEPDblBuf0Count(INT8U bEpNum)
   \                     GetEPDblBuf0Count: (+1)
   \   00000000   0xBF00             Nop      
    669          {
    670            return(_GetEPDblBuf0Count(bEpNum));
   \   00000002                      REQUIRE ?Subroutine2
   \   00000002                      ;; // Fall through to label ?Subroutine2
    671          }
    672          /*******************************************************************************
    673          * Function Name  : GetEPDblBuf1Count
    674          * Description    : Returns the number of data received in the buffer 1 of a double
    675          *                  Buffer endpoint.
    676          * Input          : bEpNum: Endpoint Number.
    677          * Output         : None.
    678          * Return         : Endpoint Buffer 1 count.
    679          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    680          INT16U GetEPDblBuf1Count(INT8U bEpNum)
    681          {
    682            return(_GetEPDblBuf1Count(bEpNum));
   \                     GetEPDblBuf1Count: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable44_4  ;; 0x40005c50
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xB289             UXTH     R1,R1
   \   00000006   0xEB01 0x00C0      ADD      R0,R1,R0, LSL #+3
   \   0000000A   0x....             LDR.N    R1,??DataTable44_8  ;; 0x4000600c
   \   0000000C   0x....             B.N      ??Subroutine10_0
    683          }
    684          /*******************************************************************************
    685          * Function Name  : GetEPDblBufDir
    686          * Description    : gets direction of the double buffered endpoint
    687          * Input          : bEpNum: Endpoint Number. 
    688          * Output         : None.
    689          * Return         : EP_DBUF_OUT, EP_DBUF_IN,
    690          *                  EP_DBUF_ERR if the endpoint counter not yet programmed.
    691          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    692          EP_DBUF_DIR GetEPDblBufDir(INT8U bEpNum)
    693          {
    694            if ((INT16U)(*_pEPRxCount(bEpNum) & 0xFC00) != 0)
   \                     GetEPDblBufDir: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable44_4  ;; 0x40005c50
   \   00000002   0x....             LDR.N    R3,??DataTable44_8  ;; 0x4000600c
   \   00000004   0x680A             LDR      R2,[R1, #+0]
   \   00000006   0xB292             UXTH     R2,R2
   \   00000008   0xEB02 0x02C0      ADD      R2,R2,R0, LSL #+3
   \   0000000C   0xF853 0x2012      LDR      R2,[R3, R2, LSL #+1]
   \   00000010   0xF44F 0x437C      MOV      R3,#+64512
   \   00000014   0x421A             TST      R2,R3
   \   00000016   0xD001             BEQ.N    ??GetEPDblBufDir_0
    695              return(EP_DBUF_OUT);
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x4770             BX       LR
    696            else if (((INT16U)(*_pEPTxCount(bEpNum)) & 0x03FF) != 0)
   \                     ??GetEPDblBufDir_0: (+1)
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0xB289             UXTH     R1,R1
   \   00000020   0xEB01 0x00C0      ADD      R0,R1,R0, LSL #+3
   \   00000024   0x....             LDR.N    R1,??DataTable44_7  ;; 0x40006004
   \   00000026   0xF851 0x0010      LDR      R0,[R1, R0, LSL #+1]
   \   0000002A   0x0580             LSLS     R0,R0,#+22
   \   0000002C   0xBF14             ITE      NE 
   \   0000002E   0x2002             MOVNE    R0,#+2
   \   00000030   0x2000             MOVEQ    R0,#+0
    697              return(EP_DBUF_IN);
    698            else
    699              return(EP_DBUF_ERR);
   \   00000032   0x4770             BX       LR
    700          }
    701          /*******************************************************************************
    702          * Function Name  : FreeUserBuffer
    703          * Description    : free buffer used from the application realizing it to the line
    704                             toggles bit SW_BUF in the double buffered endpoint register
    705          * Input          : bEpNum, bDir
    706          * Output         : None.
    707          * Return         : None.
    708          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    709          void FreeUserBuffer(INT8U bEpNum, INT8U bDir)
    710          {
    711            if (bDir == EP_DBUF_OUT)
   \                     FreeUserBuffer: (+1)
   \   00000000   0x2901             CMP      R1,#+1
   \   00000002   0xD10A             BNE.N    ??FreeUserBuffer_0
    712            { /* OUT double buffered endpoint */
    713              _ToggleDTOG_TX(bEpNum);
   \   00000004   0x....             LDR.N    R1,??DataTable44_5  ;; 0x40005c00
   \   00000006   0xF851 0x2020      LDR      R2,[R1, R0, LSL #+2]
   \   0000000A   0xF648 0x738F      MOVW     R3,#+36751
   \   0000000E   0x401A             ANDS     R2,R3,R2
   \   00000010   0xF442 0x4200      ORR      R2,R2,#0x8000
   \   00000014   0xF042 0x02C0      ORR      R2,R2,#0xC0
   \   00000018   0xE00B             B.N      ??FreeUserBuffer_1
    714            }
    715            else if (bDir == EP_DBUF_IN)
   \                     ??FreeUserBuffer_0: (+1)
   \   0000001A   0x2902             CMP      R1,#+2
   \   0000001C   0xD10B             BNE.N    ??FreeUserBuffer_2
    716            { /* IN double buffered endpoint */
    717              _ToggleDTOG_RX(bEpNum);
   \   0000001E   0x....             LDR.N    R1,??DataTable44_5  ;; 0x40005c00
   \   00000020   0xF851 0x2020      LDR      R2,[R1, R0, LSL #+2]
   \   00000024   0xF648 0x738F      MOVW     R3,#+36751
   \   00000028   0x401A             ANDS     R2,R3,R2
   \   0000002A   0xF442 0x4240      ORR      R2,R2,#0xC000
   \   0000002E   0xF042 0x0280      ORR      R2,R2,#0x80
   \                     ??FreeUserBuffer_1: (+1)
   \   00000032   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    718            }
    719          }
   \                     ??FreeUserBuffer_2: (+1)
   \   00000036   0x4770             BX       LR               ;; return
    720          
    721          /*******************************************************************************
    722          * Function Name  : ToWord
    723          * Description    : merge two byte in a word.
    724          * Input          : bh: byte high, bl: bytes low.
    725          * Output         : None.
    726          * Return         : resulted word.
    727          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    728          INT16U ToWord(INT8U bh, INT8U bl)
    729          {
    730            INT16U wRet;
    731            wRet = (INT16U)bl | ((INT16U)bh << 8);
    732            return(wRet);
   \                     ToWord: (+1)
   \   00000000   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   00000004   0x4770             BX       LR               ;; return
    733          }
    734          /*******************************************************************************
    735          * Function Name  : ByteSwap
    736          * Description    : Swap two byte in a word.
    737          * Input          : wSwW: word to Swap.
    738          * Output         : None.
    739          * Return         : resulted word.
    740          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    741          INT16U ByteSwap(INT16U wSwW)
    742          {
    743            INT8U bTemp;
    744            INT16U wRet;
    745            bTemp = (INT8U)(wSwW & 0xff);
    746            wRet =  (wSwW >> 8) | ((INT16U)bTemp << 8);
    747            return(wRet);
   \                     ByteSwap: (+1)
   \   00000000   0x4601             MOV      R1,R0
   \   00000002   0x0600             LSLS     R0,R0,#+24
   \   00000004   0x0C00             LSRS     R0,R0,#+16
   \   00000006   0xEA40 0x2011      ORR      R0,R0,R1, LSR #+8
   \   0000000A   0x4770             BX       LR               ;; return
    748          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44:
   \   00000000   0x40005C40         DC32     0x40005c40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_1:
   \   00000000   0x40005C44         DC32     0x40005c44

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_2:
   \   00000000   0x40005C48         DC32     0x40005c48

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_3:
   \   00000000   0x40005C4C         DC32     0x40005c4c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_4:
   \   00000000   0x40005C50         DC32     0x40005c50

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_5:
   \   00000000   0x40005C00         DC32     0x40005c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_6:
   \   00000000   0x40006008         DC32     0x40006008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_7:
   \   00000000   0x40006004         DC32     0x40006004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_8:
   \   00000000   0x4000600C         DC32     0x4000600c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_9:
   \   00000000   0x40006000         DC32     0x40006000
    749          
    750          #endif /* STM32F10X_CL */
    751          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
    752          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ByteSwap
       0   ClearDTOG_RX
       0   ClearDTOG_TX
       0   ClearEPDoubleBuff
       0   ClearEP_CTR_RX
       0   ClearEP_CTR_TX
       0   ClearEP_KIND
       0   Clear_Status_Out
       0   FreeUserBuffer
       0   GetBTABLE
       0   GetCNTR
       0   GetDADDR
       0   GetENDPOINT
       0   GetEPAddress
       0   GetEPDblBuf0Addr
       0   GetEPDblBuf0Count
       0   GetEPDblBuf1Addr
       0   GetEPDblBuf1Count
       0   GetEPDblBufDir
       0   GetEPRxAddr
       0   GetEPRxCount
       0   GetEPRxStatus
       0   GetEPTxAddr
       0   GetEPTxCount
       0   GetEPTxStatus
       0   GetEPType
       0   GetFNR
       0   GetISTR
       0   GetRxStallStatus
       0   GetTxStallStatus
       0   SetBTABLE
       0   SetCNTR
       0   SetDADDR
       0   SetDouBleBuffEPStall
       0   SetENDPOINT
       0   SetEPAddress
       0   SetEPCountRxReg
       0   SetEPDblBuf0Addr
       0   SetEPDblBuf0Count
       0   SetEPDblBuf1Addr
       0   SetEPDblBuf1Count
       8   SetEPDblBuffAddr
      12   SetEPDblBuffCount
       0   SetEPDoubleBuff
       0   SetEPRxAddr
       0   SetEPRxCount
       0   SetEPRxStatus
       0   SetEPRxValid
       0   SetEPTxAddr
       0   SetEPTxCount
       0   SetEPTxStatus
       0   SetEPTxValid
       0   SetEPType
       0   SetEP_KIND
       0   SetISTR
       0   Set_Status_Out
       0   ToWord
       0   ToggleDTOG_RX
       0   ToggleDTOG_TX


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable44
       4  ??DataTable44_1
       4  ??DataTable44_2
       4  ??DataTable44_3
       4  ??DataTable44_4
       4  ??DataTable44_5
       4  ??DataTable44_6
       4  ??DataTable44_7
       4  ??DataTable44_8
       4  ??DataTable44_9
      10  ??Subroutine10_0
       6  ??Subroutine6_0
      10  ??Subroutine7_0
      10  ??Subroutine8_0
       8  ??Subroutine9_0
      18  ?Subroutine0
      12  ?Subroutine1
      12  ?Subroutine2
      12  ?Subroutine3
       8  ?Subroutine4
       6  ?Subroutine5
      12  ByteSwap
      36  ClearDTOG_RX
      36  ClearDTOG_TX
      20  ClearEPDoubleBuff
      16  ClearEP_CTR_RX
      16  ClearEP_CTR_TX
      20  ClearEP_KIND
      20  Clear_Status_Out
      56  FreeUserBuffer
       6  GetBTABLE
       6  GetCNTR
       6  GetDADDR
      12  GetENDPOINT
      12  GetEPAddress
       2  GetEPDblBuf0Addr
       2  GetEPDblBuf0Count
      14  GetEPDblBuf1Addr
      14  GetEPDblBuf1Count
      52  GetEPDblBufDir
      14  GetEPRxAddr
      14  GetEPRxCount
      14  GetEPRxStatus
       2  GetEPTxAddr
       2  GetEPTxCount
      14  GetEPTxStatus
      14  GetEPType
       6  GetFNR
       4  GetISTR
      24  GetRxStallStatus
      22  GetTxStallStatus
      14  SetBTABLE
       8  SetCNTR
       8  SetDADDR
      34  SetDouBleBuffEPStall
       6  SetENDPOINT
      22  SetEPAddress
      40  SetEPCountRxReg
       2  SetEPDblBuf0Addr
      82  SetEPDblBuf0Count
      14  SetEPDblBuf1Addr
      82  SetEPDblBuf1Count
      44  SetEPDblBuffAddr
     150  SetEPDblBuffCount
       2  SetEPDoubleBuff
      14  SetEPRxAddr
      56  SetEPRxCount
      34  SetEPRxStatus
      24  SetEPRxValid
       2  SetEPTxAddr
      14  SetEPTxCount
      36  SetEPTxStatus
      24  SetEPTxValid
      20  SetEPType
       2  SetEP_KIND
       8  SetISTR
       2  Set_Status_Out
       6  ToWord
      20  ToggleDTOG_RX
      24  ToggleDTOG_TX

 
 1 434 bytes in section .text
 
 1 434 bytes of CODE memory

Errors: none
Warnings: none
