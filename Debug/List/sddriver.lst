###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       09/Feb/2018  16:15:07
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\HW Projects\ControlHome\CntrHome -
#        RF69w\uC-FatFS\device\Mmc\sddriver.c
#    Command line =  
#        "E:\HW Projects\ControlHome\CntrHome -
#        RF69w\uC-FatFS\device\Mmc\sddriver.c" -lCN "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Debug\List" -o "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Debug\Obj" --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\APP\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\BSP\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\CPU\inc\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-CPU\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-RTC\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-LIB\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uCOS-II\Ports\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uCOS-II\Source\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\I2C-Out\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Direct_Sw\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Wdt_led\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-LCD\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-RF\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\api\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\config\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\os\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\fsl\fat\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\clib\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\lbl\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\device\mmc\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\file\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-Terminal\src\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-Terminal\inc\" -Oh
#    List file    =  
#        E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\List\sddriver.lst
#    Object file  =  
#        E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\Obj\sddriver.o
#
###############################################################################

E:\HW Projects\ControlHome\CntrHome - RF69w\uC-FatFS\device\Mmc\sddriver.c
      1          /****************************************Copyright (c)**************************************************
      2          **                               Hangzhou yh software  Co.,LTD.
      3          **                                     
      4          **                                 http://www.armgcc.com
      5          **
      6          **--------------File Info-------------------------------------------------------------------------------
      7          ** File name:			sddriver.c
      8          ** Last modified Date:	2007-10-15
      9          ** Last Version:		V1.0
     10          ** Descriptions:		SD/MMC卡读写模块: 物理层 用户API函数
     11          **						
     12          **------------------------------------------------------------------------------------------------------
     13          ** Created by:			lhlzjut@hotmail.com
     14          ** Created date:		2007-10-15
     15          ** Version:				V1.0
     16          ** Descriptions:		The original version
     17          **
     18          **------------------------------------------------------------------------------------------------------
     19          ********************************************************************************************************/
     20          #include <stdio.h>
     21          
     22          //#include "sdhal.h"
     23          #include "sdcmd.h"
     24          #include "sddriver.h"
     25          
     26          #if SD_UCOSII_EN    
     27          #include  "ucos_ii.h"
     28          #endif
     29          
     30          #if SD_UCOSII_EN

   \                                 In section .bss, align 4
     31          	OS_EVENT *pSemSD = NULL;	/* semaphore that access card */
     32          #endif 
     33          
     34          /* the information structure variable of SD Card */
     35          sd_struct sds;			
   \                     sds:
   \   00000000                      DS8 28
   \                     pSemSD:
   \   0000001C                      DS8 4
     36          
     37          /* (0.000000001ns) timeout unit table */

   \                                 In section .text, align 4, keep-with-next
     38          const INT32U time_unit[8] = {1000000000,100000000,10000000, 1000000,100000,10000,1000,100};
   \                     time_unit:
   \   00000000   0x3B9ACA00         DC32 1000000000, 100000000, 10000000, 1000000, 100000, 10000, 1000, 100
   \              0x05F5E100   
   \              0x00989680   
   \              0x000F4240   
   \              0x000186A0   
   \              0x00002710   
   \              0x000003E8   
   \              0x00000064   
     39          
     40          /* timeout value table */							 

   \                                 In section .text, align 4, keep-with-next
     41          const INT8U time_value[16] = {0,10,12,13,15,20,25,30,35,40,45,50,55,60,70,80};
   \                     time_value:
   \   00000000   0x00 0x0A          DC8 0, 10, 12, 13, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 70, 80
   \              0x0C 0x0D    
   \              0x0F 0x14    
   \              0x19 0x1E    
   \              0x23 0x28    
   \              0x2D 0x32    
   \              0x37 0x3C    
   \              0x46 0x50    
     42           
     43          /* timeout factor table */                              

   \                                 In section .text, align 4, keep-with-next
     44          const INT8U r2w_fator[8] = {1,2,4,8,16,32,64,128};                           
   \                     r2w_fator:
   \   00000000   0x01 0x02          DC8 1, 2, 4, 8, 16, 32, 64, 128
   \              0x04 0x08    
   \              0x10 0x20    
   \              0x40 0x80    
     45           
     46          

   \                                 In section .text, align 2, keep-with-next
     47          void SD_Sleep(INT32U cpt_loop)
     48          {
     49            while (cpt_loop -- != 0);
     50          }   
   \                     SD_Sleep: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     51          	/*       
     52          	***************************************************************************************************
     53          		
     54          	     User API Function: Initialize,read,write,erase SD Card 
     55          				
     56          	***************************************************************************************************
     57          	*/
     58          				
     59          /*******************************************************************************************************************
     60          ** Name:	  INT8U SD_Initialize()
     61          ** Function: initialize SD/MMC card
     62          ** Input:	  NULL
     63          ** Output:	  0:  right			>0:  error code
     64          ********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     65          INT8U SD_Initialize(void)
     66          {
   \                     SD_Initialize: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
     67          	INT8U recbuf[4],ret;
     68          	
     69          #if SD_UCOSII_EN
     70          	if (pSemSD == NULL)
   \   00000002   0x....             LDR.N    R4,??DataTable11
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x69E0             LDR      R0,[R4, #+28]
   \   00000008   0xB938             CBNZ.N   R0,??SD_Initialize_0
     71          	{
     72              	pSemSD = OSSemCreate(1);					/* create SD/MMC semaphore */ 
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x.... 0x....      BL       OSSemCreate
   \   00000010   0x61E0             STR      R0,[R4, #+28]
     73          		if (pSemSD == NULL)					
   \   00000012   0xB910             CBNZ.N   R0,??SD_Initialize_0
     74          		 	return SD_ERR_CREATE_SEMSD;
   \   00000014   0x20A0             MOVS     R0,#+160
   \   00000016   0xB003             ADD      SP,SP,#+12
   \   00000018   0xBD30             POP      {R4,R5,PC}
     75          	}				    
     76          #endif	
     77             
     78              SD_StartSD();
   \                     ??SD_Initialize_0: (+1)
   \   0000001A   0x69E0             LDR      R0,[R4, #+28]
   \   0000001C   0xAA01             ADD      R2,SP,#+4
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x.... 0x....      BL       OSSemPend
     79          //    SD_HardWareInit();					    		/* Initialize the hardware that access SD Card */
     80              
     81          //    if (SD_ChkCard() != 1)						/* check weather card is inserted */
     82          //    {	
     83          //    	ret = SD_ERR_NO_CARD;   
     84          //    	goto SD_ERR;
     85          //    }
     86                  
     87              MSD_CS_Assert();							/* 1. assert CS */  
   \   00000024   0x.... 0x....      BL       MSD_CS_Assert
     88          	
     89              SD_SPIDelay(200);   						/* 2. clock delay more than 74 clock */
   \   00000028   0x20C8             MOVS     R0,#+200
   \   0000002A   0x.... 0x....      BL       SD_SPIDelay
     90              
     91              MSD_CS_Deassert();  						/* 3. dessert CS */
   \   0000002E   0x.... 0x....      BL       MSD_CS_Deassert
     92              SD_SPIDelay(4);							/* 4. delay 2(8 clock) */
   \   00000032   0x2004             MOVS     R0,#+4
   \   00000034   0x.... 0x....      BL       SD_SPIDelay
     93               
     94              SD_Sleep(1000000);
     95              
     96              ret = SD_ResetSD();							/* 5. send CMD0 command to reset sd card */
   \   00000038   0x.... 0x....      BL       SD_ResetSD
   \   0000003C   0x0005             MOVS     R5,R0
     97             	
     98              if (ret != SD_NO_ERR)
   \   0000003E   0xD110             BNE.N    ??SD_Initialize_1
     99                  goto SD_ERR;									
    100           	
    101              ret = SD_ActiveInit();						/* 6. active card initialize process */
   \   00000040   0x.... 0x....      BL       SD_ActiveInit
   \   00000044   0x0005             MOVS     R5,R0
    102              if (ret != SD_NO_ERR)
   \   00000046   0xD10C             BNE.N    ??SD_Initialize_1
    103           	goto SD_ERR;
    104              
    105              ret = SD_ReadOCR(4, recbuf);  					/* 7. read OCR register,get the supported voltage */
   \   00000048   0x4669             MOV      R1,SP
   \   0000004A   0x2004             MOVS     R0,#+4
   \   0000004C   0x.... 0x....      BL       SD_ReadOCR
   \   00000050   0x0005             MOVS     R5,R0
    106              if (ret != SD_NO_ERR)
   \   00000052   0xD106             BNE.N    ??SD_Initialize_1
    107                  goto SD_ERR;
    108              
    109              if ((recbuf[1] & MSK_OCR_33) != MSK_OCR_33)
   \   00000054   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000058   0xF000 0x0030      AND      R0,R0,#0x30
   \   0000005C   0x2830             CMP      R0,#+48
   \   0000005E   0xD006             BEQ.N    ??SD_Initialize_2
    110              { 	 
    111                  ret = SD_ERR_VOL_NOTSUSP;					/* not support 3.3V,return error code */
   \   00000060   0x2504             MOVS     R5,#+4
    112              	goto SD_ERR;
    113              }
    114                    
    115          #if SD_CRC_EN        
    116              ret = SD_EnableCRC(1);						/* enable CRC check */
    117          	if (ret != SD_NO_ERR)  
    118          	  	goto SD_ERR;
    119          #endif
    120          
    121              ret = SD_SetBlockLen(SD_BLOCKSIZE);				        /* 8. Set the block length: 512Bytes */
    122              if (ret != SD_NO_ERR)  
    123                  goto SD_ERR;
    124                  
    125              ret = SD_GetCardInfo();						/* 9. read CSD register, get the information of SD card */    
    126          	if (ret != SD_NO_ERR)
    127          		goto SD_ERR;
    128          
    129          	SD_EndSD();	
    130          
    131          //	SPI_ClkToMax();							/* 10. set SPI clock to maximum */		
    132          
    133          	return SD_NO_ERR;						/* initialize sucessfully */
    134          
    135          SD_ERR:	
    136          	SD_EndSD();	
   \                     ??SD_Initialize_1: (+1)
   \   00000062   0x69E0             LDR      R0,[R4, #+28]
   \   00000064   0x.... 0x....      BL       OSSemPost
    137          	return ret;
   \   00000068   0x4628             MOV      R0,R5
   \   0000006A   0xB003             ADD      SP,SP,#+12
   \   0000006C   0xBD30             POP      {R4,R5,PC}       ;; return
   \                     ??SD_Initialize_2: (+1)
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0x.... 0x....      BL       SD_EnableCRC
   \   00000074   0x0005             MOVS     R5,R0
   \   00000076   0xD1F4             BNE.N    ??SD_Initialize_1
   \   00000078   0xF44F 0x7000      MOV      R0,#+512
   \   0000007C   0x.... 0x....      BL       SD_SetBlockLen
   \   00000080   0x0005             MOVS     R5,R0
   \   00000082   0xD1EE             BNE.N    ??SD_Initialize_1
   \   00000084   0x.... 0x....      BL       SD_GetCardInfo
   \   00000088   0x0005             MOVS     R5,R0
   \   0000008A   0xD1EA             BNE.N    ??SD_Initialize_1
   \   0000008C   0x69E0             LDR      R0,[R4, #+28]
   \   0000008E   0x.... 0x....      BL       OSSemPost
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xB003             ADD      SP,SP,#+12
   \   00000096   0xBD30             POP      {R4,R5,PC}
    138          }
    139          
    140          /********************************************************************************************************************
    141          ** Name:	  INT8U SD_ReadBlock()
    142          ** Function:      read a single block from SD/MMC card
    143          ** Input:         INT32U blockaddr: address of block
    144          **   	          INT8U *recbuf   : the buffer of receive,length is 512Bytes
    145          ** Output:	  0:  right			>0:  error code
    146          *********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    147          INT8U SD_ReadBlock(INT32U blockaddr,INT32U len, INT8U *recbuf)
    148          {
   \                     SD_ReadBlock: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    149          	INT8U ret; 
    150          	
    151          	SD_StartSD();							/* request semaphore acessed SD/MMC to OS */
   \   00000002   0x....             LDR.N    R7,??DataTable11
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x69F8             LDR      R0,[R7, #+28]
   \   0000000C   0x466A             MOV      R2,SP
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x.... 0x....      BL       OSSemPend
    152           
    153          //        if (SD_ChkCard() != 1)							
    154          //        {
    155          //                SD_EndSD();	
    156          //                return SD_ERR_NO_CARD;   					/* card is not inserted entirely */
    157          //	}
    158          		
    159          	if (blockaddr > sds.block_num)	
   \   00000014   0x6878             LDR      R0,[R7, #+4]
   \   00000016   0x42A0             CMP      R0,R4
   \   00000018   0xD200             BCS.N    ??SD_ReadBlock_0
    160          	{
    161          		SD_EndSD();	
   \   0000001A   0x....             B.N      ?Subroutine1
    162          		return SD_ERR_OVER_CARDRANGE;				/* operate over the card range */
    163          	}
    164          	
    165           	ret = SD_ReadSingleBlock(blockaddr);			        /* read single blocks command */						
   \                     ??SD_ReadBlock_0: (+1)
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       SD_ReadSingleBlock
   \   00000022   0x0004             MOVS     R4,R0
    166           	if (ret != SD_NO_ERR)
   \   00000024   0xD104             BNE.N    ??SD_ReadBlock_1
    167           	{
    168           		SD_EndSD();									
    169           		return ret;
    170           	}
    171           	
    172            	ret = SD_ReadBlockData(len, recbuf);			        /* read data from sd card */	
   \   00000026   0x4631             MOV      R1,R6
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0x.... 0x....      BL       SD_ReadBlockData
   \   0000002E   0x4604             MOV      R4,R0
    173          	SD_EndSD();							/* return semaphore acessed SD/MMC to OS */
   \                     ??SD_ReadBlock_1: (+1)
   \   00000030   0x....             B.N      ?Subroutine0
    174          	
    175          	return ret;
    176          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x69F8             LDR      R0,[R7, #+28]
   \   00000002   0x.... 0x....      BL       OSSemPost
   \   00000006   0x2005             MOVS     R0,#+5
   \   00000008   0xBDF2             POP      {R1,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x69F8             LDR      R0,[R7, #+28]
   \   00000002   0x.... 0x....      BL       OSSemPost
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    177          
    178          /********************************************************************************************************************
    179          ** Name:	  INT8U SD_ReadMultiBlock()
    180          ** Function: read multi blocks from SD/MMC card
    181          ** Input:	  INT32U blockaddr: address of block
    182          **		  INT32U blocknum : the numbers of block
    183          **		  INT8U *recbuf   : the buffer of receive,each block length is 512Bytes
    184          ** Output:	  0:  right			>0:  error code
    185          *********************************************************************************************************************/
    186          #if SD_ReadMultiBlock_EN
    187          INT8U SD_ReadMultiBlock(INT32U blockaddr, INT32U blocknum, INT8U *recbuf)
    188          {
    189              INT32U i;
    190              INT8U ret;
    191                 
    192          	SD_StartSD();							/* request semaphore acessed SD/MMC to OS */
    193              if (SD_ChkCard() != 1)							
    194              {
    195              	SD_EndSD();	
    196              	return SD_ERR_NO_CARD;   					/* card is not inserted entirely */
    197          	}
    198          		
    199          	if ((blockaddr + blocknum) > sds.block_num)	
    200          	{
    201          		SD_EndSD();	
    202          		return SD_ERR_OVER_CARDRANGE;				/* operate over the card range */
    203          	}       
    204              
    205          	ret = SD_ReadMultipleBlock(blockaddr);			        /* read multiple blocks command */
    206          	if (ret != SD_NO_ERR)
    207          	{	
    208          		SD_EndSD();						/* return semaphore acessed SD/MMC to OS */						
    209          		return ret;
    210              }
    211              
    212              for (i = 0; i < blocknum; i++)
    213              {									/* read data from SD/MMC card */
    214              	ret = SD_ReadBlockData(SD_BLOCKSIZE, recbuf);
    215              	if (ret == SD_NO_ERR)
    216                 		recbuf = recbuf + SD_BLOCKSIZE;
    217              	else
    218              	{
    219              		SD_EndSD();
    220              		return ret;
    221              	}
    222              }
    223           	 
    224           	ret = SD_StopTransmission();				        /* stop transmission operation */ 
    225           	
    226           	SD_EndSD();
    227          	return ret; 
    228          }
    229          
    230          #endif
    231          
    232          /********************************************************************************************************************
    233          ** Name:	  INT8U SD_WriteBlock()
    234          ** Function: write a block to SD/MMC card
    235          ** Input: 	  INT32U blockaddr: address of block
    236          **	  	  INT8U *sendbuf  : the buffer of send,length is 512Bytes
    237          ** Output:	  0:  right			>0:  error code
    238          *********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    239          INT8U SD_WriteBlock(INT32U blockaddr, INT32U len, INT8U *sendbuf)
    240          {
   \                     SD_WriteBlock: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    241          	INT8U ret,tmp[2];
    242          	
    243          	SD_StartSD();							/* request semaphore acessed SD/MMC to OS */
   \   00000002   0x....             LDR.N    R7,??DataTable11
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x69F8             LDR      R0,[R7, #+28]
   \   0000000C   0xF10D 0x0202      ADD      R2,SP,#+2
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x.... 0x....      BL       OSSemPend
    244          
    245          //        if (SD_ChkCard() != 1)							
    246          //        {
    247          //                SD_EndSD();	
    248          //                return SD_ERR_NO_CARD;   					/* card is not inserted entirely */
    249          //	}	
    250          	
    251          	if (blockaddr > sds.block_num)	
   \   00000016   0x6878             LDR      R0,[R7, #+4]
   \   00000018   0x42A0             CMP      R0,R4
   \   0000001A   0xD200             BCS.N    ??SD_WriteBlock_0
    252          	{
    253          		SD_EndSD();	
   \   0000001C   0x....             B.N      ?Subroutine1
    254          		return SD_ERR_OVER_CARDRANGE;				/* operate over the card range */
    255          	}
    256          /*	
    257          	if (SD_ChkCardWP() == 1)
    258          	{
    259          		SD_EndSD();
    260          		return SD_ERR_WRITE_PROTECT;							
    261          	}
    262          */	
    263          	ret = SD_WriteSingleBlock(blockaddr);				/* write single block */
   \                     ??SD_WriteBlock_0: (+1)
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       SD_WriteSingleBlock
   \   00000024   0x0004             MOVS     R4,R0
    264          	if (ret != SD_NO_ERR)
   \   00000026   0xD118             BNE.N    ??SD_WriteBlock_1
    265          	{	
    266          		SD_EndSD();
    267          		return ret;
    268          	}
    269          	
    270          	ret = SD_WriteBlockData(0, len, sendbuf);			/* write data */
   \   00000028   0x4632             MOV      R2,R6
   \   0000002A   0x4629             MOV      R1,R5
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x.... 0x....      BL       SD_WriteBlockData
   \   00000032   0x0004             MOVS     R4,R0
    271           	
    272          	if (ret == SD_NO_ERR)						
   \   00000034   0xD111             BNE.N    ??SD_WriteBlock_1
    273           	{								/* read Card Status register to check write wheather sucessfully */
    274           		ret = SD_ReadCard_Status(2, tmp);
   \   00000036   0x4669             MOV      R1,SP
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0x.... 0x....      BL       SD_ReadCard_Status
   \   0000003E   0x0004             MOVS     R4,R0
    275           		if (ret != SD_NO_ERR)
   \   00000040   0xD10B             BNE.N    ??SD_WriteBlock_1
    276           		{
    277           			SD_EndSD();
    278           			return ret;					/* read register fail */
    279          		}
    280          
    281           		if((tmp[0] != 0) || (tmp[1] != 0))
   \   00000042   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xBF04             ITT      EQ 
   \   0000004A   0xF89D 0x0001      LDRBEQ   R0,[SP, #+1]
   \   0000004E   0x2800             CMPEQ    R0,#+0
   \   00000050   0xD003             BEQ.N    ??SD_WriteBlock_1
    282           		{
    283           			SD_EndSD();
   \   00000052   0x69F8             LDR      R0,[R7, #+28]
   \   00000054   0x.... 0x....      BL       OSSemPost
    284          			ret = SD_ERR_WRITE_BLK; 			/* response indicate write fail */
   \   00000058   0x2440             MOVS     R4,#+64
    285           		}
    286           	}
    287            
    288               SD_EndSD();
   \                     ??SD_WriteBlock_1: (+1)
   \   0000005A   0x....             B.N      ?Subroutine0
    289               return ret;							/* return the result of writing */									
    290          }
    291          
    292          /**********************************************************************************************************************
    293          ** Name:	  INT8U SD_WriteMultiBlock()
    294          ** Function: write multi blocks to SD/MMC card
    295          ** Input:	  INT32U blockaddr: address of block
    296          **      	  INT32U blocknum : the numbers of block
    297          **	          INT8U *sendbuf  : the send buffer,each block length is 512Bytes
    298          ** Output:	  0:  right			>0:  error code
    299          ***********************************************************************************************************************/
    300          #if SD_WriteMultiBlock_EN
    301          INT8U SD_WriteMultiBlock(INT32U blockaddr, INT32U blocknum, INT8U *sendbuf)
    302          {
    303          	INT32U i;
    304          	INT8U ret,tmp[2];
    305          	
    306          	SD_StartSD();						/* request semaphore acessed SD/MMC to OS */
    307              if (SD_ChkCard() != 1)							
    308              {
    309              	SD_EndSD();	
    310              	return SD_ERR_NO_CARD;   				/* card is not inserted entirely */
    311          	}
    312          		
    313          	if ((blockaddr + blocknum) > sds.block_num)	
    314          	{
    315          		SD_EndSD();	
    316          		return SD_ERR_OVER_CARDRANGE;			/* operate over the card range */
    317          	}
    318          		
    319          	if (SD_ChkCardWP() == 1)
    320          	{
    321          		SD_EndSD();
    322          		return SD_ERR_WRITE_PROTECT;				
    323          	}
    324          	
    325          	ret = SD_WriteMultipleBlock(blockaddr);			/* write multiple blocks command */
    326          	if (ret != SD_NO_ERR)
    327          	{
    328          		SD_EndSD();
    329          		return ret;
    330          	}
    331          	
    332              for (i = 0; i < blocknum; i++)
    333              {															
    334           		ret = SD_WriteBlockData(1, SD_BLOCKSIZE, sendbuf);	/* write data */
    335           		if (ret == SD_NO_ERR)	
    336           			sendbuf = sendbuf + SD_BLOCKSIZE;
    337           		else
    338           		{						        /* write fail */
    339          			SD_StopTransmission();				/* stop data transmission */	
    340          			SD_WaitBusy(SD_WAIT_WRITE);			/* waiting */
    341          			SD_EndSD();
    342          			return ret;
    343          		}
    344          	}
    345             
    346              SD_StopMultiToken();					/* send data stop token */
    347                
    348              ret = SD_WaitBusy(SD_WAIT_WRITE);				/* wait for finishing writing */
    349              if (ret != SD_NO_ERR)
    350              {
    351              	SD_EndSD();
    352              	return SD_ERR_TIMEOUT_WRITE;
    353              }
    354              
    355              if (sds.card_type == CARDTYPE_SD)
    356              {
    357             		ret = SD_GetNumWRBlcoks(&i);			/* read the blocks that be written correctly */
    358             		if (ret != SD_NO_ERR)
    359             		{
    360             			SD_EndSD();
    361             		  	return ret;
    362             		}
    363             		if(i != blocknum)
    364          			ret =  SD_ERR_WRITE_BLKNUMS;		/* the blocks that be written correctly is error */
    365             	}
    366             	else
    367             	{
    368             	 	ret = SD_ReadCard_Status(2, tmp);
    369           		if (ret != SD_NO_ERR)
    370           		{
    371           			SD_EndSD();
    372           			return ret;				/* read register fail */
    373          		}
    374           		if((tmp[0] != 0) || (tmp[1] != 0))
    375          			ret = SD_ERR_WRITE_BLK; 		/* response indicate write fail */
    376             	}
    377             	 	
    378             	SD_EndSD();   	     
    379          	return ret;						/* return write sucessfully */			
    380          }
    381          #endif
    382          
    383          /*********************************************************************************************************************
    384          ** Name:	  INT8U SD_EraseBlock()
    385          ** Function: Erase the block of SD/MMC card
    386          ** Input:         INT32U startaddr: start address
    387          **		  INT32U endaddr  : end address
    388          ** Output:	  0:  right			>0:  error code
    389          ** sds.erase_unit 
    390          *********************************************************************************************************************/
    391          #if SD_EraseBlock_EN
    392          INT8U SD_EraseBlock(INT32U startaddr, INT32U blocknum)
    393          {
    394          	INT32 tmp;
    395          	INT8U ret;
    396          	
    397          	SD_StartSD();									/* request semaphore acessed SD/MMC to OS */
    398              if (SD_ChkCard() != 1)							
    399              {
    400              	SD_EndSD();	
    401              	return SD_ERR_NO_CARD;   							/* card is not inserted entirely */
    402          	}
    403          	
    404          	if ((startaddr + blocknum) > sds.block_num)	
    405          	{
    406          		SD_EndSD();	
    407          		return SD_ERR_OVER_CARDRANGE;						/* operate over the card range */
    408          	}
    409          		
    410          	if (SD_ChkCardWP() == 1)
    411          	{
    412          		SD_EndSD();
    413          		return SD_ERR_WRITE_PROTECT;							
    414          	}	
    415          
    416          	tmp = blocknum - sds.erase_unit;	
    417          	while(tmp >= 0) 								/* once erase is sector size */
    418          	{	
    419          		ret = SD_EraseStartBlock(startaddr);					/* select start address */
    420          		if (ret != SD_NO_ERR)
    421          		{
    422          			SD_EndSD();
    423          			return ret;
    424          		}
    425          		
    426          		ret = SD_EraseEndBlock(startaddr + sds.erase_unit - 1);		        /* select end address */
    427          		if (ret != SD_NO_ERR)
    428          		{
    429          			SD_EndSD();
    430          			return ret;
    431          		}
    432          			
    433          		ret = SD_EraseSelectedBlock();						/* erase blocks selected */
    434          		if (ret != SD_NO_ERR)
    435          		{
    436          			SD_EndSD();
    437          			return ret;
    438          		}
    439          
    440          		startaddr += sds.erase_unit;							
    441          		blocknum  -= sds.erase_unit;
    442          		tmp = blocknum - sds.erase_unit;
    443          	};		
    444          	
    445          	if (blocknum > 0)									
    446          	{										/* erase blocks that numbers is not enough once_erase */
    447          		ret = SD_EraseStartBlock(startaddr);
    448          		if (ret != SD_NO_ERR)
    449          		{
    450          			SD_EndSD();
    451          			return ret;
    452          		}
    453          		
    454          		ret = SD_EraseEndBlock(startaddr + blocknum - 1);
    455          		if (ret != SD_NO_ERR)
    456          		{
    457          			SD_EndSD();
    458          			return ret;
    459          		}
    460          			
    461          		ret = SD_EraseSelectedBlock();
    462          		if (ret != SD_NO_ERR)
    463          		{
    464          			SD_EndSD();
    465          			return ret;
    466          		}
    467          	}
    468          
    469          	SD_EndSD();
    470          	return SD_NO_ERR;								/* return erase sucessfully */
    471          }
    472          #endif
    473          
    474          
    475          /*******************************************************************************************************************
    476          ** Name:	  INT8U SD_GetCardInfo()
    477          ** Function: get the information of SD/MMC card
    478          ** Input:    INT8U cardtype: card type	
    479          ** Output:	  0:  right			>0:  error code
    480          *******************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    481          INT8U SD_GetCardInfo()
    482          {
   \                     SD_GetCardInfo: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    483          	INT32U tmp;
    484          	INT8U csdbuf[16],ret;
    485          
    486          	ret = SD_ReadCSD(16, csdbuf);	 						/* read CSD register */
   \   00000004   0x4669             MOV      R1,SP
   \   00000006   0x2010             MOVS     R0,#+16
   \   00000008   0x.... 0x....      BL       SD_ReadCSD
    487          	if (ret != SD_NO_ERR)	
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD13F             BNE.N    ??SD_GetCardInfo_0
    488          		return ret;	
    489          		
    490          	SD_CalTimeout(csdbuf);								/* calculate timeout value */
   \   00000010   0x4668             MOV      R0,SP
   \   00000012   0x.... 0x....      BL       SD_CalTimeout
    491          		
    492          	                          							/* calculate the size of a sector */
    493          	sds.block_len = 1 << (csdbuf[READ_BL_LEN_POS] & READ_BL_LEN_MSK);  		/* (2 ^ READ_BL_LEN) */
   \   00000016   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   0000001A   0x....             LDR.N    R1,??DataTable11
   \   0000001C   0x2301             MOVS     R3,#+1
   \   0000001E   0xF000 0x000F      AND      R0,R0,#0xF
   \   00000022   0xFA03 0xF000      LSL      R0,R3,R0
   \   00000026   0x6088             STR      R0,[R1, #+8]
    494          	
    495          	                								/* calculate the sector numbers of the SD Card */
    496          	sds.block_num = ((csdbuf[C_SIZE_POS1] & C_SIZE_MSK1) << 10) +
    497          	      			 (csdbuf[C_SIZE_POS2] << 2) +
    498          	 	 			((csdbuf[C_SIZE_POS3] & C_SIZE_MSK3) >> 6) + 1;	/* (C_SIZE + 1)*/
    499          		 	  															
    500          	tmp = ((csdbuf[C_SIZE_MULT_POS1] & C_SIZE_MULT_MSK1) << 1) +   
    501          	      ((csdbuf[C_SIZE_MULT_POS2] & C_SIZE_MULT_MSK2) >> 7) + 2;			/* (C_SIZE_MULT + 2) */
    502              	
    503                                   								/* get the block numbers in card */
    504          	sds.block_num = sds.block_num * (1 << tmp);					/* (C_SIZE + 1) * 2 ^ (C_SIZE_MULT + 2) */
   \   00000028   0xF89D 0x5007      LDRB     R5,[SP, #+7]
   \   0000002C   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   00000030   0xF000 0x0003      AND      R0,R0,#0x3
   \   00000034   0x00AD             LSLS     R5,R5,#+2
   \   00000036   0xEB05 0x2080      ADD      R0,R5,R0, LSL #+10
   \   0000003A   0xF89D 0x5008      LDRB     R5,[SP, #+8]
   \   0000003E   0xF89D 0x400A      LDRB     R4,[SP, #+10]
    505          																			
    506          	
    507          	if (sds.card_type == CARDTYPE_MMC)
   \   00000042   0xF89D 0x200B      LDRB     R2,[SP, #+11]
   \   00000046   0xEB00 0x1095      ADD      R0,R0,R5, LSR #+6
   \   0000004A   0x1C45             ADDS     R5,R0,#+1
   \   0000004C   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   00000050   0xF000 0x0603      AND      R6,R0,#0x3
   \   00000054   0x09E0             LSRS     R0,R4,#+7
   \   00000056   0xEB00 0x0046      ADD      R0,R0,R6, LSL #+1
   \   0000005A   0x1C80             ADDS     R0,R0,#+2
   \   0000005C   0xFA03 0xF000      LSL      R0,R3,R0
   \   00000060   0x780B             LDRB     R3,[R1, #+0]
   \   00000062   0x4368             MULS     R0,R0,R5
   \   00000064   0x2B01             CMP      R3,#+1
   \   00000066   0x6048             STR      R0,[R1, #+4]
   \   00000068   0xD10A             BNE.N    ??SD_GetCardInfo_1
    508          	{					    
    509          		tmp  = ((csdbuf[ERASE_GRP_SIZE_POS] & ERASE_GRP_SIZE_MSK) >> 2) + 1;  	/* (ERASE_GRP_SIZE + 1)  */ 
    510          		
    511          		/* (ERASE_GRP_SIZE + 1) * (ERASE_GRP_MULTI + 1) */
    512          		tmp *= ((csdbuf[ERASE_GRP_MULTI_POS1] & ERASE_GRP_MULTI_MSK1) << 3) +
    513          		       ((csdbuf[ERASE_GRP_MULTI_POS2] & ERASE_GRP_MULTI_MSK2) >> 5) + 1;	
   \   0000006A   0xF004 0x0003      AND      R0,R4,#0x3
   \   0000006E   0x0952             LSRS     R2,R2,#+5
   \   00000070   0xF3C4 0x0384      UBFX     R3,R4,#+2,#+5
   \   00000074   0xEB02 0x00C0      ADD      R0,R2,R0, LSL #+3
   \   00000078   0x1C5B             ADDS     R3,R3,#+1
   \   0000007A   0x1C40             ADDS     R0,R0,#+1
   \   0000007C   0x4358             MULS     R0,R0,R3
   \   0000007E   0xE005             B.N      ??SD_GetCardInfo_2
    514          	}
    515          	else																		/*calculate the size of sector */
    516          		tmp = ((csdbuf[SECTOR_SIZE_POS1] & SECTOR_SIZE_MSK1) << 1) +  			
    517          	          ((csdbuf[SECTOR_SIZE_POS2] & SECTOR_SIZE_MSK2) >> 7) + 1;		/* SD: SECTOR_SIZE */
   \                     ??SD_GetCardInfo_1: (+1)
   \   00000080   0xF004 0x003F      AND      R0,R4,#0x3F
   \   00000084   0x09D2             LSRS     R2,R2,#+7
   \   00000086   0xEB02 0x0040      ADD      R0,R2,R0, LSL #+1
   \   0000008A   0x1C40             ADDS     R0,R0,#+1
    518          	
    519          	sds.erase_unit = tmp;	    							 
   \                     ??SD_GetCardInfo_2: (+1)
   \   0000008C   0x60C8             STR      R0,[R1, #+12]
    520          	
    521          	return SD_NO_ERR;															/* 返回执行成功 return perform sucessfully */
   \   0000008E   0x2000             MOVS     R0,#+0
   \                     ??SD_GetCardInfo_0: (+1)
   \   00000090   0xB004             ADD      SP,SP,#+16
   \   00000092   0xBD70             POP      {R4-R6,PC}       ;; return
    522          }
    523          
    524          
    525          /*******************************************************************************************************************
    526          ** Name:	  INT8U SD_CalTimeout()
    527          ** Function: calculate timeout of reading,writing,erasing
    528          ** Input: 	  INT8U *csdbuf : CSD register content
    529          ** Output:	  0:  right			>0:  error code
    530          *******************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    531          INT8U SD_CalTimeout(INT8U *csdbuf)
    532          {
   \                     SD_CalTimeout: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    533          	INT32U tmp;
    534          	INT8U time_u,time_v,fator;
    535          	
    536          	sds.timeout_read = READ_TIMEOUT_100MS;					/* 100ms */
   \   00000002   0x....             LDR.N    R1,??DataTable11
   \   00000004   0x....             LDR.N    R2,??DataTable11_1  ;; 0x36ee8
    537          	sds.timeout_write = WRITE_TIMEOUT_250MS;				/* 250ms */
   \   00000006   0x....             LDR.N    R3,??DataTable11_2  ;; 0x89544
   \   00000008   0x610A             STR      R2,[R1, #+16]
   \   0000000A   0x614B             STR      R3,[R1, #+20]
    538          	sds.timeout_erase = WRITE_TIMEOUT_250MS;
   \   0000000C   0x618B             STR      R3,[R1, #+24]
    539          		
    540          	time_u = (csdbuf[TAAC_POS] & TAAC_MSK);					/* read timeout unit */
    541          	time_v = (csdbuf[TAAC_POS] & NSAC_MSK) >> 3;				/* read timeout value */
   \   0000000E   0x7845             LDRB     R5,[R0, #+1]
    542          	fator = (csdbuf[R2WFACTOR_POS] & R2WFACTOR_MSK) >> 2;			/* read timeout factor */
   \   00000010   0x7B04             LDRB     R4,[R0, #+12]
   \   00000012   0xF3C5 0x07C3      UBFX     R7,R5,#+3,#+4
   \   00000016   0xF3C4 0x0682      UBFX     R6,R4,#+2,#+3
    543          	
    544          	if(time_v == 0)	return SD_ERR_CARD_PARAM;				/* card parameter is error */
   \   0000001A   0xB917             CBNZ.N   R7,??SD_CalTimeout_0
   \   0000001C   0xBCF0             POP      {R4-R7}
   \   0000001E   0x2003             MOVS     R0,#+3
   \   00000020   0x4770             BX       LR
    545          	
    546          	tmp = SPI_CLOCK * time_value[time_v] / 10 / time_unit[time_u];		/* TACC * f (unit: clock) */
    547          	tmp = tmp + csdbuf[NSAC_POS] * 100;					/* TACC * f + NSAC * 100 (unit: clock) */
    548          	
    549          	/* the timeout value of being calculated */
    550          	sds.timeout_read = tmp;
   \                     ??SD_CalTimeout_0: (+1)
   \   00000022   0x.... 0x....      ADR.W    R12,time_value
   \   00000026   0x7880             LDRB     R0,[R0, #+2]
   \   00000028   0xF817 0x700C      LDRB     R7,[R7, R12]
   \   0000002C   0x.... 0x....      LDR.W    R12,??DataTable11_3  ;; 0x112a880
   \   00000030   0xFB0C 0xF707      MUL      R7,R12,R7
   \   00000034   0xF04F 0x0C0A      MOV      R12,#+10
   \   00000038   0xFB97 0xF7FC      SDIV     R7,R7,R12
   \   0000003C   0x.... 0x....      ADR.W    R12,time_unit
   \   00000040   0xF005 0x0507      AND      R5,R5,#0x7
   \   00000044   0xF85C 0x5025      LDR      R5,[R12, R5, LSL #+2]
   \   00000048   0x2464             MOVS     R4,#+100
   \   0000004A   0xFBB7 0xF5F5      UDIV     R5,R7,R5
   \   0000004E   0xFB04 0x5000      MLA      R0,R4,R0,R5
    551          	sds.timeout_write = tmp * r2w_fator[fator];				/* (TACC * f + NSAC * 100) * R2WFACTOR (unit:clock)*/
   \   00000052   0x.... 0x....      ADR.W    R5,r2w_fator
   \   00000056   0x6108             STR      R0,[R1, #+16]
   \   00000058   0x5D75             LDRB     R5,[R6, R5]
    552          	
    553          	if (sds.card_type == CARDTYPE_SD)
   \   0000005A   0x780E             LDRB     R6,[R1, #+0]
   \   0000005C   0x4345             MULS     R5,R5,R0
   \   0000005E   0x614D             STR      R5,[R1, #+20]
   \   00000060   0xB976             CBNZ.N   R6,??SD_CalTimeout_1
    554          	{
    555          		sds.timeout_read  = sds.timeout_read * 100 / 8;					
   \   00000062   0x4360             MULS     R0,R4,R0
    556          		sds.timeout_write = sds.timeout_write * 100 / 8;
   \   00000064   0x436C             MULS     R4,R4,R5
   \   00000066   0x08C0             LSRS     R0,R0,#+3
   \   00000068   0x08E4             LSRS     R4,R4,#+3
    557          		if (sds.timeout_read > READ_TIMEOUT_100MS)					
   \   0000006A   0x....             LDR.N    R5,??DataTable11_4  ;; 0x36ee9
   \   0000006C   0x6108             STR      R0,[R1, #+16]
   \   0000006E   0x614C             STR      R4,[R1, #+20]
   \   00000070   0x42A8             CMP      R0,R5
   \   00000072   0xBF28             IT       CS 
   \   00000074   0x610A             STRCS    R2,[R1, #+16]
    558          			sds.timeout_read = READ_TIMEOUT_100MS;
    559          		
    560          		if (sds.timeout_write > WRITE_TIMEOUT_250MS)
   \   00000076   0x....             LDR.N    R0,??DataTable11_5  ;; 0x89545
   \   00000078   0x4284             CMP      R4,R0
   \   0000007A   0xD30B             BCC.N    ??SD_CalTimeout_2
    561          			sds.timeout_write = WRITE_TIMEOUT_250MS;
   \   0000007C   0x614B             STR      R3,[R1, #+20]
   \   0000007E   0xE009             B.N      ??SD_CalTimeout_2
    562          	}
    563          	else
    564          	{
    565          		sds.timeout_read  = sds.timeout_read * 10 / 8;					
   \                     ??SD_CalTimeout_1: (+1)
   \   00000080   0xEB00 0x0280      ADD      R2,R0,R0, LSL #+2
   \   00000084   0x0050             LSLS     R0,R2,#+1
   \   00000086   0x08C0             LSRS     R0,R0,#+3
   \   00000088   0x6108             STR      R0,[R1, #+16]
    566          		sds.timeout_write = sds.timeout_write * 10 / 8;
   \   0000008A   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   0000008E   0x0040             LSLS     R0,R0,#+1
   \   00000090   0x08C0             LSRS     R0,R0,#+3
   \   00000092   0x6148             STR      R0,[R1, #+20]
    567          	}
    568          	
    569          	sds.timeout_erase = sds.timeout_write;
    570          	
    571          #if SD_UCOSII_EN
    572          	sds.timeout_read = (sds.timeout_read << 3) * OS_TICKS_PER_SEC / SPI_CLOCK; 
   \                     ??SD_CalTimeout_2: (+1)
   \   00000094   0xF44F 0x727A      MOV      R2,#+1000
   \   00000098   0x690B             LDR      R3,[R1, #+16]
   \   0000009A   0x6948             LDR      R0,[R1, #+20]
   \   0000009C   0x....             LDR.N    R4,??DataTable11_3  ;; 0x112a880
   \   0000009E   0x6188             STR      R0,[R1, #+24]
   \   000000A0   0x00DB             LSLS     R3,R3,#+3
   \   000000A2   0x4353             MULS     R3,R2,R3
   \   000000A4   0xFBB3 0xF3F4      UDIV     R3,R3,R4
   \   000000A8   0x610B             STR      R3,[R1, #+16]
    573          	sds.timeout_write =(sds.timeout_write << 3) * OS_TICKS_PER_SEC / SPI_CLOCK;
   \   000000AA   0x00C0             LSLS     R0,R0,#+3
   \   000000AC   0x4350             MULS     R0,R2,R0
   \   000000AE   0xFBB0 0xF0F4      UDIV     R0,R0,R4
   \   000000B2   0x6148             STR      R0,[R1, #+20]
    574          	sds.timeout_erase = sds.timeout_write;							/* (unit: os tick) */
   \   000000B4   0x6188             STR      R0,[R1, #+24]
    575          #endif	
    576          	
    577          	return SD_NO_ERR;	
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0xBCF0             POP      {R4-R7}
   \   000000BA   0x4770             BX       LR               ;; return
    578          }
    579          
    580          /*******************************************************************************************************************
    581          ** Name:	  INT8U SD_ActiveInit()
    582          ** Function: active card, and get the card type 
    583          ** Input:    NULL
    584          ** Output:	  0:  right			>0:  error code
    585          *******************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    586          INT8U SD_ActiveInit(void)
    587          {
   \                     SD_ActiveInit: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    588          	INT8U param[4] = {0,0,0,0},resp[5],ret;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x9100             STR      R1,[SP, #+0]
    589          	INT32U i = 0;
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0xF240 0x35E9      MOVW     R5,#+1001
    590          	
    591           	do 
    592              {										/* send CMD1 to poll card status */
    593                  ret = SD_SendCmd(CMD1, param, CMD1_R, resp);
   \                     ??SD_ActiveInit_0: (+1)
   \   0000000E   0xAB01             ADD      R3,SP,#+4
   \   00000010   0x2201             MOVS     R2,#+1
   \   00000012   0x4669             MOV      R1,SP
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x.... 0x....      BL       SD_SendCmd
    594                  if (ret != SD_NO_ERR)
   \   0000001A   0xBB38             CBNZ.N   R0,??SD_ActiveInit_1
    595                 		return ret;
    596                  i ++;
    597              }while (((resp[0] & MSK_IDLE) == MSK_IDLE) && (i <= SD_IDLE_WAIT_MAX));
   \   0000001C   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000020   0x1C64             ADDS     R4,R4,#+1
   \   00000022   0x07C0             LSLS     R0,R0,#+31
   \   00000024   0xD501             BPL.N    ??SD_ActiveInit_2
   \   00000026   0x42AC             CMP      R4,R5
   \   00000028   0xD3F1             BCC.N    ??SD_ActiveInit_0
    598              										/* if response R1 Idle bit is 1,continue recycle */    
    599              if (i >= SD_IDLE_WAIT_MAX)
   \                     ??SD_ActiveInit_2: (+1)
   \   0000002A   0xF5B4 0x7F7A      CMP      R4,#+1000
   \   0000002E   0xBF28             IT       CS 
   \   00000030   0x2034             MOVCS    R0,#+52
    600                  return SD_ERR_TIMEOUT_WAITIDLE;						/* time out,return error */	
   \   00000032   0xD21B             BCS.N    ??SD_ActiveInit_1
    601          	
    602              ret = SD_SendCmd(CMD55, param, CMD55_R, resp);
   \   00000034   0xAB01             ADD      R3,SP,#+4
   \   00000036   0x2201             MOVS     R2,#+1
   \   00000038   0x4669             MOV      R1,SP
   \   0000003A   0x2037             MOVS     R0,#+55
   \   0000003C   0x.... 0x....      BL       SD_SendCmd
    603              if (ret != SD_NO_ERR)
   \   00000040   0xB9A0             CBNZ.N   R0,??SD_ActiveInit_1
    604                 	return ret;
    605                 	
    606              ret = SD_SendCmd(ACMD41, param, ACMD41_R, resp);		                /* active card to initialize process internal */
    607              if (ret != SD_NO_ERR)	
   \   00000042   0xAB01             ADD      R3,SP,#+4
   \   00000044   0x2201             MOVS     R2,#+1
   \   00000046   0x4669             MOV      R1,SP
   \   00000048   0x2029             MOVS     R0,#+41
   \   0000004A   0x.... 0x....      BL       SD_SendCmd
   \   0000004E   0xB110             CBZ.N    R0,??SD_ActiveInit_3
    608              	return SD_ERR_UNKNOWN_CARD;
   \   00000050   0x2006             MOVS     R0,#+6
   \   00000052   0xB003             ADD      SP,SP,#+12
   \   00000054   0xBD30             POP      {R4,R5,PC}
    609              
    610              if ((resp[0] & 0xFE) == 0)
   \                     ??SD_ActiveInit_3: (+1)
   \   00000056   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000005A   0xF000 0x01FE      AND      R1,R0,#0xFE
   \   0000005E   0x1E48             SUBS     R0,R1,#+1
   \   00000060   0x4180             SBCS     R0,R0,R0
   \   00000062   0x43C0             MVNS     R0,R0
   \   00000064   0x....             LDR.N    R1,??DataTable11
   \   00000066   0x0FC0             LSRS     R0,R0,#+31
   \   00000068   0x7008             STRB     R0,[R1, #+0]
    611                	sds.card_type = CARDTYPE_SD;						/* the card is SD card */	
    612              else	
    613              	sds.card_type = CARDTYPE_MMC;						/* the card is MMC card */
    614          
    615          	return SD_NO_ERR;
   \   0000006A   0x2000             MOVS     R0,#+0
   \                     ??SD_ActiveInit_1: (+1)
   \   0000006C   0xB003             ADD      SP,SP,#+12
   \   0000006E   0xBD30             POP      {R4,R5,PC}       ;; return
    616          }
    617          
    618          /*******************************************************************************************************************
    619          ** Name:	  INT8U SD_StartSD()
    620          ** Function: request the right of operating sd to OS
    621          ** Input:	  NULL
    622          ** return:	  NULL
    623          ********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    624          void SD_StartSD(void)
    625          {
   \                     SD_StartSD: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    626          #if SD_UCOSII_EN
    627          	INT8U ret;
    628          	
    629          	OSSemPend(pSemSD, 0, &ret);					/* wait for semaphore that accessed Card */
   \   00000002   0x....             LDR.N    R0,??DataTable11
   \   00000004   0x69C0             LDR      R0,[R0, #+28]
   \   00000006   0x466A             MOV      R2,SP
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x.... 0x....      BL       OSSemPend
    630          #endif
    631          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
    632          
    633          /*******************************************************************************************************************
    634          ** Name:	  INT8U SD_EndSD()
    635          ** Function: return the right of operating sd to OS
    636          ** Input:	  NULL
    637          ** return:	  NULL
    638          ********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    639          void SD_EndSD(void)
    640          {
    641          #if SD_UCOSII_EN
    642          	OSSemPost(pSemSD);						/* return the semaphore accessing Card to OS */
   \                     SD_EndSD: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11
   \   00000002   0x69C0             LDR      R0,[R0, #+28]
   \   00000004   0x.... 0x....      B.W      OSSemPost
    643          #endif
    644          }	
    645          
    646          
    647          /*******************************************************************************************************************
    648          ** Name:	  INT16U SD_GetZLGSDVer()
    649          ** Function: get the version of ZLG/SD
    650          ** Input:    NULL
    651          ** Output:	  Version
    652          *******************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    653          INT16U SD_GetZLGSDVer(void)
    654          {
    655          	return 0x0200;						
   \                     SD_GetZLGSDVer: (+1)
   \   00000000   0xF44F 0x7000      MOV      R0,#+512
   \   00000004   0x4770             BX       LR               ;; return
    656          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     sds

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x00036EE8         DC32     0x36ee8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x00089544         DC32     0x89544

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x0112A880         DC32     0x112a880

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x00036EE9         DC32     0x36ee9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x00089545         DC32     0x89545

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    657          
    658          
    659          
    660          
    661          
    662          
    663          
    664          
    665          
    666          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   SD_ActiveInit
        24   -> SD_SendCmd
      16   SD_CalTimeout
       0   SD_EndSD
         0   -> OSSemPost
      32   SD_GetCardInfo
        32   -> SD_CalTimeout
        32   -> SD_ReadCSD
       0   SD_GetZLGSDVer
      24   SD_Initialize
        24   -> MSD_CS_Assert
        24   -> MSD_CS_Deassert
        24   -> OSSemCreate
        24   -> OSSemPend
        24   -> OSSemPost
        24   -> SD_ActiveInit
        24   -> SD_EnableCRC
        24   -> SD_GetCardInfo
        24   -> SD_ReadOCR
        24   -> SD_ResetSD
        24   -> SD_SPIDelay
        24   -> SD_SetBlockLen
      24   SD_ReadBlock
        24   -> OSSemPend
        24   -> OSSemPost
        24   -> SD_ReadBlockData
        24   -> SD_ReadSingleBlock
       0   SD_Sleep
       8   SD_StartSD
         8   -> OSSemPend
      24   SD_WriteBlock
        24   -> OSSemPend
        24   -> OSSemPost
        24   -> SD_ReadCard_Status
        24   -> SD_WriteBlockData
        24   -> SD_WriteSingleBlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
      10  ?Subroutine0
      10  ?Subroutine1
       4  ?_0
     112  SD_ActiveInit
     188  SD_CalTimeout
       8  SD_EndSD
     148  SD_GetCardInfo
       6  SD_GetZLGSDVer
     152  SD_Initialize
      50  SD_ReadBlock
       2  SD_Sleep
      16  SD_StartSD
      92  SD_WriteBlock
       8  r2w_fator
      32  sds
          pSemSD
      32  time_unit
      16  time_value

 
  32 bytes in section .bss
   4 bytes in section .rodata
 874 bytes in section .text
 
 874 bytes of CODE  memory
   4 bytes of CONST memory
  32 bytes of DATA  memory

Errors: none
Warnings: none
