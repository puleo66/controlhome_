###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       08/Oct/2017  11:53:37
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\HW Projects\ControlHome\CntrHome - RF69w\uC-FatFS\sdc_diskio.c
#    Command line =  
#        "E:\HW Projects\ControlHome\CntrHome - RF69w\uC-FatFS\sdc_diskio.c"
#        -lCN "E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\List" -o
#        "E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\Obj" --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\APP\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\BSP\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\CPU\inc\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-CPU\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-RTC\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-LIB\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uCOS-II\Ports\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uCOS-II\Source\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\I2C-Out\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Direct_Sw\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Wdt_led\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-LCD\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-RF\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\" -Oh
#    List file    =  
#        E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\List\sdc_diskio.lst
#    Object file  =  
#        E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\Obj\sdc_diskio.o
#
###############################################################################

E:\HW Projects\ControlHome\CntrHome - RF69w\uC-FatFS\sdc_diskio.c
      1              /*-----------------------------------------------------------------------*/   
      2              /* MMC/SDSC/SDHC (in SPI mode) control module  (C)                       */   
      3              /*-----------------------------------------------------------------------*/   
      4              /* filename: sdc_diskio.c                                                */   
      5              /*-----------------------------------------------------------------------*/   
      6                 
      7              #include "includes.h"   
      8              #include "diskio.h"      
      9                 
     10              /* Definitions for MMC/SDC command */   
     11              #define CMD0    (0x40+0)    /* GO_IDLE_STATE */   
     12              #define CMD1    (0x40+1)    /* SEND_OP_COND (MMC) */   
     13              #define ACMD41  (0xC0+41)   /* SEND_OP_COND (SDC) */   
     14              #define CMD8    (0x40+8)    /* SEND_IF_COND */   
     15              #define CMD9    (0x40+9)    /* SEND_CSD */   
     16              #define CMD10   (0x40+10)   /* SEND_CID */   
     17              #define CMD12   (0x40+12)   /* STOP_TRANSMISSION */   
     18              #define ACMD13  (0xC0+13)   /* SD_STATUS (SDC) */   
     19              #define CMD16   (0x40+16)   /* SET_BLOCKLEN */   
     20              #define CMD17   (0x40+17)   /* READ_SINGLE_BLOCK */   
     21              #define CMD18   (0x40+18)   /* READ_MULTIPLE_BLOCK */   
     22              #define CMD23   (0x40+23)   /* SET_BLOCK_COUNT (MMC) */   
     23              #define ACMD23  (0xC0+23)   /* SET_WR_BLK_ERASE_COUNT (SDC) */   
     24              #define CMD24   (0x40+24)   /* WRITE_BLOCK */   
     25              #define CMD25   (0x40+25)   /* WRITE_MULTIPLE_BLOCK */   
     26              #define CMD55   (0x40+55)   /* APP_CMD */   
     27              #define CMD58   (0x40+58)   /* READ_OCR */   
     28                 
     29              #define MMC_SELECT()     MSD_CS_Assert()            /* MMC CS = L */    
     30              #define MMC_DESELECT()   MSD_CS_Deassert()         /* MMC CS = H */   
     31                 
     32                 
     33              /*--------------------------------------------------------------------------  
     34                
     35                Module Private Functions  
     36                
     37                ---------------------------------------------------------------------------*/   
     38                 
     39              static volatile   

   \                                 In section .data, align 4
     40              DSTATUS Stat = STA_NOINIT;  /* Disk status */   
   \                     Stat:
   \   00000000   0x01               DC8 1
   \   00000001   0x00               DC8 0
   \   00000002   0x00 0x00          DC8 0, 0
     41                 
     42              static   
     43              BYTE CardType;              /* b0:MMC(1), b1:SDv1(2), b2:SDv2(4), b3:Block addressing(8) */   
     44                 
     45          //    extern volatile   
     46              unsigned int Timer1, Timer2;       
   \                     Timer1:
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .bss, align 4
   \                     Timer2:
   \   00000000                      DS8 4
     47                 
     48              static   
     49              UCHAR SPI_ReadWrite_Byte(unsigned char byte)   
     50              {         
     51                return (UCHAR)SPI2_SendByte(byte);
     52              }   
     53                 
     54              /*-----------------------------------------------------------------------*/   
     55              /* Wait for card ready                                                   */   
     56              /*-----------------------------------------------------------------------*/   
     57                 

   \                                 In section .text, align 2, keep-with-next
     58              static   
     59              BYTE Wait_Ready (void)   
     60              {   
   \                     Wait_Ready: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     61                  BYTE res;   
     62                 
     63                  Timer2 = 50;    /* Wait for ready in timeout of 500ms */   
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable8
   \   00000006   0x2032             MOVS     R0,#+50
   \   00000008   0x6020             STR      R0,[R4, #+0]
     64                  SPI_ReadWrite_Byte(0xff);;   
   \   0000000A   0x20FF             MOVS     R0,#+255
   \   0000000C   0x.... 0x....      BL       SPI2_SendByte
     65                  do{   
     66                      res = SPI_ReadWrite_Byte(0xff);   
   \                     ??Wait_Ready_0: (+1)
   \   00000010   0x20FF             MOVS     R0,#+255
   \   00000012   0x.... 0x....      BL       SPI2_SendByte
     67                  }while ((res != 0xFF) && Timer2);   
   \   00000016   0x28FF             CMP      R0,#+255
   \   00000018   0xBF1C             ITT      NE 
   \   0000001A   0x6821             LDRNE    R1,[R4, #+0]
   \   0000001C   0x2900             CMPNE    R1,#+0
   \   0000001E   0xD1F7             BNE.N    ??Wait_Ready_0
     68                 
     69                  return res;   
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
     70              }   
     71                 
     72              /*-----------------------------------------------------------------------*/   
     73              /* Deselect the card and release SPI bus                                 */   
     74              /*-----------------------------------------------------------------------*/   
     75                 
     76              static   
     77              void SPI_Release(void)   
     78              {   
     79                  MMC_DESELECT();   
     80                  SPI_ReadWrite_Byte(0xff);;   
     81              }   
     82                 
     83                 
     84                 
     85              /*-----------------------------------------------------------------------*/   
     86              /* Power Control  (Platform dependent)                                   */   
     87              /*-----------------------------------------------------------------------*/   
     88              /* When the target system does not support socket power control, there   */   
     89              /* is nothing to do in these functions and chk_power always returns 1.   */   
     90              /*-----------------------------------------------------------------------*/   
     91              #define MMC_POWERON()    GPIO_ResetBits(GPIOD, GPIO_Pin_10)         
     92              #define MMC_POWEROFF()   GPIO_SetBits(GPIOD, GPIO_Pin_10)   
     93                 

   \                                 In section .text, align 2, keep-with-next
     94              int chk_power(void)     /* Socket power state: 0=off, 1=on */   
     95              {   
     96                  return 1;   
   \                     chk_power: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4770             BX       LR               ;; return
     97              }   
     98                 
     99              /*-----------------------------------------------------------------------*/   
    100              /* Receive a data packet from MMC                                        */   
    101              /*-----------------------------------------------------------------------*/   
    102                 

   \                                 In section .text, align 2, keep-with-next
    103              static   
    104              BOOL Receive_DataBlock(   
    105                      BYTE *buff,         /* Data buffer to store received data */   
    106                      UINT btr            /* Byte count (must be multiple of 4) */   
    107                      )   
    108              {   
   \                     Receive_DataBlock: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    109                  BYTE token;   
    110                     
    111                  Timer1 = 10;   
   \   00000004   0x.... 0x....      LDR.W    R6,??DataTable8_1
   \   00000008   0x200A             MOVS     R0,#+10
   \   0000000A   0x460D             MOV      R5,R1
   \   0000000C   0x6070             STR      R0,[R6, #+4]
    112                  do {                            /* Wait for data packet in timeout of 100ms */   
    113                      token = SPI_ReadWrite_Byte(0xff);   
   \                     ??Receive_DataBlock_0: (+1)
   \   0000000E   0x20FF             MOVS     R0,#+255
   \   00000010   0x.... 0x....      BL       SPI2_SendByte
    114                  } while ((token == 0xFF) && Timer1);   
   \   00000014   0x28FF             CMP      R0,#+255
   \   00000016   0xD103             BNE.N    ??Receive_DataBlock_1
   \   00000018   0x6870             LDR      R0,[R6, #+4]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD1F7             BNE.N    ??Receive_DataBlock_0
   \   0000001E   0xE001             B.N      ??Receive_DataBlock_2
    115                  if(token != 0xFE) return FALSE; /* If not valid data token, retutn with error */   
   \                     ??Receive_DataBlock_1: (+1)
   \   00000020   0x28FE             CMP      R0,#+254
   \   00000022   0xD001             BEQ.N    ??Receive_DataBlock_3
   \                     ??Receive_DataBlock_2: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xBD70             POP      {R4-R6,PC}
    116                 
    117                  do {                            /* Receive the data block into buffer */   
    118                      *buff++ = SPI_ReadWrite_Byte(0xff);   
   \                     ??Receive_DataBlock_3: (+1)
   \   00000028   0x20FF             MOVS     R0,#+255
   \   0000002A   0x.... 0x....      BL       SPI2_SendByte
   \   0000002E   0xF804 0x0B01      STRB     R0,[R4], #+1
    119                  } while (btr--);   
   \   00000032   0x4628             MOV      R0,R5
   \   00000034   0x1E45             SUBS     R5,R0,#+1
   \   00000036   0xB280             UXTH     R0,R0
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD1F5             BNE.N    ??Receive_DataBlock_3
    120                  SPI_ReadWrite_Byte(0xff);       /* Discard CRC */   
   \   0000003C   0x20FF             MOVS     R0,#+255
   \   0000003E   0x.... 0x....      BL       SPI2_SendByte
    121                  SPI_ReadWrite_Byte(0xff);   
   \   00000042   0x20FF             MOVS     R0,#+255
   \   00000044   0x.... 0x....      BL       SPI2_SendByte
    122                 
    123                  return TRUE;                    /* Return with success */   
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xBD70             POP      {R4-R6,PC}       ;; return
    124              }   
    125                 
    126                 
    127                 
    128              /*-----------------------------------------------------------------------*/   
    129              /* Send a data packet to MMC                                             */   
    130              /*-----------------------------------------------------------------------*/   
    131                 
    132              #if _READONLY == 0   

   \                                 In section .text, align 2, keep-with-next
    133              static   
    134              BOOL Transmit_DataBlock (   
    135                      const BYTE *buff,   /* 512 byte data block to be transmitted */   
    136                      BYTE token          /* Data/Stop token */   
    137                      )   
    138              {   
   \                     Transmit_DataBlock: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    139                  BYTE resp;   
    140                  UINT wc;   
    141                 
    142                 
    143                  if (Wait_Ready() != 0xFF) return FALSE;   
   \   00000006   0x.... 0x....      BL       Wait_Ready
   \   0000000A   0x28FF             CMP      R0,#+255
   \   0000000C   0xD119             BNE.N    ??Transmit_DataBlock_0
    144                 
    145                  SPI_ReadWrite_Byte(token);          /* Transmit data token */   
   \   0000000E   0x4628             MOV      R0,R5
   \   00000010   0x.... 0x....      BL       SPI2_SendByte
    146                  if (token != 0xFD) {                /* Is data token, 0xFD for stop token */   
   \   00000014   0x2DFD             CMP      R5,#+253
   \   00000016   0xD016             BEQ.N    ??Transmit_DataBlock_1
    147                      wc = 512;   
   \   00000018   0xF44F 0x7500      MOV      R5,#+512
    148                      do {                            /* Transmit the 512 byte data block to MMC */   
    149                          SPI_ReadWrite_Byte(*buff++);   
   \                     ??Transmit_DataBlock_2: (+1)
   \   0000001C   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   00000020   0x.... 0x....      BL       SPI2_SendByte
    150                      } while (--wc);   
   \   00000024   0x1E6D             SUBS     R5,R5,#+1
   \   00000026   0xD1F9             BNE.N    ??Transmit_DataBlock_2
    151                      SPI_ReadWrite_Byte(0xFF);       /* CRC (Dummy) */   
   \   00000028   0x20FF             MOVS     R0,#+255
   \   0000002A   0x.... 0x....      BL       SPI2_SendByte
    152                      SPI_ReadWrite_Byte(0xFF);   
   \   0000002E   0x20FF             MOVS     R0,#+255
   \   00000030   0x.... 0x....      BL       SPI2_SendByte
    153                      resp = SPI_ReadWrite_Byte(0xff);/* Reveive data response */   
    154                      if ((resp & 0x1F) != 0x05)      /* If not accepted, return with error */   
   \   00000034   0x20FF             MOVS     R0,#+255
   \   00000036   0x.... 0x....      BL       SPI2_SendByte
   \   0000003A   0xF000 0x001F      AND      R0,R0,#0x1F
   \   0000003E   0x2805             CMP      R0,#+5
   \   00000040   0xD001             BEQ.N    ??Transmit_DataBlock_1
    155                          return FALSE;   
   \                     ??Transmit_DataBlock_0: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}
    156                  }   
    157                 
    158                  return TRUE;   
   \                     ??Transmit_DataBlock_1: (+1)
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    159              }   
    160              #endif /* _READONLY */   
    161                 
    162              /*-----------------------------------------------------------------------*/   
    163              /* Send a command packet to MMC                                          */   
    164              /* Output: R1, R2, R3 response                                           */   
    165              /*         In idle mode R1 Response is 0x01                              */   
    166              /*         When the card is initialized successfuly, R1 response is 0x00 */   
    167              /*-----------------------------------------------------------------------*/   
    168                 

   \                                 In section .text, align 2, keep-with-next
    169              static   
    170              BYTE Send_Command(   
    171                      BYTE cmd,       /* Command byte */   
    172                      DWORD arg       /* Argument */   
    173                      )   
    174              {   
   \                     Send_Command: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    175                  BYTE n, res;   
    176                 
    177                  /* Is a ACMD<n>? */   
    178                  if (cmd & 0x80) {   /* ACMD<n> is the command sequense of CMD55-CMD<n> */   
   \   00000004   0x0620             LSLS     R0,R4,#+24
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0xD507             BPL.N    ??Send_Command_0
    179                      cmd &= 0x7F;   
    180                      res = Send_Command(CMD55, 0);   
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x2077             MOVS     R0,#+119
   \   0000000E   0xF7FF 0xFFF7      BL       Send_Command
    181                      if (res > 1) return res;   
   \   00000012   0x2802             CMP      R0,#+2
   \   00000014   0xF004 0x047F      AND      R4,R4,#0x7F
   \   00000018   0xDA31             BGE.N    ??Send_Command_1
    182                  }   
    183                 
    184                  /* Select the card and wait for ready */   
    185                  MMC_DESELECT();   
   \                     ??Send_Command_0: (+1)
   \   0000001A   0x.... 0x....      BL       MSD_CS_Deassert
    186                  MMC_SELECT();   
   \   0000001E   0x.... 0x....      BL       MSD_CS_Assert
    187                  if (Wait_Ready() != 0xFF) return 0xFF;   
   \   00000022   0x.... 0x....      BL       Wait_Ready
   \   00000026   0x28FF             CMP      R0,#+255
   \   00000028   0xD001             BEQ.N    ??Send_Command_2
   \   0000002A   0x20FF             MOVS     R0,#+255
   \   0000002C   0xBD32             POP      {R1,R4,R5,PC}
    188                 
    189                  /* Send command packet */   
    190                  SPI_ReadWrite_Byte(cmd);   
   \                     ??Send_Command_2: (+1)
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       SPI2_SendByte
    191                  SPI_ReadWrite_Byte((BYTE)(arg >> 24));        /* Argument[31..24] */   
   \   00000034   0x0E28             LSRS     R0,R5,#+24
   \   00000036   0x.... 0x....      BL       SPI2_SendByte
    192                  SPI_ReadWrite_Byte((BYTE)(arg >> 16));        /* Argument[23..16] */   
   \   0000003A   0x0228             LSLS     R0,R5,#+8
   \   0000003C   0x0E00             LSRS     R0,R0,#+24
   \   0000003E   0x.... 0x....      BL       SPI2_SendByte
    193                  SPI_ReadWrite_Byte((BYTE)(arg >> 8));     /* Argument[15..8] */   
   \   00000042   0x0428             LSLS     R0,R5,#+16
   \   00000044   0x0E00             LSRS     R0,R0,#+24
   \   00000046   0x.... 0x....      BL       SPI2_SendByte
    194                  SPI_ReadWrite_Byte((BYTE)arg);              /* Argument[7..0] */   
   \   0000004A   0xB2E8             UXTB     R0,R5
   \   0000004C   0x.... 0x....      BL       SPI2_SendByte
    195                  n = 0x01;                                   /* Dummy CRC + Stop */   
   \   00000050   0x2001             MOVS     R0,#+1
    196                  if (cmd == CMD0) n = 0x95;                  /* Valid CRC for CMD0(0) */   
   \   00000052   0x2C40             CMP      R4,#+64
   \   00000054   0xBF08             IT       EQ 
   \   00000056   0x2095             MOVEQ    R0,#+149
   \   00000058   0xD002             BEQ.N    ??Send_Command_3
    197                  if (cmd == CMD8) n = 0x87;                  /* Valid CRC for CMD8(0x1AA) */   
   \   0000005A   0x2C48             CMP      R4,#+72
   \   0000005C   0xBF08             IT       EQ 
   \   0000005E   0x2087             MOVEQ    R0,#+135
    198                  SPI_ReadWrite_Byte(n);   
   \                     ??Send_Command_3: (+1)
   \   00000060   0x.... 0x....      BL       SPI2_SendByte
    199                 
    200                  /* Receive command response */   
    201                  if (cmd == CMD12) {    
   \   00000064   0x2C4C             CMP      R4,#+76
   \   00000066   0xBF04             ITT      EQ 
    202                      /* The received byte immediataly following   
    203                       * CMD12 is a stuff byte, it should be discarded  
    204                       * before receive the response of the CMD12. */   
    205                      SPI_ReadWrite_Byte(0xff);              
   \   00000068   0x20FF             MOVEQ    R0,#+255
   \   0000006A   0x.... 0x....      BLEQ     SPI2_SendByte
    206                  }   
    207                 
    208                  /* Wait for a valid response in timeout of 10 attempts */   
    209                  n = 10;                                
   \   0000006E   0x240A             MOVS     R4,#+10
    210                  do{   
    211                      res = SPI_ReadWrite_Byte(0xff);   
   \                     ??Send_Command_4: (+1)
   \   00000070   0x20FF             MOVS     R0,#+255
   \   00000072   0x.... 0x....      BL       SPI2_SendByte
    212                  }while ((res & 0x80) && --n);   
   \   00000076   0x0601             LSLS     R1,R0,#+24
   \   00000078   0xD501             BPL.N    ??Send_Command_1
   \   0000007A   0x1E64             SUBS     R4,R4,#+1
   \   0000007C   0xD1F8             BNE.N    ??Send_Command_4
    213                 
    214                  return res;         /* Return with the response value */   
   \                     ??Send_Command_1: (+1)
   \   0000007E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    215              }   
    216                 
    217              /*--------------------------------------------------------------------------  
    218                
    219                Public Functions  
    220                
    221                ---------------------------------------------------------------------------*/   
    222                 
    223                 
    224              /*-----------------------------------------------------------------------*/   
    225              /* Initialize Disk Drive                                                 */   
    226              /*-----------------------------------------------------------------------*/   
    227                 

   \                                 In section .text, align 2, keep-with-next
    228              DSTATUS disk_initialize (   
    229                      BYTE drv        /* Physical drive nmuber (0) */   
    230                      )   
    231              {   
   \                     disk_initialize: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    232                  BYTE n, cmd, ty, ocr[4];   
    233                 
    234                 
    235                  if (drv) return STA_NOINIT;             /* Supports only single drive */   
   \   00000004   0xB108             CBZ.N    R0,??disk_initialize_0
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD76             POP      {R1,R2,R4-R6,PC}
    236                  if (Stat & STA_NODISK) return Stat;             /* No card in the socket */   
   \                     ??disk_initialize_0: (+1)
   \   0000000A   0x.... 0x....      LDR.W    R4,??DataTable8_1
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x0780             LSLS     R0,R0,#+30
   \   00000012   0xD431             BMI.N    ??disk_initialize_1
    237                 
    238                  MMC_DESELECT();   
   \   00000014   0x.... 0x....      BL       MSD_CS_Deassert
    239                  /* Wait for enter Idle state in timeout of 5000 msec */   
    240                  Timer1 = 500;   
   \   00000018   0xF44F 0x70FA      MOV      R0,#+500
   \   0000001C   0x6060             STR      R0,[R4, #+4]
    241                  do{   
    242                 
    243                      for (n = 10; n; n--) SPI_ReadWrite_Byte(0xff);      /* 80 dummy clocks */   
   \                     ??disk_initialize_2: (+1)
   \   0000001E   0x250A             MOVS     R5,#+10
   \                     ??disk_initialize_3: (+1)
   \   00000020   0x20FF             MOVS     R0,#+255
   \   00000022   0x.... 0x....      BL       SPI2_SendByte
   \   00000026   0x1E6D             SUBS     R5,R5,#+1
   \   00000028   0xB2ED             UXTB     R5,R5
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD1F8             BNE.N    ??disk_initialize_3
    244                  }   
    245                  while((Send_Command(CMD0,0) != 1) && Timer1);   
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x2040             MOVS     R0,#+64
   \   00000032   0x.... 0x....      BL       Send_Command
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xBF1C             ITT      NE 
   \   0000003A   0x6860             LDRNE    R0,[R4, #+4]
   \   0000003C   0x2800             CMPNE    R0,#+0
   \   0000003E   0xD1EE             BNE.N    ??disk_initialize_2
    246                 
    247                  ty = 0;   
    248                  Timer1 = 200;                   /* Initialization timeout of 2000 msec */   
   \   00000040   0x20C8             MOVS     R0,#+200
   \   00000042   0x6060             STR      R0,[R4, #+4]
    249                  if (Send_Command(CMD8, 0x1AA) == 1) {       /* ??????SDC Ver2 */   
   \   00000044   0xF44F 0x71D5      MOV      R1,#+426
   \   00000048   0x2048             MOVS     R0,#+72
   \   0000004A   0x.... 0x....      BL       Send_Command
   \   0000004E   0x2801             CMP      R0,#+1
   \   00000050   0xD16A             BNE.N    ??disk_initialize_4
   \   00000052   0x466D             MOV      R5,SP
   \   00000054   0x2604             MOVS     R6,#+4
    250                      for (n = 0; n < 4; n++)    
    251                          ocr[n] = SPI_ReadWrite_Byte(0xff);  /* Get trailing return value of R7 resp */   
   \                     ??disk_initialize_5: (+1)
   \   00000056   0x20FF             MOVS     R0,#+255
   \   00000058   0x.... 0x....      BL       SPI2_SendByte
   \   0000005C   0x1E76             SUBS     R6,R6,#+1
   \   0000005E   0xF805 0x0B01      STRB     R0,[R5], #+1
   \   00000062   0xD1F8             BNE.N    ??disk_initialize_5
    252                      if (ocr[2] == 0x01 && ocr[3] == 0xAA) {            
   \   00000064   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000068   0x2801             CMP      R0,#+1
   \   0000006A   0xD007             BEQ.N    ??disk_initialize_6
   \                     ??disk_initialize_7: (+1)
   \   0000006C   0x2000             MOVS     R0,#+0
   \                     ??disk_initialize_8: (+1)
   \   0000006E   0x7060             STRB     R0,[R4, #+1]
    253                          /* The card can work at vdd range of 2.7-3.6V */   
    254                          /* Wait for leaving idle state (ACMD41 with HCS bit) */   
    255                          while (Timer1 && Send_Command(ACMD41, 1UL << 30));                   
    256                          if (Timer1 && Send_Command(CMD58, 0) == 0) {           
    257                              /* Check CCS bit in the OCR */   
    258                              for (n = 0; n < 4; n++)   
    259                                  ocr[n] = SPI_ReadWrite_Byte(0xff);   
    260                              /* When CCS bit is set  R/W in block address insted of byte address */   
    261                              ty = (ocr[0] & 0x40) ? 12 : 4;   
    262                          }   
    263                      }   
    264                  } else {                               
    265                      /* SDSC or MMC */   
    266                      if (Send_Command(ACMD41, 0) <= 1)    {           /* initialize successful will response 0x00 */   
    267                          ty = 2; cmd = ACMD41;   /* SDv1 */   
    268                      } else {   
    269                          ty = 1; cmd = CMD1;     /* MMC */   
    270                      }   
    271                      while (Timer1 && Send_Command(cmd, 0));         /* Wait for leaving idle state */   
    272                      if (!Timer1 || Send_Command(CMD16, 512) != 0)   /* Set R/W block length to 512 */   
    273                          ty = 0;   
    274                  }   
    275                 
    276                  CardType = ty;       
    277                 
    278                  if (ty) {   
    279                      /* Initialization succeded */   
    280                      Stat &= ~STA_NOINIT;       
    281                      printf("Initialization succeded.\n");  
    282                  } else {                           
    283                      /* Initialization failed */   
    284                      printf("Initialization failed.\n");
   \                     ??disk_initialize_9: (+1)
   \   00000070   0x.... 0x....      ADR.W    R0,?_1
   \                     ??disk_initialize_10: (+1)
   \   00000074   0x.... 0x....      BL       printf
    285           
    286                  }   
    287                 
    288                  return Stat;   
   \                     ??disk_initialize_1: (+1)
   \   00000078   0x7820             LDRB     R0,[R4, #+0]
   \   0000007A   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   \                     ??disk_initialize_6: (+1)
   \   0000007C   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   00000080   0x28AA             CMP      R0,#+170
   \   00000082   0xD1F3             BNE.N    ??disk_initialize_7
   \                     ??disk_initialize_11: (+1)
   \   00000084   0x6860             LDR      R0,[R4, #+4]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD0F1             BEQ.N    ??disk_initialize_8
   \   0000008A   0x2100             MOVS     R1,#+0
   \   0000008C   0x2077             MOVS     R0,#+119
   \   0000008E   0x.... 0x....      BL       Send_Command
   \   00000092   0x2802             CMP      R0,#+2
   \   00000094   0xDAF6             BGE.N    ??disk_initialize_11
   \   00000096   0x.... 0x....      BL       MSD_CS_Deassert
   \   0000009A   0x.... 0x....      BL       MSD_CS_Assert
   \   0000009E   0x.... 0x....      BL       Wait_Ready
   \   000000A2   0x28FF             CMP      R0,#+255
   \   000000A4   0xD1EE             BNE.N    ??disk_initialize_11
   \   000000A6   0x2069             MOVS     R0,#+105
   \   000000A8   0x.... 0x....      BL       SPI2_SendByte
   \   000000AC   0x2040             MOVS     R0,#+64
   \   000000AE   0x.... 0x....      BL       SPI2_SendByte
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x.... 0x....      BL       SPI2_SendByte
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x.... 0x....      BL       SPI2_SendByte
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x.... 0x....      BL       SPI2_SendByte
   \   000000C4   0x2001             MOVS     R0,#+1
   \   000000C6   0x.... 0x....      BL       SPI2_SendByte
   \   000000CA   0x260A             MOVS     R6,#+10
   \                     ??disk_initialize_12: (+1)
   \   000000CC   0x20FF             MOVS     R0,#+255
   \   000000CE   0x.... 0x....      BL       SPI2_SendByte
   \   000000D2   0x0601             LSLS     R1,R0,#+24
   \   000000D4   0xD501             BPL.N    ??disk_initialize_13
   \   000000D6   0x1E76             SUBS     R6,R6,#+1
   \   000000D8   0xD1F8             BNE.N    ??disk_initialize_12
   \                     ??disk_initialize_13: (+1)
   \   000000DA   0x2800             CMP      R0,#+0
   \   000000DC   0xD1D2             BNE.N    ??disk_initialize_11
   \   000000DE   0x6860             LDR      R0,[R4, #+4]
   \   000000E0   0x2800             CMP      R0,#+0
   \   000000E2   0xD0C3             BEQ.N    ??disk_initialize_7
   \   000000E4   0x2100             MOVS     R1,#+0
   \   000000E6   0x207A             MOVS     R0,#+122
   \   000000E8   0x.... 0x....      BL       Send_Command
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD1BD             BNE.N    ??disk_initialize_7
   \   000000F0   0x20FF             MOVS     R0,#+255
   \   000000F2   0x.... 0x....      BL       SPI2_SendByte
   \   000000F6   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   000000FA   0x20FF             MOVS     R0,#+255
   \   000000FC   0x.... 0x....      BL       SPI2_SendByte
   \   00000100   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   00000104   0x20FF             MOVS     R0,#+255
   \   00000106   0x.... 0x....      BL       SPI2_SendByte
   \   0000010A   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   0000010E   0x20FF             MOVS     R0,#+255
   \   00000110   0x.... 0x....      BL       SPI2_SendByte
   \   00000114   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   00000118   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000011C   0x0640             LSLS     R0,R0,#+25
   \   0000011E   0xBF4C             ITE      MI 
   \   00000120   0x200C             MOVMI    R0,#+12
   \   00000122   0x2004             MOVPL    R0,#+4
   \   00000124   0x7060             STRB     R0,[R4, #+1]
   \   00000126   0xE01F             B.N      ??disk_initialize_14
   \                     ??disk_initialize_4: (+1)
   \   00000128   0x2100             MOVS     R1,#+0
   \   0000012A   0x20E9             MOVS     R0,#+233
   \   0000012C   0x.... 0x....      BL       Send_Command
   \   00000130   0x2802             CMP      R0,#+2
   \   00000132   0xBFB9             ITTEE    LT 
   \   00000134   0x2502             MOVLT    R5,#+2
   \   00000136   0x26E9             MOVLT    R6,#+233
   \   00000138   0x2501             MOVGE    R5,#+1
   \   0000013A   0x2641             MOVGE    R6,#+65
   \                     ??disk_initialize_15: (+1)
   \   0000013C   0x6860             LDR      R0,[R4, #+4]
   \   0000013E   0x2800             CMP      R0,#+0
   \   00000140   0xD094             BEQ.N    ??disk_initialize_7
   \   00000142   0x2100             MOVS     R1,#+0
   \   00000144   0x4630             MOV      R0,R6
   \   00000146   0x.... 0x....      BL       Send_Command
   \   0000014A   0x2800             CMP      R0,#+0
   \   0000014C   0xD1F6             BNE.N    ??disk_initialize_15
   \   0000014E   0x6860             LDR      R0,[R4, #+4]
   \   00000150   0x2800             CMP      R0,#+0
   \   00000152   0xD08B             BEQ.N    ??disk_initialize_7
   \   00000154   0xF44F 0x7100      MOV      R1,#+512
   \   00000158   0x2050             MOVS     R0,#+80
   \   0000015A   0x.... 0x....      BL       Send_Command
   \   0000015E   0x2800             CMP      R0,#+0
   \   00000160   0xD184             BNE.N    ??disk_initialize_7
   \   00000162   0x2D00             CMP      R5,#+0
   \   00000164   0x7065             STRB     R5,[R4, #+1]
   \   00000166   0xD083             BEQ.N    ??disk_initialize_9
   \                     ??disk_initialize_14: (+1)
   \   00000168   0x7820             LDRB     R0,[R4, #+0]
   \   0000016A   0xF000 0x00FE      AND      R0,R0,#0xFE
   \   0000016E   0x7020             STRB     R0,[R4, #+0]
   \   00000170   0x.... 0x....      ADR.W    R0,?_0
   \   00000174   0xE77E             B.N      ??disk_initialize_10
    289              }   
    290                 
    291                 
    292                 
    293              /*-----------------------------------------------------------------------*/   
    294              /* Get Disk Status                                                       */   
    295              /*-----------------------------------------------------------------------*/   
    296                 

   \                                 In section .text, align 2, keep-with-next
    297              DSTATUS disk_status (   
    298                      BYTE drv        /* Physical drive nmuber (0) */   
    299                      )   
    300              {   
    301                  if (drv) return STA_NOINIT;     /* Supports only single drive */   
   \                     disk_status: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xBF12             ITEE     NE 
   \   00000004   0x2001             MOVNE    R0,#+1
   \   00000006   0x.... 0x....      LDREQ.W  R0,??DataTable8_1
   \   0000000A   0x7800             LDRBEQ   R0,[R0, #+0]
    302                  return Stat;   
   \   0000000C   0x4770             BX       LR
    303              }   
    304                 
    305                 
    306                 
    307              /*-----------------------------------------------------------------------*/   
    308              /* Read Sector(s)                                                        */   
    309              /*-----------------------------------------------------------------------*/   
    310                 

   \                                 In section .text, align 2, keep-with-next
    311              DRESULT disk_read (   
    312                      BYTE drv,           /* Physical drive nmuber (0) */   
    313                      BYTE *buff,         /* Pointer to the data buffer to store read data */   
    314                      DWORD sector,               /* Start sector number (LBA) */   
    315                      BYTE count          /* Sector count (1..255) */   
    316                      )   
    317              {   
   \                     disk_read: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4611             MOV      R1,R2
   \   00000008   0x461C             MOV      R4,R3
    318                  if (drv || !count) return RES_PARERR;   
   \   0000000A   0xB900             CBNZ.N   R0,??disk_read_0
   \   0000000C   0xB914             CBNZ.N   R4,??disk_read_1
   \                     ??disk_read_0: (+1)
   \   0000000E   0x2004             MOVS     R0,#+4
   \   00000010   0xE8BD 0x81F0      POP      {R4-R8,PC}
    319                  if (Stat & STA_NOINIT) return RES_NOTRDY;   
   \                     ??disk_read_1: (+1)
   \   00000014   0x.... 0x....      LDR.W    R6,??DataTable8_1
   \   00000018   0x7830             LDRB     R0,[R6, #+0]
   \   0000001A   0x07C0             LSLS     R0,R0,#+31
   \   0000001C   0xBF48             IT       MI 
   \   0000001E   0x2003             MOVMI    R0,#+3
   \   00000020   0xD448             BMI.N    ??disk_read_2
    320                 
    321                  if (!(CardType & 8)) sector *= 512; /* Convert to byte address if needed */   
   \   00000022   0x7870             LDRB     R0,[R6, #+1]
   \   00000024   0x0700             LSLS     R0,R0,#+28
   \   00000026   0xBF58             IT       PL 
   \   00000028   0x0249             LSLPL    R1,R1,#+9
    322                 
    323                  if (count == 1) {   /* Single block read */   
   \   0000002A   0x2C01             CMP      R4,#+1
   \   0000002C   0xD10B             BNE.N    ??disk_read_3
    324                      if ((Send_Command(CMD17, sector) == 0)  /* READ_SINGLE_BLOCK */   
    325                              && Receive_DataBlock(buff, 512))   
   \   0000002E   0x2051             MOVS     R0,#+81
   \   00000030   0x.... 0x....      BL       Send_Command
   \   00000034   0xBBA8             CBNZ.N   R0,??disk_read_4
   \   00000036   0xF44F 0x7100      MOV      R1,#+512
   \   0000003A   0x4628             MOV      R0,R5
   \   0000003C   0x.... 0x....      BL       Receive_DataBlock
   \   00000040   0xB378             CBZ.N    R0,??disk_read_4
    326                          count = 0;   
   \   00000042   0x2400             MOVS     R4,#+0
   \   00000044   0xE02D             B.N      ??disk_read_4
    327                  }   
    328                  else {              /* Multiple block read */   
    329                      if (Send_Command(CMD18, sector) == 0) { /* READ_MULTIPLE_BLOCK */   
   \                     ??disk_read_3: (+1)
   \   00000046   0x2052             MOVS     R0,#+82
   \   00000048   0x.... 0x....      BL       Send_Command
   \   0000004C   0xBB48             CBNZ.N   R0,??disk_read_4
    330                          do {   
    331                              if (!Receive_DataBlock(buff, 512)) break;   
   \                     ??disk_read_5: (+1)
   \   0000004E   0x200A             MOVS     R0,#+10
   \   00000050   0xF44F 0x7700      MOV      R7,#+512
   \   00000054   0x46A8             MOV      R8,R5
   \   00000056   0x6070             STR      R0,[R6, #+4]
   \                     ??disk_read_6: (+1)
   \   00000058   0x20FF             MOVS     R0,#+255
   \   0000005A   0x.... 0x....      BL       SPI2_SendByte
   \   0000005E   0x28FF             CMP      R0,#+255
   \   00000060   0xD103             BNE.N    ??disk_read_7
   \   00000062   0x6870             LDR      R0,[R6, #+4]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD1F7             BNE.N    ??disk_read_6
   \   00000068   0xE017             B.N      ??disk_read_8
   \                     ??disk_read_7: (+1)
   \   0000006A   0x28FE             CMP      R0,#+254
   \   0000006C   0xD115             BNE.N    ??disk_read_8
   \                     ??disk_read_9: (+1)
   \   0000006E   0x20FF             MOVS     R0,#+255
   \   00000070   0x.... 0x....      BL       SPI2_SendByte
   \   00000074   0xF808 0x0B01      STRB     R0,[R8], #+1
   \   00000078   0x4638             MOV      R0,R7
   \   0000007A   0x1E47             SUBS     R7,R0,#+1
   \   0000007C   0xB280             UXTH     R0,R0
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD1F5             BNE.N    ??disk_read_9
   \   00000082   0x20FF             MOVS     R0,#+255
   \   00000084   0x.... 0x....      BL       SPI2_SendByte
   \   00000088   0x20FF             MOVS     R0,#+255
   \   0000008A   0x.... 0x....      BL       SPI2_SendByte
    332                              buff += 512;   
    333                          } while (--count);   
   \   0000008E   0x1E64             SUBS     R4,R4,#+1
   \   00000090   0xB2E4             UXTB     R4,R4
   \   00000092   0x2C00             CMP      R4,#+0
   \   00000094   0xF505 0x7500      ADD      R5,R5,#+512
   \   00000098   0xD1D9             BNE.N    ??disk_read_5
    334                          Send_Command(CMD12, 0);             /* STOP_TRANSMISSION */   
   \                     ??disk_read_8: (+1)
   \   0000009A   0x2100             MOVS     R1,#+0
   \   0000009C   0x204C             MOVS     R0,#+76
   \   0000009E   0x.... 0x....      BL       Send_Command
    335                      }   
    336                  }   
    337                  SPI_Release();   
   \                     ??disk_read_4: (+1)
   \   000000A2   0x.... 0x....      BL       MSD_CS_Deassert
   \   000000A6   0x20FF             MOVS     R0,#+255
   \   000000A8   0x.... 0x....      BL       SPI2_SendByte
    338                 
    339                  return count ? RES_ERROR : RES_OK;   
   \   000000AC   0x1E60             SUBS     R0,R4,#+1
   \   000000AE   0x4180             SBCS     R0,R0,R0
   \   000000B0   0x43C0             MVNS     R0,R0
   \   000000B2   0x0FC0             LSRS     R0,R0,#+31
   \                     ??disk_read_2: (+1)
   \   000000B4   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    340              }   
    341                 
    342                 
    343                 
    344              /*-----------------------------------------------------------------------*/   
    345              /* Write Sector(s)                                                       */   
    346              /*-----------------------------------------------------------------------*/   
    347                 
    348              #if _READONLY == 0   

   \                                 In section .text, align 2, keep-with-next
    349              DRESULT disk_write (   
    350                      BYTE drv,           /* Physical drive nmuber (0) */   
    351                      const BYTE *buff,   /* Pointer to the data to be written */   
    352                      DWORD sector,       /* Start sector number (LBA) */   
    353                      BYTE count          /* Sector count (1..255) */   
    354                      )   
    355              {   
   \                     disk_write: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4616             MOV      R6,R2
   \   00000006   0x461D             MOV      R5,R3
    356                  if (drv || !count) return RES_PARERR;   
   \   00000008   0xB900             CBNZ.N   R0,??disk_write_0
   \   0000000A   0xB90D             CBNZ.N   R5,??disk_write_1
   \                     ??disk_write_0: (+1)
   \   0000000C   0x2004             MOVS     R0,#+4
   \   0000000E   0xBDF2             POP      {R1,R4-R7,PC}
    357                  if (Stat & STA_NOINIT) return RES_NOTRDY;   
   \                     ??disk_write_1: (+1)
   \   00000010   0x....             LDR.N    R0,??DataTable8_1
   \   00000012   0x7801             LDRB     R1,[R0, #+0]
   \   00000014   0x07C9             LSLS     R1,R1,#+31
   \   00000016   0xD501             BPL.N    ??disk_write_2
   \   00000018   0x2003             MOVS     R0,#+3
   \   0000001A   0xBDF2             POP      {R1,R4-R7,PC}
    358                  if (Stat & STA_PROTECT) return RES_WRPRT;   
   \                     ??disk_write_2: (+1)
   \   0000001C   0x7801             LDRB     R1,[R0, #+0]
   \   0000001E   0x0749             LSLS     R1,R1,#+29
   \   00000020   0xD501             BPL.N    ??disk_write_3
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xBDF2             POP      {R1,R4-R7,PC}
    359                 
    360                  if (!(CardType & 8)) sector *= 512; /* Convert to byte address if needed */   
   \                     ??disk_write_3: (+1)
   \   00000026   0x7840             LDRB     R0,[R0, #+1]
   \   00000028   0x0701             LSLS     R1,R0,#+28
   \   0000002A   0xBF58             IT       PL 
   \   0000002C   0x0276             LSLPL    R6,R6,#+9
    361                 
    362                  if (count == 1) {   /* Single block write */   
   \   0000002E   0x2D01             CMP      R5,#+1
   \   00000030   0xD10D             BNE.N    ??disk_write_4
    363                      if ((Send_Command(CMD24, sector) == 0)  /* WRITE_BLOCK */   
    364                              && Transmit_DataBlock(buff, 0xFE))   
   \   00000032   0x4631             MOV      R1,R6
   \   00000034   0x2058             MOVS     R0,#+88
   \   00000036   0x.... 0x....      BL       Send_Command
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD13F             BNE.N    ??disk_write_5
   \   0000003E   0x21FE             MOVS     R1,#+254
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x.... 0x....      BL       Transmit_DataBlock
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD039             BEQ.N    ??disk_write_5
    365                          count = 0;   
   \   0000004A   0x2500             MOVS     R5,#+0
   \   0000004C   0xE037             B.N      ??disk_write_5
    366                  }   
    367                  else {              /* Multiple block write */   
    368                      if (CardType & 6) Send_Command(ACMD23, count);   
   \                     ??disk_write_4: (+1)
   \   0000004E   0x2106             MOVS     R1,#+6
   \   00000050   0x4208             TST      R0,R1
   \   00000052   0xD003             BEQ.N    ??disk_write_6
   \   00000054   0x4629             MOV      R1,R5
   \   00000056   0x20D7             MOVS     R0,#+215
   \   00000058   0x.... 0x....      BL       Send_Command
    369                      if (Send_Command(CMD25, sector) == 0) { /* WRITE_MULTIPLE_BLOCK */   
   \                     ??disk_write_6: (+1)
   \   0000005C   0x4631             MOV      R1,R6
   \   0000005E   0x2059             MOVS     R0,#+89
   \   00000060   0x.... 0x....      BL       Send_Command
   \   00000064   0xBB58             CBNZ.N   R0,??disk_write_5
    370                          do {   
    371                              if (!Transmit_DataBlock(buff, 0xFC)) break;   
   \                     ??disk_write_7: (+1)
   \   00000066   0x.... 0x....      BL       Wait_Ready
   \   0000006A   0x28FF             CMP      R0,#+255
   \   0000006C   0x4626             MOV      R6,R4
   \   0000006E   0xD11D             BNE.N    ??disk_write_8
   \   00000070   0x20FC             MOVS     R0,#+252
   \   00000072   0x.... 0x....      BL       SPI2_SendByte
   \   00000076   0xF44F 0x7700      MOV      R7,#+512
   \                     ??disk_write_9: (+1)
   \   0000007A   0xF816 0x0B01      LDRB     R0,[R6], #+1
   \   0000007E   0x.... 0x....      BL       SPI2_SendByte
   \   00000082   0x1E7F             SUBS     R7,R7,#+1
   \   00000084   0xD1F9             BNE.N    ??disk_write_9
   \   00000086   0x20FF             MOVS     R0,#+255
   \   00000088   0x.... 0x....      BL       SPI2_SendByte
   \   0000008C   0x20FF             MOVS     R0,#+255
   \   0000008E   0x.... 0x....      BL       SPI2_SendByte
   \   00000092   0x20FF             MOVS     R0,#+255
   \   00000094   0x.... 0x....      BL       SPI2_SendByte
   \   00000098   0xF000 0x001F      AND      R0,R0,#0x1F
   \   0000009C   0x2805             CMP      R0,#+5
   \   0000009E   0xD105             BNE.N    ??disk_write_8
    372                              buff += 512;   
    373                          } while (--count);   
   \   000000A0   0x1E6D             SUBS     R5,R5,#+1
   \   000000A2   0xB2ED             UXTB     R5,R5
   \   000000A4   0x2D00             CMP      R5,#+0
   \   000000A6   0xF504 0x7400      ADD      R4,R4,#+512
   \   000000AA   0xD1DC             BNE.N    ??disk_write_7
    374                          if (!Transmit_DataBlock(0, 0xFD))   /* STOP_TRAN token */   
   \                     ??disk_write_8: (+1)
   \   000000AC   0x.... 0x....      BL       Wait_Ready
   \   000000B0   0x28FF             CMP      R0,#+255
   \   000000B2   0xD103             BNE.N    ??disk_write_10
   \   000000B4   0x20FD             MOVS     R0,#+253
   \   000000B6   0x.... 0x....      BL       SPI2_SendByte
   \   000000BA   0xE000             B.N      ??disk_write_5
    375                              count = 1;                      /* faild */   
   \                     ??disk_write_10: (+1)
   \   000000BC   0x2501             MOVS     R5,#+1
    376                      }   
    377                  }   
    378                  SPI_Release();   
   \                     ??disk_write_5: (+1)
   \   000000BE   0x.... 0x....      BL       MSD_CS_Deassert
   \   000000C2   0x20FF             MOVS     R0,#+255
   \   000000C4   0x.... 0x....      BL       SPI2_SendByte
    379                 
    380                  return count ? RES_ERROR : RES_OK;   
   \   000000C8   0x1E68             SUBS     R0,R5,#+1
   \   000000CA   0x4180             SBCS     R0,R0,R0
   \   000000CC   0x43C0             MVNS     R0,R0
   \   000000CE   0x0FC0             LSRS     R0,R0,#+31
   \   000000D0   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    381              }   
    382              #endif /* _READONLY == 0 */   
    383                 
    384                 
    385                 
    386              /*-----------------------------------------------------------------------*/   
    387              /* Miscellaneous Functions                                               */   
    388              /*-----------------------------------------------------------------------*/   
    389                 
    390              #if _USE_IOCTL != 0   

   \                                 In section .text, align 4, keep-with-next
    391              DRESULT disk_ioctl (   
    392                      BYTE drv,       /* Physical drive nmuber (0) */   
    393                      BYTE ctrl,      /* Control code */   
    394                      void *buff      /* Buffer to send/receive control data */   
    395                      )   
    396              {   
   \                     disk_ioctl: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x4614             MOV      R4,R2
    397                  DRESULT res;   
    398                  BYTE n, csd[16], *ptr = buff;   
    399                  WORD csize;   
    400                 
    401                 
    402                  if (drv) return RES_PARERR;   
   \   00000006   0xB110             CBZ.N    R0,??disk_ioctl_1
   \   00000008   0x2004             MOVS     R0,#+4
   \   0000000A   0xB004             ADD      SP,SP,#+16
   \   0000000C   0xBD70             POP      {R4-R6,PC}
    403                 
    404                  res = RES_ERROR;   
   \                     ??disk_ioctl_1: (+1)
   \   0000000E   0x2601             MOVS     R6,#+1
    405                 
    406                  if (ctrl == CTRL_POWER) {   
   \   00000010   0x2904             CMP      R1,#+4
   \   00000012   0xD113             BNE.N    ??disk_ioctl_2
    407                      switch (*ptr) {   
   \   00000014   0x7820             LDRB     R0,[R4, #+0]
   \   00000016   0xB118             CBZ.N    R0,??disk_ioctl_3
   \   00000018   0x2802             CMP      R0,#+2
   \   0000001A   0xD00D             BEQ.N    ??disk_ioctl_4
   \   0000001C   0xD306             BCC.N    ??disk_ioctl_5
   \   0000001E   0xE0E9             B.N      ??disk_ioctl_6
    408                          case 0:     /* Sub control code == 0 (POWER_OFF) */   
    409                              if (chk_power())   
    410                                  MMC_POWEROFF();         /* Power off */   
   \                     ??disk_ioctl_3: (+1)
   \   00000020   0xF44F 0x6180      MOV      R1,#+1024
   \   00000024   0x....             LDR.N    R0,??DataTable8_2  ;; 0x40011400
   \   00000026   0x.... 0x....      BL       GPIO_SetBits
    411                              res = RES_OK;   
   \   0000002A   0xE0E1             B.N      ??disk_ioctl_7
    412                              break;   
    413                          case 1:     /* Sub control code == 1 (POWER_ON) */   
    414                              MMC_POWERON();              /* Power on */   
   \                     ??disk_ioctl_5: (+1)
   \   0000002C   0xF44F 0x6180      MOV      R1,#+1024
   \   00000030   0x....             LDR.N    R0,??DataTable8_2  ;; 0x40011400
   \   00000032   0x.... 0x....      BL       GPIO_ResetBits
    415                              res = RES_OK;   
   \   00000036   0xE0DB             B.N      ??disk_ioctl_7
    416                              break;   
    417                          case 2:     /* Sub control code == 2 (POWER_GET) */   
    418                              *(ptr+1) = (BYTE)chk_power();   
   \                     ??disk_ioctl_4: (+1)
   \   00000038   0x7066             STRB     R6,[R4, #+1]
    419                              res = RES_OK;   
   \   0000003A   0xE0D9             B.N      ??disk_ioctl_7
    420                              break;   
    421                          default :   
    422                              res = RES_PARERR;   
    423                      }   
    424                  }   
    425                  else {   
    426                      if (Stat & STA_NOINIT) return RES_NOTRDY;   
   \                     ??disk_ioctl_2: (+1)
   \   0000003C   0x....             LDR.N    R5,??DataTable8_1
   \   0000003E   0x7828             LDRB     R0,[R5, #+0]
   \   00000040   0x07C0             LSLS     R0,R0,#+31
   \   00000042   0xBF48             IT       MI 
   \   00000044   0x2003             MOVMI    R0,#+3
   \   00000046   0xF100 0x80DC      BMI.W    ??disk_ioctl_8
    427                 
    428                      switch (ctrl) {   
   \   0000004A   0x290E             CMP      R1,#+14
   \   0000004C   0xF200 0x80D2      BHI.W    ??disk_ioctl_6
   \   00000050   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??disk_ioctl_0:
   \   00000054   0x08 0x10          DC8      0x8,0x10,0x4B,0x4F
   \              0x4B 0x4F    
   \   00000058   0xD0 0xD0          DC8      0xD0,0xD0,0xD0,0xD0
   \              0xD0 0xD0    
   \   0000005C   0xD0 0xD0          DC8      0xD0,0xD0,0x99,0x9C
   \              0x99 0x9C    
   \   00000060   0xA3 0xAA          DC8      0xA3,0xAA,0xC1,0x0
   \              0xC1 0x00    
    429                          case CTRL_SYNC :        /* Make sure that no pending write process */   
    430                              MMC_SELECT();   
   \                     ??disk_ioctl_9: (+1)
   \   00000064   0x.... 0x....      BL       MSD_CS_Assert
    431                              if (Wait_Ready() == 0xFF)   
   \   00000068   0x.... 0x....      BL       Wait_Ready
   \   0000006C   0x28FF             CMP      R0,#+255
   \   0000006E   0xF040 0x80C2      BNE.W    ??disk_ioctl_10
    432                                  res = RES_OK;   
   \   00000072   0xE0BD             B.N      ??disk_ioctl_7
    433                              break;   
    434                 
    435                          case GET_SECTOR_COUNT : /* Get number of sectors on the disk (DWORD) */   
    436                              if ((Send_Command(CMD9, 0) == 0) && Receive_DataBlock(csd, 16)) {   
   \                     ??disk_ioctl_11: (+1)
   \   00000074   0x2100             MOVS     R1,#+0
   \   00000076   0x2049             MOVS     R0,#+73
   \   00000078   0x.... 0x....      BL       Send_Command
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xF040 0x80BA      BNE.W    ??disk_ioctl_10
   \   00000082   0x2110             MOVS     R1,#+16
   \   00000084   0x4668             MOV      R0,SP
   \   00000086   0x.... 0x....      BL       Receive_DataBlock
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xF000 0x80B3      BEQ.W    ??disk_ioctl_10
    437                                  if ((csd[0] >> 6) == 1) { /* SDC ver 2.00 */   
   \   00000090   0xF89D 0x3000      LDRB     R3,[SP, #+0]
   \   00000094   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   00000098   0xF89D 0x1009      LDRB     R1,[SP, #+9]
   \   0000009C   0x099B             LSRS     R3,R3,#+6
   \   0000009E   0x2B01             CMP      R3,#+1
   \   000000A0   0xD105             BNE.N    ??disk_ioctl_12
    438                                      csize = csd[9] + ((WORD)csd[8] << 8) + 1;   
    439                                      *(DWORD*)buff = (DWORD)csize << 10;   
   \   000000A2   0xEB01 0x2002      ADD      R0,R1,R2, LSL #+8
   \   000000A6   0x1C40             ADDS     R0,R0,#+1
   \   000000A8   0x0400             LSLS     R0,R0,#+16
   \   000000AA   0x0980             LSRS     R0,R0,#+6
   \   000000AC   0xE01B             B.N      ??disk_ioctl_13
    440                                  } else {                    /* SDC ver 1.XX or MMC*/   
    441                                      n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;   
    442                                      csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;   
    443                                      *(DWORD*)buff = (DWORD)csize << (n - 9);   
   \                     ??disk_ioctl_12: (+1)
   \   000000AE   0xF89D 0x3007      LDRB     R3,[SP, #+7]
   \   000000B2   0xF89D 0x000A      LDRB     R0,[SP, #+10]
   \   000000B6   0x0992             LSRS     R2,R2,#+6
   \   000000B8   0xEB02 0x0283      ADD      R2,R2,R3, LSL #+2
   \   000000BC   0xF89D 0x3006      LDRB     R3,[SP, #+6]
   \   000000C0   0xF003 0x0303      AND      R3,R3,#0x3
   \   000000C4   0xEB02 0x2283      ADD      R2,R2,R3, LSL #+10
   \   000000C8   0xF89D 0x3005      LDRB     R3,[SP, #+5]
   \   000000CC   0xF003 0x030F      AND      R3,R3,#0xF
   \   000000D0   0xEB03 0x10D0      ADD      R0,R3,R0, LSR #+7
   \   000000D4   0xF001 0x0103      AND      R1,R1,#0x3
   \   000000D8   0x1C52             ADDS     R2,R2,#+1
   \   000000DA   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \   000000DE   0xB292             UXTH     R2,R2
   \   000000E0   0x1FC0             SUBS     R0,R0,#+7
   \   000000E2   0xFA02 0xF000      LSL      R0,R2,R0
   \                     ??disk_ioctl_13: (+1)
   \   000000E6   0x6020             STR      R0,[R4, #+0]
    444                                  }   
    445                                  res = RES_OK;   
   \   000000E8   0xE082             B.N      ??disk_ioctl_7
    446                              }   
    447                              break;   
    448                 
    449                          case GET_SECTOR_SIZE :  /* Get R/W sector size (WORD) */   
    450                              *(WORD*)buff = 512;   
   \                     ??disk_ioctl_14: (+1)
   \   000000EA   0xF44F 0x7000      MOV      R0,#+512
   \   000000EE   0x8020             STRH     R0,[R4, #+0]
    451                              res = RES_OK;   
   \   000000F0   0xE07E             B.N      ??disk_ioctl_7
    452                              break;   
    453                 
    454                          case GET_BLOCK_SIZE :   /* Get erase block size in unit of sector (DWORD) */   
    455                              if (CardType & 4) {         /* SDC ver 2.00 */   
   \                     ??disk_ioctl_15: (+1)
   \   000000F2   0x7868             LDRB     R0,[R5, #+1]
   \   000000F4   0x0740             LSLS     R0,R0,#+29
   \   000000F6   0xD51B             BPL.N    ??disk_ioctl_16
    456                                  if (Send_Command(ACMD13, 0) == 0) {     /* Read SD status */   
   \   000000F8   0x2100             MOVS     R1,#+0
   \   000000FA   0x20CD             MOVS     R0,#+205
   \   000000FC   0x.... 0x....      BL       Send_Command
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD178             BNE.N    ??disk_ioctl_10
    457                                      SPI_ReadWrite_Byte(0xff);   
   \   00000104   0x20FF             MOVS     R0,#+255
   \   00000106   0x.... 0x....      BL       SPI2_SendByte
    458                                      if (Receive_DataBlock(csd, 16)) {               /* Read partial block */   
   \   0000010A   0x2110             MOVS     R1,#+16
   \   0000010C   0x4668             MOV      R0,SP
   \   0000010E   0x.... 0x....      BL       Receive_DataBlock
   \   00000112   0x2800             CMP      R0,#+0
   \   00000114   0xD06F             BEQ.N    ??disk_ioctl_10
    459                                          for (n = 64 - 16; n; n--) SPI_ReadWrite_Byte(0xff); /* Purge trailing data */   
   \   00000116   0x2530             MOVS     R5,#+48
   \                     ??disk_ioctl_17: (+1)
   \   00000118   0x20FF             MOVS     R0,#+255
   \   0000011A   0x.... 0x....      BL       SPI2_SendByte
   \   0000011E   0x1E6D             SUBS     R5,R5,#+1
   \   00000120   0xD1FA             BNE.N    ??disk_ioctl_17
    460                                          *(DWORD*)buff = 16UL << (csd[10] >> 4);   
   \   00000122   0xF89D 0x100A      LDRB     R1,[SP, #+10]
   \   00000126   0x2010             MOVS     R0,#+16
   \   00000128   0x0909             LSRS     R1,R1,#+4
   \   0000012A   0x4088             LSLS     R0,R0,R1
   \   0000012C   0x6020             STR      R0,[R4, #+0]
    461                                          res = RES_OK;   
   \   0000012E   0xE05F             B.N      ??disk_ioctl_7
    462                                      }   
    463                                  }   
    464                              } else {                    /* SDC ver 1.XX or MMC */   
    465                                  if ((Send_Command(CMD9, 0) == 0) && Receive_DataBlock(csd, 16)) {   /* Read CSD */   
   \                     ??disk_ioctl_16: (+1)
   \   00000130   0x2100             MOVS     R1,#+0
   \   00000132   0x2049             MOVS     R0,#+73
   \   00000134   0x.... 0x....      BL       Send_Command
   \   00000138   0x2800             CMP      R0,#+0
   \   0000013A   0xD15C             BNE.N    ??disk_ioctl_10
   \   0000013C   0x2110             MOVS     R1,#+16
   \   0000013E   0x4668             MOV      R0,SP
   \   00000140   0x.... 0x....      BL       Receive_DataBlock
   \   00000144   0x2800             CMP      R0,#+0
   \   00000146   0xD056             BEQ.N    ??disk_ioctl_10
    466                                      if (CardType & 2) {         /* SDC ver 1.XX */   
   \   00000148   0x786A             LDRB     R2,[R5, #+1]
   \   0000014A   0xF89D 0x100B      LDRB     R1,[SP, #+11]
   \   0000014E   0xF89D 0x000A      LDRB     R0,[SP, #+10]
   \   00000152   0x0792             LSLS     R2,R2,#+30
   \   00000154   0xD50B             BPL.N    ??disk_ioctl_18
    467                                          *(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);   
   \   00000156   0xF000 0x003F      AND      R0,R0,#0x3F
   \   0000015A   0x09C9             LSRS     R1,R1,#+7
   \   0000015C   0xEB01 0x0040      ADD      R0,R1,R0, LSL #+1
   \   00000160   0xF89D 0x100D      LDRB     R1,[SP, #+13]
   \   00000164   0x0989             LSRS     R1,R1,#+6
   \   00000166   0x1C40             ADDS     R0,R0,#+1
   \   00000168   0x1E49             SUBS     R1,R1,#+1
   \   0000016A   0x4088             LSLS     R0,R0,R1
   \   0000016C   0xE009             B.N      ??disk_ioctl_19
    468                                      } else {                    /* MMC */   
    469                                          *(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);   
   \                     ??disk_ioctl_18: (+1)
   \   0000016E   0xF001 0x0203      AND      R2,R1,#0x3
   \   00000172   0x0949             LSRS     R1,R1,#+5
   \   00000174   0xF3C0 0x0084      UBFX     R0,R0,#+2,#+5
   \   00000178   0xEB01 0x01C2      ADD      R1,R1,R2, LSL #+3
   \   0000017C   0x1C40             ADDS     R0,R0,#+1
   \   0000017E   0x1C49             ADDS     R1,R1,#+1
   \   00000180   0x4348             MULS     R0,R1,R0
   \                     ??disk_ioctl_19: (+1)
   \   00000182   0x6020             STR      R0,[R4, #+0]
    470                                      }   
    471                                      res = RES_OK;   
   \   00000184   0xE034             B.N      ??disk_ioctl_7
    472                                  }   
    473                              }   
    474                              break;   
    475                 
    476                          case MMC_GET_TYPE :     /* Get card type flags (1 byte) */   
    477                              *ptr = CardType;   
   \                     ??disk_ioctl_20: (+1)
   \   00000186   0x7868             LDRB     R0,[R5, #+1]
   \   00000188   0x7020             STRB     R0,[R4, #+0]
    478                              res = RES_OK;   
   \   0000018A   0xE031             B.N      ??disk_ioctl_7
    479                              break;   
    480                 
    481                          case MMC_GET_CSD :      /* Receive CSD as a data block (16 bytes) */   
    482                              if (Send_Command(CMD9, 0) == 0      /* READ_CSD */   
    483                                      && Receive_DataBlock(ptr, 16))   
   \                     ??disk_ioctl_21: (+1)
   \   0000018C   0x2100             MOVS     R1,#+0
   \   0000018E   0x2049             MOVS     R0,#+73
   \   00000190   0x.... 0x....      BL       Send_Command
   \   00000194   0xBB78             CBNZ.N   R0,??disk_ioctl_10
   \   00000196   0x2110             MOVS     R1,#+16
   \   00000198   0xE026             B.N      ??disk_ioctl_22
    484                                  res = RES_OK;   
    485                              break;   
    486                 
    487                          case MMC_GET_CID :      /* Receive CID as a data block (16 bytes) */   
    488                              if (Send_Command(CMD10, 0) == 0     /* READ_CID */   
    489                                      && Receive_DataBlock(ptr, 16))   
   \                     ??disk_ioctl_23: (+1)
   \   0000019A   0x2100             MOVS     R1,#+0
   \   0000019C   0x204A             MOVS     R0,#+74
   \   0000019E   0x.... 0x....      BL       Send_Command
   \   000001A2   0xBB40             CBNZ.N   R0,??disk_ioctl_10
   \   000001A4   0x2110             MOVS     R1,#+16
   \   000001A6   0xE01F             B.N      ??disk_ioctl_22
    490                                  res = RES_OK;   
    491                              break;   
    492                 
    493                          case MMC_GET_OCR :      /* Receive OCR as an R3 resp (4 bytes) */   
    494                              if (Send_Command(CMD58, 0) == 0) {  /* READ_OCR */   
   \                     ??disk_ioctl_24: (+1)
   \   000001A8   0x2100             MOVS     R1,#+0
   \   000001AA   0x207A             MOVS     R0,#+122
   \   000001AC   0x.... 0x....      BL       Send_Command
   \   000001B0   0xBB08             CBNZ.N   R0,??disk_ioctl_10
    495                                  for (n = 4; n; n--) *ptr++ = SPI_ReadWrite_Byte(0xff);   
   \   000001B2   0x20FF             MOVS     R0,#+255
   \   000001B4   0x.... 0x....      BL       SPI2_SendByte
   \   000001B8   0x7020             STRB     R0,[R4, #+0]
   \   000001BA   0x20FF             MOVS     R0,#+255
   \   000001BC   0x.... 0x....      BL       SPI2_SendByte
   \   000001C0   0x7060             STRB     R0,[R4, #+1]
   \   000001C2   0x20FF             MOVS     R0,#+255
   \   000001C4   0x.... 0x....      BL       SPI2_SendByte
   \   000001C8   0xF804 0x0F02      STRB     R0,[R4, #+2]!
   \   000001CC   0x20FF             MOVS     R0,#+255
   \   000001CE   0x.... 0x....      BL       SPI2_SendByte
   \   000001D2   0x7060             STRB     R0,[R4, #+1]
    496                                  res = RES_OK;   
   \   000001D4   0xE00C             B.N      ??disk_ioctl_7
    497                              }   
    498                              break;   
    499                 
    500                          case MMC_GET_SDSTAT :   /* Receive SD statsu as a data block (64 bytes) */   
    501                              if (Send_Command(ACMD13, 0) == 0) { /* SD_STATUS */   
   \                     ??disk_ioctl_25: (+1)
   \   000001D6   0x2100             MOVS     R1,#+0
   \   000001D8   0x20CD             MOVS     R0,#+205
   \   000001DA   0x.... 0x....      BL       Send_Command
   \   000001DE   0xB950             CBNZ.N   R0,??disk_ioctl_10
    502                                  SPI_ReadWrite_Byte(0xff);   
   \   000001E0   0x20FF             MOVS     R0,#+255
   \   000001E2   0x.... 0x....      BL       SPI2_SendByte
    503                                  if (Receive_DataBlock(ptr, 64))   
   \   000001E6   0x2140             MOVS     R1,#+64
   \                     ??disk_ioctl_22: (+1)
   \   000001E8   0x4620             MOV      R0,R4
   \   000001EA   0x.... 0x....      BL       Receive_DataBlock
   \   000001EE   0xB110             CBZ.N    R0,??disk_ioctl_10
    504                                      res = RES_OK;   
   \                     ??disk_ioctl_7: (+1)
   \   000001F0   0x2600             MOVS     R6,#+0
   \   000001F2   0xE000             B.N      ??disk_ioctl_10
    505                              }   
    506                              break;   
    507                 
    508                          default:   
    509                              res = RES_PARERR;   
   \                     ??disk_ioctl_6: (+1)
   \   000001F4   0x2604             MOVS     R6,#+4
    510                      }   
    511                 
    512                  }   
    513                     
    514                  SPI_Release();   
   \                     ??disk_ioctl_10: (+1)
   \   000001F6   0x.... 0x....      BL       MSD_CS_Deassert
   \   000001FA   0x20FF             MOVS     R0,#+255
   \   000001FC   0x.... 0x....      BL       SPI2_SendByte
    515                  return res;   
   \   00000200   0x4630             MOV      R0,R6
   \                     ??disk_ioctl_8: (+1)
   \   00000202   0xB004             ADD      SP,SP,#+16
   \   00000204   0xBD70             POP      {R4-R6,PC}       ;; return
    516              }   
    517              #endif /* _USE_IOCTL != 0 */   
    518                 

   \                                 In section .text, align 2, keep-with-next
    519              DWORD get_fattime (void)   
    520              {   
    521                  return 0;     
   \                     get_fattime: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    522              }   

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     Timer2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     Stat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x49 0x6E          DC8 "Initialization succeded.\012"
   \              0x69 0x74    
   \              0x69 0x61    
   \              0x6C 0x69    
   \              0x7A 0x61    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x20 0x73    
   \              0x75 0x63    
   \              0x63 0x65    
   \              0x64 0x65    
   \              0x64 0x2E    
   \              0x0A 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x49 0x6E          DC8 "Initialization failed.\012"
   \              0x69 0x74    
   \              0x69 0x61    
   \              0x6C 0x69    
   \              0x7A 0x61    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x2E    
   \              0x0A 0x00    
    523              /*-----------------------------------------------------------------------*/   
    524              /* Device Timer Interrupt Procedure  (Platform dependent)                */   
    525              /*-----------------------------------------------------------------------*/   
    526              /* This function must be called in period of 10ms                        */   
    527                 
    528              /*  
    529                 void disk_timerproc (void)  
    530                 {  
    531                 static BYTE pv;  
    532                 BYTE n, s;  
    533                
    534                
    535                 n = Timer1;                          // 100Hz decrement timer  
    536                 if (n) Timer1 = --n;  
    537                 n = Timer2;  
    538                 if (n) Timer2 = --n;  
    539                
    540                 n = pv;  
    541                 pv = SOCKPORT & (SOCKWP | SOCKINS);  // Sample socket switch   
    542                
    543                 if (n == pv) {                       // Have contacts stabled?   
    544                 s = Stat;  
    545                
    546                 if (pv & SOCKWP)         // WP is H (write protected)   
    547                 s |= STA_PROTECT;  
    548                 else                     // WP is L (write enabled)   
    549                 s &= ~STA_PROTECT;  
    550                
    551                 if (pv & SOCKINS)            // INS = H (Socket empty)   
    552                 s |= (STA_NODISK | STA_NOINIT);  
    553                 else                     // INS = L (Card inserted)   
    554                 s &= ~STA_NODISK;  
    555                
    556                 Stat = s;  
    557                 }  
    558                 }  
    559                 */   
    560          
    561          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   Receive_DataBlock
        16   -> SPI2_SendByte
      16   Send_Command
        16   -> MSD_CS_Assert
        16   -> MSD_CS_Deassert
        16   -> SPI2_SendByte
        16   -> Send_Command
        16   -> Wait_Ready
      16   Transmit_DataBlock
        16   -> SPI2_SendByte
        16   -> Wait_Ready
       8   Wait_Ready
         8   -> SPI2_SendByte
       0   chk_power
      24   disk_initialize
        24   -> MSD_CS_Assert
        24   -> MSD_CS_Deassert
        24   -> SPI2_SendByte
        24   -> Send_Command
        24   -> Wait_Ready
        24   -> printf
      32   disk_ioctl
        32   -> GPIO_ResetBits
        32   -> GPIO_SetBits
        32   -> MSD_CS_Assert
        32   -> MSD_CS_Deassert
        32   -> Receive_DataBlock
        32   -> SPI2_SendByte
        32   -> Send_Command
        32   -> Wait_Ready
      24   disk_read
        24   -> MSD_CS_Deassert
        24   -> Receive_DataBlock
        24   -> SPI2_SendByte
        24   -> Send_Command
       0   disk_status
      24   disk_write
        24   -> MSD_CS_Deassert
        24   -> SPI2_SendByte
        24   -> Send_Command
        24   -> Transmit_DataBlock
        24   -> Wait_Ready
       0   get_fattime


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
      28  ?_0
      24  ?_1
      76  Receive_DataBlock
     128  Send_Command
       8  Stat
          CardType
          Timer1
       4  Timer2
      74  Transmit_DataBlock
      34  Wait_Ready
       4  chk_power
     374  disk_initialize
     518  disk_ioctl
     184  disk_read
      14  disk_status
     210  disk_write
       4  get_fattime

 
     4 bytes in section .bss
     8 bytes in section .data
 1 684 bytes in section .text
 
 1 684 bytes of CODE memory
    12 bytes of DATA memory

Errors: none
Warnings: none
