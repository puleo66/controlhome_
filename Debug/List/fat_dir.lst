###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       09/Feb/2018  16:14:50
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\HW Projects\ControlHome\CntrHome - RF69w\uC-FatFS\fsl\fat\fat_dir.c
#    Command line =  
#        "E:\HW Projects\ControlHome\CntrHome -
#        RF69w\uC-FatFS\fsl\fat\fat_dir.c" -lCN "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Debug\List" -o "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Debug\Obj" --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\APP\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\BSP\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\CPU\inc\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-CPU\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-RTC\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-LIB\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uCOS-II\Ports\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uCOS-II\Source\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\I2C-Out\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Direct_Sw\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Wdt_led\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-LCD\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-RF\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\api\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\config\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\os\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\fsl\fat\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\clib\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\lbl\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\device\mmc\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\file\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-Terminal\src\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-Terminal\inc\" -Oh
#    List file    =  
#        E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\List\fat_dir.lst
#    Object file  =  
#        E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\Obj\fat_dir.o
#
###############################################################################

E:\HW Projects\ControlHome\CntrHome - RF69w\uC-FatFS\fsl\fat\fat_dir.c
      1          /*
      2          **********************************************************************
      3          *                          Micrium, Inc.
      4          *                      949 Crestview Circle
      5          *                     Weston,  FL 33327-1848
      6          *
      7          *                            uC/FS
      8          *
      9          *             (c) Copyright 2001 - 2003, Micrium, Inc.
     10          *                      All rights reserved.
     11          *
     12          ***********************************************************************
     13          
     14          ----------------------------------------------------------------------
     15          File        : fat_dir.c
     16          Purpose     : POSIX 1003.1 like directory support
     17          ----------------------------------------------------------------------
     18          Known problems or limitations with current version
     19          ----------------------------------------------------------------------
     20          None.
     21          ---------------------------END-OF-HEADER------------------------------
     22          */
     23          
     24          /*********************************************************************
     25          *
     26          *             #include Section
     27          *
     28          **********************************************************************
     29          */
     30          
     31          #include "fs_conf.h"
     32          #include "fs_port.h"
     33          #include "fs_dev.h"
     34          #include "fs_api.h"
     35          #include "fs_fsl.h"
     36          #include "fs_int.h"
     37          #include "fs_os.h"
     38          #include "fs_lbl.h"
     39          #include "fs_fat.h"
     40          #include "fs_clib.h"
     41          
     42          #if FS_POSIX_DIR_SUPPORT
     43          
     44          
     45          /*********************************************************************
     46          *
     47          *             _FS_fat_create_directory
     48          *
     49            Description:
     50            FS internal function. Create a directory in the directory specified
     51            with DirStart. Do not call, if you have not checked before for 
     52            existing directory with name pDirName.
     53          
     54            Parameters:
     55            Idx         - Index of device in the device information table 
     56                          referred by FS__pDevInfo.
     57            Unit        - Unit number, which is passed to the device driver.
     58            pDirName    - Directory name. 
     59            DirStart    - Start of directory, where to create pDirName.
     60            DirSize     - Size of the directory starting at DirStart.
     61            
     62            Return value:
     63            >=0         - Directory has been created.
     64            <0          - An error has occured.
     65          */
     66          

   \                                 In section .text, align 2, keep-with-next
     67          static int _FS_fat_create_directory(int Idx, FS_u32 Unit, const char *pDirName,
     68                                              FS_u32 DirStart, FS_u32 DirSize) {
   \                     _FS_fat_create_directory: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x468A             MOV      R10,R1
   \   00000008   0x4693             MOV      R11,R2
   \   0000000A   0x461E             MOV      R6,R3
     69            char *buffer;
     70            FS__fat_dentry_type *s;
     71            FS_u32 dirindex;
     72            FS_u32 dsec;
     73            FS_i32 cluster;
     74            FS_u16 val_time;
     75            FS_u16 val_date;
     76            int err;
     77            int len;
     78            int j;
     79          
     80            buffer = FS__fat_malloc(FS_FAT_SEC_SIZE);
   \   0000000C   0xF44F 0x7000      MOV      R0,#+512
   \   00000010   0x.... 0x....      BL       FS__fat_malloc
   \   00000014   0x0004             MOVS     R4,R0
     81            if (!buffer) {
   \   00000016   0xF000 0x8111      BEQ.W    ??_FS_fat_create_directory_0
     82              return -1;
     83            }
     84            len = FS__CLIB_strlen(pDirName);
   \   0000001A   0x4658             MOV      R0,R11
   \   0000001C   0x.... 0x....      BL       FS__CLIB_strlen
   \   00000020   0x4607             MOV      R7,R0
     85            if (len > 11) {
   \   00000022   0x2F0C             CMP      R7,#+12
   \   00000024   0xBFA8             IT       GE 
   \   00000026   0x270B             MOVGE    R7,#+11
     86              len = 11;
     87            }
     88            /* Read directory */
     89            for (dirindex = 0; dirindex < DirSize; dirindex++) {
   \   00000028   0x980E             LDR      R0,[SP, #+56]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xF04F 0x0800      MOV      R8,#+0
   \   00000030   0xF000 0x810D      BEQ.W    ??_FS_fat_create_directory_1
     90              dsec = FS__fat_dir_realsec(Idx, Unit, DirStart, dirindex);
   \                     ??_FS_fat_create_directory_2: (+1)
   \   00000034   0x9804             LDR      R0,[SP, #+16]
   \   00000036   0x4643             MOV      R3,R8
   \   00000038   0x4632             MOV      R2,R6
   \   0000003A   0x4651             MOV      R1,R10
   \   0000003C   0x.... 0x....      BL       FS__fat_dir_realsec
   \   00000040   0xEA5F 0x0900      MOVS     R9,R0
     91              if (dsec == 0) {
   \   00000044   0xF000 0x80F7      BEQ.W    ??_FS_fat_create_directory_3
     92                /* Translation of relativ directory sector to an absolute sector failed */
     93                FS__fat_free(buffer);
     94                return -1;
     95              }
     96              err = FS__lb_read(FS__pDevInfo[Idx].devdriver, Unit, dsec, (void*)buffer); /* Read directory sector */
     97              if (err < 0) {
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable5
   \   0000004C   0x9904             LDR      R1,[SP, #+16]
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xEB00 0x1001      ADD      R0,R0,R1, LSL #+4
   \   00000054   0x9001             STR      R0,[SP, #+4]
   \   00000056   0x4623             MOV      R3,R4
   \   00000058   0x6880             LDR      R0,[R0, #+8]
   \   0000005A   0x464A             MOV      R2,R9
   \   0000005C   0x4651             MOV      R1,R10
   \   0000005E   0x.... 0x....      BL       FS__lb_read
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xF100 0x80E7      BMI.W    ??_FS_fat_create_directory_3
     98                /* Read error */
     99                FS__fat_free(buffer);
    100                return -1;
    101              }
    102              /* Scan the directory sector for a free or deleted entry */
    103              s = (FS__fat_dentry_type*)buffer;
   \   00000068   0x4625             MOV      R5,R4
   \   0000006A   0xE000             B.N      ??_FS_fat_create_directory_4
    104              while (1) {
    105                if (s >= (FS__fat_dentry_type*)(buffer + FS_FAT_SEC_SIZE)) {
    106                  break;  /* End of sector reached */
    107                }
    108                if (s->data[0] == 0x00) {
    109                  break;  /* Found a free entry */
    110                }
    111                if (s->data[0] == (unsigned char)0xe5) {
    112                  break;  /* Found a deleted entry */
    113                }
    114                s++;
   \                     ??_FS_fat_create_directory_5: (+1)
   \   0000006C   0x3520             ADDS     R5,R5,#+32
   \                     ??_FS_fat_create_directory_4: (+1)
   \   0000006E   0x4628             MOV      R0,R5
   \   00000070   0xF504 0x7100      ADD      R1,R4,#+512
   \   00000074   0x4288             CMP      R0,R1
   \   00000076   0xD204             BCS.N    ??_FS_fat_create_directory_6
   \   00000078   0x7829             LDRB     R1,[R5, #+0]
   \   0000007A   0x2900             CMP      R1,#+0
   \   0000007C   0xBF18             IT       NE 
   \   0000007E   0x29E5             CMPNE    R1,#+229
   \   00000080   0xD1F4             BNE.N    ??_FS_fat_create_directory_5
    115              }
    116              if (s < (FS__fat_dentry_type*)(buffer + FS_FAT_SEC_SIZE)) {
   \                     ??_FS_fat_create_directory_6: (+1)
   \   00000082   0xF504 0x7100      ADD      R1,R4,#+512
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xF080 0x80DB      BCS.W    ??_FS_fat_create_directory_7
    117                /* Free entry found. Make entry and return 1st block of the file. */
    118                FS__CLIB_strncpy((char*)s->data, pDirName, len);
   \   0000008C   0x463A             MOV      R2,R7
   \   0000008E   0x4659             MOV      R1,R11
   \   00000090   0x.... 0x....      BL       FS__CLIB_strncpy
    119                 s->data[11] = FS_FAT_ATTR_DIRECTORY;
   \   00000094   0x2010             MOVS     R0,#+16
   \   00000096   0x72E8             STRB     R0,[R5, #+11]
    120                cluster = FS__fat_FAT_alloc(Idx, Unit, -1);              /* Alloc block in FAT */
   \   00000098   0xF04F 0x32FF      MOV      R2,#-1
   \   0000009C   0x9804             LDR      R0,[SP, #+16]
   \   0000009E   0x4651             MOV      R1,R10
   \   000000A0   0x.... 0x....      BL       FS__fat_FAT_alloc
   \   000000A4   0xEA5F 0x0B00      MOVS     R11,R0
    121                if (cluster >= 0) {
   \   000000A8   0xF100 0x80C5      BMI.W    ??_FS_fat_create_directory_3
    122                  s->data[12]     = 0x00;                                /* Res */
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x7328             STRB     R0,[R5, #+12]
    123                  s->data[13]     = 0x00;                                /* CrtTimeTenth (optional, not supported) */
   \   000000B0   0x7368             STRB     R0,[R5, #+13]
    124                  s->data[14]     = 0x00;                                /* CrtTime (optional, not supported) */
   \   000000B2   0x73A8             STRB     R0,[R5, #+14]
    125                  s->data[15]     = 0x00;
   \   000000B4   0x73E8             STRB     R0,[R5, #+15]
    126                  s->data[16]     = 0x00;                                /* CrtDate (optional, not supported) */
   \   000000B6   0x7428             STRB     R0,[R5, #+16]
    127                  s->data[17]     = 0x00;
   \   000000B8   0x7468             STRB     R0,[R5, #+17]
    128                  s->data[18]     = 0x00;                                /* LstAccDate (optional, not supported) */
   \   000000BA   0x74A8             STRB     R0,[R5, #+18]
    129                  s->data[19]     = 0x00;
   \   000000BC   0x74E8             STRB     R0,[R5, #+19]
    130                  val_time        = FS_X_OS_GetTime();
   \   000000BE   0x.... 0x....      BL       FS_X_OS_GetTime
   \   000000C2   0x4607             MOV      R7,R0
    131                  s->data[22]     = (unsigned char)(val_time & 0xff);   /* WrtTime */
    132                  s->data[23]     = (unsigned char)(val_time / 256);
   \   000000C4   0x09F8             LSRS     R0,R7,#+7
   \   000000C6   0xEB07 0x6010      ADD      R0,R7,R0, LSR #+24
   \   000000CA   0x75AF             STRB     R7,[R5, #+22]
   \   000000CC   0x0A00             LSRS     R0,R0,#+8
   \   000000CE   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   000000D2   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000000D6   0x75E8             STRB     R0,[R5, #+23]
    133                  val_date        = FS_X_OS_GetDate();
   \   000000D8   0x.... 0x....      BL       FS_X_OS_GetDate
   \   000000DC   0x4680             MOV      R8,R0
    134                  s->data[24]     = (unsigned char)(val_date & 0xff);   /* WrtDate */
    135                  s->data[25]     = (unsigned char)(val_date / 256);
   \   000000DE   0xEA4F 0x10D8      LSR      R0,R8,#+7
   \   000000E2   0xEB08 0x6010      ADD      R0,R8,R0, LSR #+24
   \   000000E6   0xF885 0x8018      STRB     R8,[R5, #+24]
   \   000000EA   0x0A00             LSRS     R0,R0,#+8
   \   000000EC   0xF88D 0x0000      STRB     R0,[SP, #+0]
    136                  s->data[26]     = (unsigned char)(cluster & 0xff);    /* FstClusLo / FstClusHi */ 
    137                  s->data[27]     = (unsigned char)((cluster / 256) & 0xff);
    138                  s->data[20]     = (unsigned char)((cluster / 0x10000L) & 0xff);
    139                  s->data[21]     = (unsigned char)((cluster / 0x1000000L) & 0xff);
    140                  s->data[28]     = 0x00;                                /* FileSize */
    141                  s->data[29]     = 0x00;
    142                  s->data[30]     = 0x00;
    143                  s->data[31]     = 0x00;
    144                  err = FS__lb_write(FS__pDevInfo[Idx].devdriver, Unit, dsec, (void*)buffer); /* Write the modified directory sector */
    145                  if (err < 0) {
   \   000000F0   0x4623             MOV      R3,R4
   \   000000F2   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000F6   0x7668             STRB     R0,[R5, #+25]
   \   000000F8   0xF885 0xB01A      STRB     R11,[R5, #+26]
   \   000000FC   0xEA4F 0x10EB      ASR      R0,R11,#+7
   \   00000100   0xEB0B 0x6010      ADD      R0,R11,R0, LSR #+24
   \   00000104   0x1200             ASRS     R0,R0,#+8
   \   00000106   0xF88D 0x0008      STRB     R0,[SP, #+8]
   \   0000010A   0x464A             MOV      R2,R9
   \   0000010C   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000110   0x76E8             STRB     R0,[R5, #+27]
   \   00000112   0x4651             MOV      R1,R10
   \   00000114   0xEA4F 0x30EB      ASR      R0,R11,#+15
   \   00000118   0xEB0B 0x4010      ADD      R0,R11,R0, LSR #+16
   \   0000011C   0x1400             ASRS     R0,R0,#+16
   \   0000011E   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   00000122   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   00000126   0x7528             STRB     R0,[R5, #+20]
   \   00000128   0xEA4F 0x50EB      ASR      R0,R11,#+23
   \   0000012C   0xEB0B 0x2010      ADD      R0,R11,R0, LSR #+8
   \   00000130   0x1600             ASRS     R0,R0,#+24
   \   00000132   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   00000136   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000013A   0x7568             STRB     R0,[R5, #+21]
   \   0000013C   0x2000             MOVS     R0,#+0
   \   0000013E   0x7728             STRB     R0,[R5, #+28]
   \   00000140   0x7768             STRB     R0,[R5, #+29]
   \   00000142   0x77A8             STRB     R0,[R5, #+30]
   \   00000144   0x77E8             STRB     R0,[R5, #+31]
   \   00000146   0x9801             LDR      R0,[SP, #+4]
   \   00000148   0x6880             LDR      R0,[R0, #+8]
   \   0000014A   0x.... 0x....      BL       FS__lb_write
   \   0000014E   0x2800             CMP      R0,#+0
   \   00000150   0xD471             BMI.N    ??_FS_fat_create_directory_3
    146                    FS__fat_free(buffer);
    147                    return -1;
    148                  }
    149                  /* Clear new directory and make '.' and '..' entries */
    150                  /* Make "." entry */
    151                  FS__CLIB_memset(buffer, 0x00, (FS_size_t)FS_FAT_SEC_SIZE);
   \   00000152   0xF44F 0x7200      MOV      R2,#+512
   \   00000156   0x2100             MOVS     R1,#+0
   \   00000158   0x4620             MOV      R0,R4
   \   0000015A   0x.... 0x....      BL       FS__CLIB_memset
    152                  s = (FS__fat_dentry_type*)buffer;
    153                  FS__CLIB_strncpy((char*)s->data, ".          ", 11);
   \   0000015E   0x220B             MOVS     R2,#+11
   \   00000160   0x.... 0x....      ADR.W    R1,?_0
   \   00000164   0x4620             MOV      R0,R4
   \   00000166   0x.... 0x....      BL       FS__CLIB_strncpy
    154                  s->data[11]     = FS_FAT_ATTR_DIRECTORY;
   \   0000016A   0x2010             MOVS     R0,#+16
   \   0000016C   0x72E0             STRB     R0,[R4, #+11]
    155                  s->data[22]     = (unsigned char)(val_time & 0xff);   /* WrtTime */
   \   0000016E   0x75A7             STRB     R7,[R4, #+22]
    156                  s->data[23]     = (unsigned char)(val_time / 256);
    157                  s->data[24]     = (unsigned char)(val_date & 0xff);   /* WrtDate */
    158                  s->data[25]     = (unsigned char)(val_date / 256);
    159                  s->data[26]     = (unsigned char)(cluster & 0xff);    /* FstClusLo / FstClusHi */ 
    160                  s->data[27]     = (unsigned char)((cluster / 256) & 0xff);
    161                  s->data[20]     = (unsigned char)((cluster / 0x10000L) & 0xff);
    162                  s->data[21]     = (unsigned char)((cluster / 0x1000000L) & 0xff);
    163                  /* Make entry ".." */
    164                  s++;
   \   00000170   0xF104 0x0520      ADD      R5,R4,#+32
   \   00000174   0xF89D 0x0001      LDRB     R0,[SP, #+1]
    165                  FS__CLIB_strncpy((char*)s->data, "..         ", 11);
   \   00000178   0x.... 0x....      ADR.W    R1,?_1
   \   0000017C   0x75E0             STRB     R0,[R4, #+23]
   \   0000017E   0xF884 0x8018      STRB     R8,[R4, #+24]
   \   00000182   0x220B             MOVS     R2,#+11
   \   00000184   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000188   0x7660             STRB     R0,[R4, #+25]
   \   0000018A   0xF884 0xB01A      STRB     R11,[R4, #+26]
   \   0000018E   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000192   0x76E0             STRB     R0,[R4, #+27]
   \   00000194   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   00000198   0x7520             STRB     R0,[R4, #+20]
   \   0000019A   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000019E   0x7560             STRB     R0,[R4, #+21]
   \   000001A0   0x4628             MOV      R0,R5
   \   000001A2   0x.... 0x....      BL       FS__CLIB_strncpy
    166                  s->data[11]     = FS_FAT_ATTR_DIRECTORY;
   \   000001A6   0x2010             MOVS     R0,#+16
   \   000001A8   0x72E8             STRB     R0,[R5, #+11]
    167                  s->data[22]     = (unsigned char)(val_time & 0xff);   /* WrtTime */
   \   000001AA   0x75AF             STRB     R7,[R5, #+22]
    168                  s->data[23]     = (unsigned char)(val_time / 256);
    169                  s->data[24]     = (unsigned char)(val_date & 0xff);   /* WrtDate */
    170                  s->data[25]     = (unsigned char)(val_date / 256);
    171                  s->data[26]     = (unsigned char)(DirStart & 0xff);    /* FstClusLo / FstClusHi */ 
    172                  s->data[27]     = (unsigned char)((DirStart / 256) & 0xff);
    173                  s->data[20]     = (unsigned char)((DirStart / 0x10000L) & 0xff);
    174                  s->data[21]     = (unsigned char)((DirStart / 0x1000000L) & 0xff);
    175                  dsec = FS__fat_dir_realsec(Idx, Unit, cluster, 0); /* Find 1st absolute sector of the new directory */
   \   000001AC   0x2300             MOVS     R3,#+0
   \   000001AE   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000001B2   0x75E8             STRB     R0,[R5, #+23]
   \   000001B4   0xF885 0x8018      STRB     R8,[R5, #+24]
   \   000001B8   0x465A             MOV      R2,R11
   \   000001BA   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000001BE   0x7668             STRB     R0,[R5, #+25]
   \   000001C0   0x76AE             STRB     R6,[R5, #+26]
   \   000001C2   0x0A30             LSRS     R0,R6,#+8
   \   000001C4   0x76E8             STRB     R0,[R5, #+27]
   \   000001C6   0x4651             MOV      R1,R10
   \   000001C8   0x0C30             LSRS     R0,R6,#+16
   \   000001CA   0x7528             STRB     R0,[R5, #+20]
   \   000001CC   0x0E30             LSRS     R0,R6,#+24
   \   000001CE   0x7568             STRB     R0,[R5, #+21]
   \   000001D0   0x9804             LDR      R0,[SP, #+16]
   \   000001D2   0x.... 0x....      BL       FS__fat_dir_realsec
    176                  if (dsec == 0) {
   \   000001D6   0xB370             CBZ.N    R0,??_FS_fat_create_directory_3
    177                    FS__fat_free(buffer);
    178                    return -1;
    179                  }
    180                  /* Write "." & ".." entries into the new directory */
    181                  err = FS__lb_write(FS__pDevInfo[Idx].devdriver, Unit, dsec, (void*)buffer);
    182                  if (err < 0) {
   \   000001D8   0x4602             MOV      R2,R0
   \   000001DA   0x9801             LDR      R0,[SP, #+4]
   \   000001DC   0x6880             LDR      R0,[R0, #+8]
   \   000001DE   0x4623             MOV      R3,R4
   \   000001E0   0x4651             MOV      R1,R10
   \   000001E2   0x.... 0x....      BL       FS__lb_write
   \   000001E6   0x2800             CMP      R0,#+0
   \   000001E8   0xD425             BMI.N    ??_FS_fat_create_directory_3
    183                    FS__fat_free(buffer);
    184                    return -1;
    185                  }
    186                  /* Clear rest of the directory cluster */
    187                  FS__CLIB_memset(buffer, 0x00, (FS_size_t)FS_FAT_SEC_SIZE);
   \   000001EA   0xF44F 0x7200      MOV      R2,#+512
   \   000001EE   0x2100             MOVS     R1,#+0
   \   000001F0   0x4620             MOV      R0,R4
   \   000001F2   0x.... 0x....      BL       FS__CLIB_memset
    188                  for (j = 1; j < FS__FAT_aBPBUnit[Idx][Unit].SecPerClus; j++) {
   \   000001F6   0x9904             LDR      R1,[SP, #+16]
   \   000001F8   0x....             LDR.N    R0,??DataTable5_1
   \   000001FA   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   000001FE   0x2601             MOVS     R6,#+1
   \   00000200   0xEB00 0x174A      ADD      R7,R0,R10, LSL #+5
   \   00000204   0xE00F             B.N      ??_FS_fat_create_directory_8
    189                    dsec = FS__fat_dir_realsec(Idx, Unit, cluster, j);
   \                     ??_FS_fat_create_directory_9: (+1)
   \   00000206   0x9804             LDR      R0,[SP, #+16]
   \   00000208   0x4633             MOV      R3,R6
   \   0000020A   0x465A             MOV      R2,R11
   \   0000020C   0x4651             MOV      R1,R10
   \   0000020E   0x.... 0x....      BL       FS__fat_dir_realsec
    190                    err = FS__lb_write(FS__pDevInfo[Idx].devdriver, Unit, dsec, (void*)buffer);
    191                    if (err < 0) {
   \   00000212   0x4602             MOV      R2,R0
   \   00000214   0x9801             LDR      R0,[SP, #+4]
   \   00000216   0x6880             LDR      R0,[R0, #+8]
   \   00000218   0x4623             MOV      R3,R4
   \   0000021A   0x4651             MOV      R1,R10
   \   0000021C   0x.... 0x....      BL       FS__lb_write
   \   00000220   0x2800             CMP      R0,#+0
   \   00000222   0xD408             BMI.N    ??_FS_fat_create_directory_3
    192                      FS__fat_free(buffer);
    193                      return -1;
    194                    }
    195                  }
   \   00000224   0x1C76             ADDS     R6,R6,#+1
   \                     ??_FS_fat_create_directory_8: (+1)
   \   00000226   0x7F38             LDRB     R0,[R7, #+28]
   \   00000228   0x4286             CMP      R6,R0
   \   0000022A   0xDBEC             BLT.N    ??_FS_fat_create_directory_9
    196                  FS__fat_free(buffer);
   \   0000022C   0x4620             MOV      R0,R4
   \   0000022E   0x.... 0x....      BL       FS__fat_free
    197                  return 1;
   \   00000232   0x2001             MOVS     R0,#+1
   \   00000234   0x....             B.N      ?Subroutine0
    198          
    199                }
    200                FS__fat_free(buffer);
   \                     ??_FS_fat_create_directory_3: (+1)
   \   00000236   0x4620             MOV      R0,R4
   \   00000238   0x.... 0x....      BL       FS__fat_free
    201                return -1;
   \                     ??_FS_fat_create_directory_0: (+1)
   \   0000023C   0xF04F 0x30FF      MOV      R0,#-1
    202              }
    203            }
   \   00000240   0x....             B.N      ?Subroutine0
   \                     ??_FS_fat_create_directory_7: (+1)
   \   00000242   0x980E             LDR      R0,[SP, #+56]
   \   00000244   0xF108 0x0801      ADD      R8,R8,#+1
   \   00000248   0x4580             CMP      R8,R0
   \   0000024A   0xF4FF 0xAEF3      BCC.W    ??_FS_fat_create_directory_2
    204            FS__fat_free(buffer);
   \                     ??_FS_fat_create_directory_1: (+1)
   \   0000024E   0x4620             MOV      R0,R4
   \   00000250   0x.... 0x....      BL       FS__fat_free
    205            return -2;  /* Directory is full */
   \   00000254   0xF06F 0x0001      MVN      R0,#+1
   \   00000258                      REQUIRE ?Subroutine0
   \   00000258                      ;; // Fall through to label ?Subroutine0
    206          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xB005             ADD      SP,SP,#+20
   \   00000002   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    207          
    208          
    209          /*********************************************************************
    210          *
    211          *             Global functions
    212          *
    213          **********************************************************************
    214          */
    215          
    216          /*********************************************************************
    217          *
    218          *             FS__fat_opendir
    219          *
    220            Description:
    221            FS internal function. Open an existing directory for reading.
    222          
    223            Parameters:
    224            pDirName    - Directory name. 
    225            pDir        - Pointer to a FS_DIR data structure. 
    226            
    227            Return value:
    228            ==0         - Unable to open the directory.
    229            !=0         - Address of an FS_DIR data structure.
    230          */
    231          

   \                                 In section .text, align 2, keep-with-next
    232          FS_DIR *FS__fat_opendir(const char *pDirName, FS_DIR *pDir) {
   \                     FS__fat_opendir: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xEA5F 0x0801      MOVS     R8,R1
   \   00000008   0xB088             SUB      SP,SP,#+32
    233            FS_size_t len;
    234            FS_u32 unit;
    235            FS_u32 dstart;
    236            FS_u32 dsize;
    237            FS_i32 i;
    238            char realname[12];
    239            char *filename;
    240          
    241            if (!pDir) {
   \   0000000A   0xD040             BEQ.N    ??FS__fat_opendir_0
    242              return 0;  /* No valid pointer to a FS_DIR structure */
    243            }
    244            /* Find path on the media and return file name part of the complete path */
    245            dsize = FS__fat_findpath(pDir->dev_index, pDirName, &filename, &unit, &dstart); 
   \   0000000C   0xA902             ADD      R1,SP,#+8
   \   0000000E   0x9100             STR      R1,[SP, #+0]
   \   00000010   0xF508 0x7582      ADD      R5,R8,#+260
   \   00000014   0x4601             MOV      R1,R0
   \   00000016   0x6968             LDR      R0,[R5, #+20]
   \   00000018   0xAB01             ADD      R3,SP,#+4
   \   0000001A   0xAA03             ADD      R2,SP,#+12
   \   0000001C   0x.... 0x....      BL       FS__fat_findpath
   \   00000020   0x0006             MOVS     R6,R0
    246            if (dsize == 0) {
   \   00000022   0xD034             BEQ.N    ??FS__fat_opendir_0
    247              return 0;  /* Directory not found */
    248            }
    249            FS__lb_ioctl(FS__pDevInfo[pDir->dev_index].devdriver, unit, FS_CMD_INC_BUSYCNT, 0, (void*)0); /* Turn on busy signal */
   \   00000024   0x....             LDR.N    R0,??DataTable5
   \   00000026   0x6807             LDR      R7,[R0, #+0]
   \   00000028   0x9901             LDR      R1,[SP, #+4]
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x9000             STR      R0,[SP, #+0]
   \   0000002E   0x2300             MOVS     R3,#+0
   \   00000030   0x6968             LDR      R0,[R5, #+20]
   \   00000032   0xEB07 0x1000      ADD      R0,R7,R0, LSL #+4
   \   00000036   0xF640 0x32B9      MOVW     R2,#+3001
   \   0000003A   0x6880             LDR      R0,[R0, #+8]
   \   0000003C   0x.... 0x....      BL       FS__lb_ioctl
    250            len = FS__CLIB_strlen(filename);
    251            if (len != 0) {
   \   00000040   0x9803             LDR      R0,[SP, #+12]
   \   00000042   0x.... 0x....      BL       FS__CLIB_strlen
   \   00000046   0xB168             CBZ.N    R0,??FS__fat_opendir_1
    252              /* There is a name in the complete path (it does not end with a '\') */
    253              FS__fat_make_realname(realname, filename);  /* Convert name to FAT real name */
   \   00000048   0x9903             LDR      R1,[SP, #+12]
   \   0000004A   0xA804             ADD      R0,SP,#+16
   \   0000004C   0x.... 0x....      BL       FS__fat_make_realname
    254              i =  FS__fat_find_dir(pDir->dev_index, unit, realname, dstart, dsize);  /* Search name in the directory */
   \   00000050   0x9600             STR      R6,[SP, #+0]
   \   00000052   0x9B02             LDR      R3,[SP, #+8]
   \   00000054   0x9901             LDR      R1,[SP, #+4]
   \   00000056   0x6968             LDR      R0,[R5, #+20]
   \   00000058   0xAA04             ADD      R2,SP,#+16
   \   0000005A   0x.... 0x....      BL       FS__fat_find_dir
   \   0000005E   0x0004             MOVS     R4,R0
    255              if (i == 0) {
   \   00000060   0xD101             BNE.N    ??FS__fat_opendir_2
   \   00000062   0xE008             B.N      ??FS__fat_opendir_3
    256                /* Directory not found */
    257                FS__lb_ioctl(FS__pDevInfo[pDir->dev_index].devdriver, unit, FS_CMD_DEC_BUSYCNT, 0, (void*)0);  /* Turn off busy signal */
    258                return 0;
    259              }
    260            }
    261            else {
    262              /* 
    263                 There is no name in the complete path (it does end with a '\'). In that
    264                 case, FS__fat_findpath returns already start of the directory.
    265              */
    266              i = dstart;  /* Use 'current' path */
   \                     ??FS__fat_opendir_1: (+1)
   \   00000064   0x9C02             LDR      R4,[SP, #+8]
    267            }
    268            if (i) {
   \                     ??FS__fat_opendir_2: (+1)
   \   00000066   0xB1B4             CBZ.N    R4,??FS__fat_opendir_4
    269              dsize  =  FS__fat_dir_size(pDir->dev_index, unit, i);  /* Get size of the directory */
   \   00000068   0x9901             LDR      R1,[SP, #+4]
   \   0000006A   0x6968             LDR      R0,[R5, #+20]
   \   0000006C   0x4622             MOV      R2,R4
   \   0000006E   0x.... 0x....      BL       FS__fat_dir_size
   \   00000072   0x0006             MOVS     R6,R0
    270            }
    271            if (dsize == 0) {
   \   00000074   0xD10F             BNE.N    ??FS__fat_opendir_4
    272              /* Directory not found */
    273              FS__lb_ioctl(FS__pDevInfo[pDir->dev_index].devdriver, unit, FS_CMD_DEC_BUSYCNT, 0, (void*)0);  /* Turn off busy signal */
   \                     ??FS__fat_opendir_3: (+1)
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x9000             STR      R0,[SP, #+0]
   \   0000007A   0x2300             MOVS     R3,#+0
   \   0000007C   0x6968             LDR      R0,[R5, #+20]
   \   0000007E   0x9901             LDR      R1,[SP, #+4]
   \   00000080   0xEB07 0x1000      ADD      R0,R7,R0, LSL #+4
   \   00000084   0xF640 0x32BA      MOVW     R2,#+3002
   \   00000088   0x6880             LDR      R0,[R0, #+8]
   \   0000008A   0x.... 0x....      BL       FS__lb_ioctl
    274              return 0;
   \                     ??FS__fat_opendir_0: (+1)
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xB008             ADD      SP,SP,#+32
   \   00000092   0xE8BD 0x81F0      POP      {R4-R8,PC}
    275            }
    276            pDir->dirid_lo  = unit;
   \                     ??FS__fat_opendir_4: (+1)
   \   00000096   0x9801             LDR      R0,[SP, #+4]
   \   00000098   0x6028             STR      R0,[R5, #+0]
    277            pDir->dirid_hi  = i;
   \   0000009A   0x606C             STR      R4,[R5, #+4]
    278            pDir->dirid_ex  = dstart;
   \   0000009C   0x9802             LDR      R0,[SP, #+8]
   \   0000009E   0x60A8             STR      R0,[R5, #+8]
    279            pDir->error     = 0;
    280            pDir->size      = dsize;
   \   000000A0   0x612E             STR      R6,[R5, #+16]
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x8328             STRH     R0,[R5, #+24]
    281            pDir->dirpos    = 0;
   \   000000A6   0x60E8             STR      R0,[R5, #+12]
    282            pDir->inuse     = 1;
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0x76A8             STRB     R0,[R5, #+26]
    283            return pDir;
   \   000000AC   0xB008             ADD      SP,SP,#+32
   \   000000AE   0x4640             MOV      R0,R8
   \   000000B0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    284          }
    285          
    286          
    287          /*********************************************************************
    288          *
    289          *             FS__fat_closedir
    290          *
    291            Description:
    292            FS internal function. Close a directory referred by pDir.
    293          
    294            Parameters:
    295            pDir        - Pointer to a FS_DIR data structure. 
    296            
    297            Return value:
    298            ==0         - Directory has been closed.
    299            ==-1        - Unable to close directory.
    300          */
    301          

   \                                 In section .text, align 2, keep-with-next
    302          int FS__fat_closedir(FS_DIR *pDir) {
   \                     FS__fat_closedir: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    303            if (!pDir) {
   \   00000002   0xB910             CBNZ.N   R0,??FS__fat_closedir_0
    304              return -1;  /* No valid pointer to a FS_DIR structure */
   \   00000004   0xF04F 0x30FF      MOV      R0,#-1
   \   00000008   0xBD32             POP      {R1,R4,R5,PC}
    305            }
    306            FS__lb_ioctl(FS__pDevInfo[pDir->dev_index].devdriver, pDir->dirid_lo, FS_CMD_DEC_BUSYCNT, 0, (void*)0);  /* Turn off busy signal */
   \                     ??FS__fat_closedir_0: (+1)
   \   0000000A   0xF500 0x7482      ADD      R4,R0,#+260
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x9000             STR      R0,[SP, #+0]
   \   00000012   0x2300             MOVS     R3,#+0
   \   00000014   0x....             LDR.N    R0,??DataTable5
   \   00000016   0x6965             LDR      R5,[R4, #+20]
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x6821             LDR      R1,[R4, #+0]
   \   0000001C   0xEB00 0x1005      ADD      R0,R0,R5, LSL #+4
   \   00000020   0xF640 0x32BA      MOVW     R2,#+3002
   \   00000024   0x6880             LDR      R0,[R0, #+8]
   \   00000026   0x.... 0x....      BL       FS__lb_ioctl
    307            pDir->inuse = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x76A0             STRB     R0,[R4, #+26]
    308            return 0;
   \   0000002E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    309          }
    310          
    311          
    312          /*********************************************************************
    313          *
    314          *             FS__fat_readdir
    315          *
    316            Description:
    317            FS internal function. Read next directory entry in directory 
    318            specified by pDir.
    319          
    320            Parameters:
    321            pDir        - Pointer to a FS_DIR data structure. 
    322            
    323            Return value:
    324            ==0         - No more directory entries or error.
    325            !=0         - Pointer to a directory entry.
    326          */
    327          

   \                                 In section .text, align 2, keep-with-next
    328          struct FS_DIRENT *FS__fat_readdir(FS_DIR *pDir) {
   \                     FS__fat_readdir: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0005             MOVS     R5,R0
    329            FS__fat_dentry_type *s;
    330            FS_u32 dirindex;
    331            FS_u32 dsec;
    332            FS_u16 bytespersec;
    333            char *buffer;
    334            int err;
    335          
    336            if (!pDir) {
   \   00000006   0xD068             BEQ.N    ??FS__fat_readdir_0
    337              return 0;  /* No valid pointer to a FS_DIR structure */
    338            }
    339            buffer = FS__fat_malloc(FS_FAT_SEC_SIZE);
   \   00000008   0xF44F 0x7000      MOV      R0,#+512
   \   0000000C   0x.... 0x....      BL       FS__fat_malloc
   \   00000010   0xEA5F 0x0A00      MOVS     R10,R0
    340            if (!buffer) {
   \   00000014   0xD061             BEQ.N    ??FS__fat_readdir_0
    341              return 0;
    342            }
    343            bytespersec = FS__FAT_aBPBUnit[pDir->dev_index][pDir->dirid_lo].BytesPerSec;
   \   00000016   0xF505 0x7782      ADD      R7,R5,#+260
   \   0000001A   0x....             LDR.N    R0,??DataTable5_1
   \   0000001C   0x6979             LDR      R1,[R7, #+20]
   \   0000001E   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   00000022   0x6839             LDR      R1,[R7, #+0]
   \   00000024   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
    344            dirindex = pDir->dirpos / bytespersec;
   \   00000028   0xF50A 0x7900      ADD      R9,R10,#+512
   \   0000002C   0x8984             LDRH     R4,[R0, #+12]
   \   0000002E   0x68F8             LDR      R0,[R7, #+12]
   \   00000030   0xFB90 0xF8F4      SDIV     R8,R0,R4
   \   00000034   0xE001             B.N      ??FS__fat_readdir_1
    345            while (dirindex < (FS_u32)pDir->size) {
    346              dsec = FS__fat_dir_realsec(pDir->dev_index, pDir->dirid_lo, pDir->dirid_hi, dirindex);
    347              if (dsec == 0) {
    348                /* Cannot convert logical sector */
    349                FS__fat_free(buffer);
    350                return 0;
    351              }
    352              /* Read directory sector */
    353              err = FS__lb_read(FS__pDevInfo[pDir->dev_index].devdriver, pDir->dirid_lo, dsec, (void*)buffer);
    354              if (err < 0) {
    355                FS__fat_free(buffer);
    356                return 0;
    357              }
    358              /* Scan for valid directory entry */
    359              s = (FS__fat_dentry_type*)&buffer[pDir->dirpos % bytespersec];
    360              while (1) {
    361                if (s >= (FS__fat_dentry_type*)(buffer + FS_FAT_SEC_SIZE)) {
    362                  break;  /* End of sector reached */
    363                }
    364                if (s->data[11] != 0x00) { /* not an empty entry */
    365                  if (s->data[0] != (unsigned char)0xe5) { /* not a deleted file */
    366                    if (s->data[11] != (FS_FAT_ATTR_READ_ONLY | FS_FAT_ATTR_HIDDEN | FS_FAT_ATTR_SYSTEM | FS_FAT_VOLUME_ID)) {
    367                      break;  /* Also not a long entry, so it is a valid entry */
    368                    }
    369                  }
    370                }
    371                s++;
    372                pDir->dirpos += 32;
    373              }
    374              if (s < (FS__fat_dentry_type*)(buffer + FS_FAT_SEC_SIZE)) {
    375                /* Valid entry found, copy it.*/
    376                pDir->dirpos += 32;
    377                FS__CLIB_memcpy(pDir->dirent.d_name, s->data, 8);
    378                pDir->dirent.d_name[8] = '.';
    379                FS__CLIB_memcpy(&pDir->dirent.d_name[9], &s->data[8], 3);
    380                pDir->dirent.d_name[12] = 0;
    381                pDir->dirent.FAT_DirAttr = s->data[11];
    382                FS__fat_free(buffer);
    383                return &pDir->dirent;
    384              }
    385              dirindex++;
   \                     ??FS__fat_readdir_2: (+1)
   \   00000036   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??FS__fat_readdir_1: (+1)
   \   0000003A   0x6938             LDR      R0,[R7, #+16]
   \   0000003C   0x4580             CMP      R8,R0
   \   0000003E   0xD249             BCS.N    ??FS__fat_readdir_3
   \   00000040   0x687A             LDR      R2,[R7, #+4]
   \   00000042   0x6839             LDR      R1,[R7, #+0]
   \   00000044   0x6978             LDR      R0,[R7, #+20]
   \   00000046   0x4643             MOV      R3,R8
   \   00000048   0x.... 0x....      BL       FS__fat_dir_realsec
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD041             BEQ.N    ??FS__fat_readdir_3
   \   00000050   0x4602             MOV      R2,R0
   \   00000052   0x....             LDR.N    R0,??DataTable5
   \   00000054   0x697E             LDR      R6,[R7, #+20]
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x6839             LDR      R1,[R7, #+0]
   \   0000005A   0xEB00 0x1006      ADD      R0,R0,R6, LSL #+4
   \   0000005E   0x4653             MOV      R3,R10
   \   00000060   0x6880             LDR      R0,[R0, #+8]
   \   00000062   0x.... 0x....      BL       FS__lb_read
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD434             BMI.N    ??FS__fat_readdir_3
   \   0000006A   0x68F8             LDR      R0,[R7, #+12]
   \   0000006C   0xFB90 0xF1F4      SDIV     R1,R0,R4
   \   00000070   0xFB04 0x0011      MLS      R0,R4,R1,R0
   \   00000074   0xEB00 0x060A      ADD      R6,R0,R10
   \   00000078   0xE003             B.N      ??FS__fat_readdir_4
   \                     ??FS__fat_readdir_5: (+1)
   \   0000007A   0x68F8             LDR      R0,[R7, #+12]
   \   0000007C   0x3020             ADDS     R0,R0,#+32
   \   0000007E   0x3620             ADDS     R6,R6,#+32
   \   00000080   0x60F8             STR      R0,[R7, #+12]
   \                     ??FS__fat_readdir_4: (+1)
   \   00000082   0x454E             CMP      R6,R9
   \   00000084   0xD206             BCS.N    ??FS__fat_readdir_6
   \   00000086   0x7AF1             LDRB     R1,[R6, #+11]
   \   00000088   0x2900             CMP      R1,#+0
   \   0000008A   0xBF1E             ITTT     NE 
   \   0000008C   0x7832             LDRBNE   R2,[R6, #+0]
   \   0000008E   0x2AE5             CMPNE    R2,#+229
   \   00000090   0x290F             CMPNE    R1,#+15
   \   00000092   0xD0F2             BEQ.N    ??FS__fat_readdir_5
   \                     ??FS__fat_readdir_6: (+1)
   \   00000094   0x454E             CMP      R6,R9
   \   00000096   0xD2CE             BCS.N    ??FS__fat_readdir_2
   \   00000098   0x68F8             LDR      R0,[R7, #+12]
   \   0000009A   0x3020             ADDS     R0,R0,#+32
   \   0000009C   0x60F8             STR      R0,[R7, #+12]
   \   0000009E   0x2208             MOVS     R2,#+8
   \   000000A0   0x4631             MOV      R1,R6
   \   000000A2   0x1D28             ADDS     R0,R5,#+4
   \   000000A4   0x.... 0x....      BL       FS__CLIB_memcpy
   \   000000A8   0xF105 0x040C      ADD      R4,R5,#+12
   \   000000AC   0x202E             MOVS     R0,#+46
   \   000000AE   0x7020             STRB     R0,[R4, #+0]
   \   000000B0   0x2203             MOVS     R2,#+3
   \   000000B2   0xF106 0x0108      ADD      R1,R6,#+8
   \   000000B6   0xF105 0x000D      ADD      R0,R5,#+13
   \   000000BA   0x.... 0x....      BL       FS__CLIB_memcpy
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x7120             STRB     R0,[R4, #+4]
   \   000000C2   0x7AF0             LDRB     R0,[R6, #+11]
   \   000000C4   0xF885 0x0103      STRB     R0,[R5, #+259]
   \   000000C8   0x4650             MOV      R0,R10
   \   000000CA   0x.... 0x....      BL       FS__fat_free
   \   000000CE   0x4628             MOV      R0,R5
   \   000000D0   0xE8BD 0x87F0      POP      {R4-R10,PC}
    386            }
    387            FS__fat_free(buffer);
   \                     ??FS__fat_readdir_3: (+1)
   \   000000D4   0x4650             MOV      R0,R10
   \   000000D6   0x.... 0x....      BL       FS__fat_free
    388            return 0;
   \                     ??FS__fat_readdir_0: (+1)
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    389          }
    390          
    391          
    392          /*********************************************************************
    393          *
    394          *             FS__fat_MkRmDir
    395          *
    396            Description:
    397            FS internal function. Create or remove a directory. If you call this 
    398            function to remove a directory (MkDir==0), you must make sure, that 
    399            it is already empty.
    400          
    401            Parameters:
    402            pDirName    - Directory name. 
    403            Idx         - Index of device in the device information table 
    404                          referred by FS__pDevInfo.
    405            MkDir       - ==0 => Remove directory.
    406                          !=0 => Create directory.
    407            
    408            Return value:
    409            ==0         - Directory has been created.
    410            ==-1        - An error has occured.
    411          */
    412          

   \                                 In section .text, align 2, keep-with-next
    413          int  FS__fat_MkRmDir(const char *pDirName, int Idx, char MkDir) {
   \                     FS__fat_MkRmDir: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x460C             MOV      R4,R1
    414            FS_size_t len;
    415            FS_u32 dstart;
    416            FS_u32 dsize;
    417            FS_u32 unit;
    418            FS_i32 i;
    419            int lexp_a;
    420            int lexp_b;
    421            char realname[12];
    422            char *filename;
    423          
    424            if (Idx < 0) {
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xB089             SUB      SP,SP,#+36
   \   00000008   0x4615             MOV      R5,R2
   \   0000000A   0xD466             BMI.N    ??FS__fat_MkRmDir_0
    425              return -1; /* Not a valid index */
    426            }
    427            dsize = FS__fat_findpath(Idx, pDirName, &filename, &unit, &dstart);
   \   0000000C   0xA903             ADD      R1,SP,#+12
   \   0000000E   0x9100             STR      R1,[SP, #+0]
   \   00000010   0xAB02             ADD      R3,SP,#+8
   \   00000012   0x4601             MOV      R1,R0
   \   00000014   0xAA04             ADD      R2,SP,#+16
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       FS__fat_findpath
   \   0000001C   0x0006             MOVS     R6,R0
    428            if (dsize == 0) {
   \   0000001E   0xD05C             BEQ.N    ??FS__fat_MkRmDir_0
    429              return -1;  /* Path not found */
    430            }
    431            FS__lb_ioctl(FS__pDevInfo[Idx].devdriver, unit, FS_CMD_INC_BUSYCNT, 0, (void*)0); /* Turn on busy signal */
   \   00000020   0x....             LDR.N    R0,??DataTable5
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x9902             LDR      R1,[SP, #+8]
   \   00000026   0xEB00 0x1704      ADD      R7,R0,R4, LSL #+4
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x9000             STR      R0,[SP, #+0]
   \   0000002E   0x2300             MOVS     R3,#+0
   \   00000030   0x68B8             LDR      R0,[R7, #+8]
   \   00000032   0xF640 0x32B9      MOVW     R2,#+3001
   \   00000036   0x.... 0x....      BL       FS__lb_ioctl
    432            len = FS__CLIB_strlen(filename);
    433            if (len != 0) {
   \   0000003A   0x9804             LDR      R0,[SP, #+16]
   \   0000003C   0x.... 0x....      BL       FS__CLIB_strlen
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD041             BEQ.N    ??FS__fat_MkRmDir_1
    434              FS__fat_make_realname(realname, filename);  /* Convert name to FAT real name */
   \   00000044   0x9904             LDR      R1,[SP, #+16]
   \   00000046   0xA805             ADD      R0,SP,#+20
   \   00000048   0x.... 0x....      BL       FS__fat_make_realname
    435              i =  FS__fat_find_dir(Idx, unit, realname, dstart, dsize);
    436              lexp_a = (i!=0) && (MkDir);  /* We want to create a direcory , but it does already exist */
   \   0000004C   0x9B03             LDR      R3,[SP, #+12]
   \   0000004E   0x9902             LDR      R1,[SP, #+8]
   \   00000050   0x9600             STR      R6,[SP, #+0]
   \   00000052   0xAA05             ADD      R2,SP,#+20
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       FS__fat_find_dir
   \   0000005A   0xB918             CBNZ.N   R0,??FS__fat_MkRmDir_2
   \   0000005C   0x1E69             SUBS     R1,R5,#+1
   \   0000005E   0x4189             SBCS     R1,R1,R1
   \   00000060   0x0FC9             LSRS     R1,R1,#+31
   \   00000062   0xE004             B.N      ??FS__fat_MkRmDir_3
   \                     ??FS__fat_MkRmDir_2: (+1)
   \   00000064   0x1E68             SUBS     R0,R5,#+1
   \   00000066   0x4180             SBCS     R0,R0,R0
   \   00000068   0x43C0             MVNS     R0,R0
   \   0000006A   0x0FC0             LSRS     R0,R0,#+31
   \   0000006C   0x2100             MOVS     R1,#+0
    437              lexp_b = (i==0) && (!MkDir); /* We want to remove a direcory , but it does not exist */
    438              lexp_a = lexp_a || lexp_b;
    439              if (lexp_a) {
   \                     ??FS__fat_MkRmDir_3: (+1)
   \   0000006E   0x4308             ORRS     R0,R1,R0
   \   00000070   0xD12A             BNE.N    ??FS__fat_MkRmDir_1
    440                /* We want to create, but dir does already exist or we want to remove, but dir is not there */
    441                /* turn off busy signal */
    442                FS__lb_ioctl(FS__pDevInfo[Idx].devdriver, unit, FS_CMD_DEC_BUSYCNT, 0, (void*)0);
    443                return -1;
    444              }
    445            }
    446            else {
    447              FS__lb_ioctl(FS__pDevInfo[Idx].devdriver, unit, FS_CMD_DEC_BUSYCNT, 0, (void*)0);  /* Turn off busy signal */
    448              return -1;
    449            }
    450            /* 
    451                When you get here, variables have following values:
    452                 dstart="current"  
    453                 dsize="size of current"  
    454                 realname="real dir name to create" 
    455            */
    456            if (MkDir) {
   \   00000072   0xB13D             CBZ.N    R5,??FS__fat_MkRmDir_4
    457              i = _FS_fat_create_directory(Idx, unit,realname, dstart, dsize);  /* Create the directory */
   \   00000074   0x9B03             LDR      R3,[SP, #+12]
   \   00000076   0x9902             LDR      R1,[SP, #+8]
   \   00000078   0x9600             STR      R6,[SP, #+0]
   \   0000007A   0xAA05             ADD      R2,SP,#+20
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0x.... 0x....      BL       _FS_fat_create_directory
   \   00000082   0xE007             B.N      ??FS__fat_MkRmDir_5
    458            }
    459            else {
    460              i = FS__fat_DeleteFileOrDir(Idx, unit, realname, dstart, dsize, 0);  /* Remove the directory */
   \                     ??FS__fat_MkRmDir_4: (+1)
   \   00000084   0x9001             STR      R0,[SP, #+4]
   \   00000086   0x9B03             LDR      R3,[SP, #+12]
   \   00000088   0x9902             LDR      R1,[SP, #+8]
   \   0000008A   0x9600             STR      R6,[SP, #+0]
   \   0000008C   0xAA05             ADD      R2,SP,#+20
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x.... 0x....      BL       FS__fat_DeleteFileOrDir
    461            }
    462            if (i >= 0) {
   \                     ??FS__fat_MkRmDir_5: (+1)
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD417             BMI.N    ??FS__fat_MkRmDir_1
    463              /* If the operation has been successfull, flush the cache.*/
    464              i = FS__lb_ioctl(FS__pDevInfo[Idx].devdriver, unit, FS_CMD_FLUSH_CACHE, 2, (void*)0);
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x9000             STR      R0,[SP, #+0]
   \   0000009C   0x2302             MOVS     R3,#+2
   \   0000009E   0x9902             LDR      R1,[SP, #+8]
   \   000000A0   0x68B8             LDR      R0,[R7, #+8]
   \   000000A2   0xF44F 0x727A      MOV      R2,#+1000
   \   000000A6   0x.... 0x....      BL       FS__lb_ioctl
   \   000000AA   0x4604             MOV      R4,R0
    465              FS__lb_ioctl(FS__pDevInfo[Idx].devdriver, unit, FS_CMD_DEC_BUSYCNT, 0, (void*)0);  /* Turn of busy signal */
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x9000             STR      R0,[SP, #+0]
   \   000000B0   0x2300             MOVS     R3,#+0
   \   000000B2   0x9902             LDR      R1,[SP, #+8]
   \   000000B4   0x68B8             LDR      R0,[R7, #+8]
   \   000000B6   0xF640 0x32BA      MOVW     R2,#+3002
   \   000000BA   0x.... 0x....      BL       FS__lb_ioctl
    466              if (i < 0) {
   \   000000BE   0x2C00             CMP      R4,#+0
   \   000000C0   0xD40B             BMI.N    ??FS__fat_MkRmDir_0
    467                return -1;
    468              }
    469              return 0;
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0xB009             ADD      SP,SP,#+36
   \   000000C6   0xBDF0             POP      {R4-R7,PC}
    470            }
    471            FS__lb_ioctl(FS__pDevInfo[Idx].devdriver, unit, FS_CMD_DEC_BUSYCNT, 0, (void*)0);  /* Turn of busy signal */
   \                     ??FS__fat_MkRmDir_1: (+1)
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x9000             STR      R0,[SP, #+0]
   \   000000CC   0x2300             MOVS     R3,#+0
   \   000000CE   0x9902             LDR      R1,[SP, #+8]
   \   000000D0   0x68B8             LDR      R0,[R7, #+8]
   \   000000D2   0xF640 0x32BA      MOVW     R2,#+3002
   \   000000D6   0x.... 0x....      BL       FS__lb_ioctl
    472            return -1;
   \                     ??FS__fat_MkRmDir_0: (+1)
   \   000000DA   0xF04F 0x30FF      MOV      R0,#-1
   \   000000DE   0xB009             ADD      SP,SP,#+36
   \   000000E0   0xBDF0             POP      {R4-R7,PC}       ;; return
    473          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     FS__pDevInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     FS__FAT_aBPBUnit

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x2E 0x20          DC8 ".          "
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x2E 0x2E          DC8 "..         "
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x00    
    474          
    475          
    476          #endif /* FS_POSIX_DIR_SUPPORT */
    477          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      56   FS__fat_MkRmDir
        56   -> FS__CLIB_strlen
        56   -> FS__fat_DeleteFileOrDir
        56   -> FS__fat_find_dir
        56   -> FS__fat_findpath
        56   -> FS__fat_make_realname
        56   -> FS__lb_ioctl
        56   -> _FS_fat_create_directory
      16   FS__fat_closedir
        16   -> FS__lb_ioctl
      56   FS__fat_opendir
        56   -> FS__CLIB_strlen
        56   -> FS__fat_dir_size
        56   -> FS__fat_find_dir
        56   -> FS__fat_findpath
        56   -> FS__fat_make_realname
        56   -> FS__lb_ioctl
      32   FS__fat_readdir
        32   -> FS__CLIB_memcpy
        32   -> FS__fat_dir_realsec
        32   -> FS__fat_free
        32   -> FS__fat_malloc
        32   -> FS__lb_read
      56   _FS_fat_create_directory
        56   -> FS_X_OS_GetDate
        56   -> FS_X_OS_GetTime
        56   -> FS__CLIB_memset
        56   -> FS__CLIB_strlen
        56   -> FS__CLIB_strncpy
        56   -> FS__fat_FAT_alloc
        56   -> FS__fat_dir_realsec
        56   -> FS__fat_free
        56   -> FS__fat_malloc
        56   -> FS__lb_read
        56   -> FS__lb_write


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       6  ?Subroutine0
      12  ?_0
      12  ?_1
     226  FS__fat_MkRmDir
      48  FS__fat_closedir
     180  FS__fat_opendir
     224  FS__fat_readdir
     600  _FS_fat_create_directory

 
 1 316 bytes in section .text
 
 1 316 bytes of CODE memory

Errors: none
Warnings: none
