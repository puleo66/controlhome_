###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       09/Feb/2018  16:14:53
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\HW Projects\ControlHome\CntrHome -
#        RF69w\uC-FatFS\fsl\fat\fat_open.c
#    Command line =  
#        "E:\HW Projects\ControlHome\CntrHome -
#        RF69w\uC-FatFS\fsl\fat\fat_open.c" -lCN "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Debug\List" -o "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Debug\Obj" --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\APP\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\BSP\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\CPU\inc\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-CPU\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-RTC\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-LIB\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uCOS-II\Ports\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uCOS-II\Source\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\I2C-Out\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Direct_Sw\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Wdt_led\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-LCD\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-RF\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\api\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\config\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\os\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\fsl\fat\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\clib\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\lbl\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\device\mmc\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\file\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-Terminal\src\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-Terminal\inc\" -Oh
#    List file    =  
#        E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\List\fat_open.lst
#    Object file  =  
#        E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\Obj\fat_open.o
#
###############################################################################

E:\HW Projects\ControlHome\CntrHome - RF69w\uC-FatFS\fsl\fat\fat_open.c
      1          /*
      2          **********************************************************************
      3          *                          Micrium, Inc.
      4          *                      949 Crestview Circle
      5          *                     Weston,  FL 33327-1848
      6          *
      7          *                            uC/FS
      8          *
      9          *             (c) Copyright 2001 - 2003, Micrium, Inc.
     10          *                      All rights reserved.
     11          *
     12          ***********************************************************************
     13          
     14          ----------------------------------------------------------------------
     15          File        : fat_open.c
     16          Purpose     : FAT routines for open/delete files
     17          ----------------------------------------------------------------------
     18          Known problems or limitations with current version
     19          ----------------------------------------------------------------------
     20          None.
     21          ---------------------------END-OF-HEADER------------------------------
     22          */
     23          
     24          /*********************************************************************
     25          *
     26          *             #include Section
     27          *
     28          **********************************************************************
     29          */
     30          
     31          #include "fs_conf.h"
     32          #include "fs_port.h"
     33          #ifndef FS_FARCHARPTR
     34          #define FS_FARCHARPTR char *
     35          #endif
     36          #include "fs_dev.h"
     37          #include "fs_api.h"
     38          #include "fs_fsl.h"
     39          #include "fs_int.h"
     40          #include "fs_os.h"
     41          #include "fs_lbl.h"
     42          #include "fs_fat.h"
     43          #include "fs_clib.h"
     44          
     45          
     46          /*********************************************************************
     47          *
     48          *             #define constants
     49          *
     50          **********************************************************************
     51          */
     52          
     53          #ifndef FS_FAT_NOFAT32
     54            #define FS_FAT_NOFAT32        0
     55          #endif /* FS_FAT_NOFAT32 */
     56          
     57          
     58          /*********************************************************************
     59          *
     60          *             Local functions
     61          *
     62          **********************************************************************
     63          */
     64          
     65          /*********************************************************************
     66          *
     67          *             _FS_fat_find_file
     68          *
     69            Description:
     70            FS internal function. Find the file with name pFileName in directory
     71            DirStart. Copy its directory entry to pDirEntry.
     72            
     73            Parameters:
     74            Idx         - Index of device in the device information table 
     75                          referred by FS__pDevInfo.
     76            Unit        - Unit number.
     77            pFileName   - File name. 
     78            pDirEntry   - Pointer to an FS__fat_dentry_type data structure.
     79            DirStart    - 1st cluster of the directory.
     80            DirSize     - Sector (not cluster) size of the directory.
     81           
     82            Return value:
     83            >=0         - File found. Value is the first cluster of the file.
     84            <0          - An error has occured.
     85          */
     86          

   \                                 In section .text, align 2, keep-with-next
     87          static FS_i32 _FS_fat_find_file(int Idx, FS_u32 Unit, const char *pFileName,
     88                                              FS__fat_dentry_type *pDirEntry,
     89                                              FS_u32 DirStart, FS_u32 DirSize) {
   \                     _FS_fat_find_file: (+1)
   \   00000000   0xE92D 0x47F9      PUSH     {R0,R3-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4691             MOV      R9,R2
   \   0000000A   0x461E             MOV      R6,R3
     90            FS__fat_dentry_type *s;
     91            FS_u32 i;
     92            FS_u32 dsec;
     93            int len;
     94            int err; 
     95            int c;
     96            char *buffer;
     97          
     98            buffer = FS__fat_malloc(FS_FAT_SEC_SIZE);
   \   0000000C   0xF44F 0x7000      MOV      R0,#+512
   \   00000010   0x.... 0x....      BL       FS__fat_malloc
   \   00000014   0xEA5F 0x0A00      MOVS     R10,R0
     99            if (!buffer) {
   \   00000018   0xD044             BEQ.N    ??_FS_fat_find_file_0
    100              return -1;
    101            }
    102            len = FS__CLIB_strlen(pFileName);
   \   0000001A   0x4648             MOV      R0,R9
   \   0000001C   0x.... 0x....      BL       FS__CLIB_strlen
   \   00000020   0x4604             MOV      R4,R0
    103            if (len > 11) {
   \   00000022   0x2C0C             CMP      R4,#+12
   \   00000024   0xBFA8             IT       GE 
   \   00000026   0x240B             MOVGE    R4,#+11
    104              len = 11;
    105            }
    106            /* Read directory */
    107            for (i = 0; i < DirSize; i++) {
   \   00000028   0x980D             LDR      R0,[SP, #+52]
   \   0000002A   0x2500             MOVS     R5,#+0
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD036             BEQ.N    ??_FS_fat_find_file_1
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000034   0x9902             LDR      R1,[SP, #+8]
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xEB00 0x1001      ADD      R0,R0,R1, LSL #+4
   \   0000003C   0x9000             STR      R0,[SP, #+0]
    108              dsec = FS__fat_dir_realsec(Idx, Unit, DirStart, i);
   \                     ??_FS_fat_find_file_2: (+1)
   \   0000003E   0x9A0C             LDR      R2,[SP, #+48]
   \   00000040   0x9802             LDR      R0,[SP, #+8]
   \   00000042   0x462B             MOV      R3,R5
   \   00000044   0x4641             MOV      R1,R8
   \   00000046   0x.... 0x....      BL       FS__fat_dir_realsec
    109              if (dsec == 0) {
   \   0000004A   0xB340             CBZ.N    R0,??_FS_fat_find_file_1
    110                FS__fat_free(buffer);
    111                return -1;
    112              }
    113              err = FS__lb_read(FS__pDevInfo[Idx].devdriver, Unit, dsec, (void*)buffer);
    114              if (err < 0) {
   \   0000004C   0x4602             MOV      R2,R0
   \   0000004E   0x9800             LDR      R0,[SP, #+0]
   \   00000050   0x6880             LDR      R0,[R0, #+8]
   \   00000052   0x4653             MOV      R3,R10
   \   00000054   0x4641             MOV      R1,R8
   \   00000056   0x.... 0x....      BL       FS__lb_read
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD41F             BMI.N    ??_FS_fat_find_file_1
    115                FS__fat_free(buffer);
    116                return -1;
    117              }
    118              s = (FS__fat_dentry_type*)buffer;
   \   0000005E   0x4657             MOV      R7,R10
   \   00000060   0xE000             B.N      ??_FS_fat_find_file_3
    119              while (1) {
    120                if (s >= (FS__fat_dentry_type*)(buffer + FS_FAT_SEC_SIZE)) {
    121                  break;  /* End of sector reached */
    122                }
    123                c = FS__CLIB_strncmp((char*)s->data, pFileName, len);
    124                if (c == 0) {  /* Name does match */
    125                  if (s->data[11] & FS_FAT_ATTR_ARCHIVE) {
    126                    break;  /* Entry found */
    127                  }
    128                }
    129                s++;
   \                     ??_FS_fat_find_file_4: (+1)
   \   00000062   0x3720             ADDS     R7,R7,#+32
   \                     ??_FS_fat_find_file_3: (+1)
   \   00000064   0xF50A 0x7000      ADD      R0,R10,#+512
   \   00000068   0x4287             CMP      R7,R0
   \   0000006A   0xD209             BCS.N    ??_FS_fat_find_file_5
   \   0000006C   0x4622             MOV      R2,R4
   \   0000006E   0x4649             MOV      R1,R9
   \   00000070   0x4638             MOV      R0,R7
   \   00000072   0x.... 0x....      BL       FS__CLIB_strncmp
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD1F3             BNE.N    ??_FS_fat_find_file_4
   \   0000007A   0x7AF8             LDRB     R0,[R7, #+11]
   \   0000007C   0x0680             LSLS     R0,R0,#+26
   \   0000007E   0xD5F0             BPL.N    ??_FS_fat_find_file_4
    130              }
    131              if (s < (FS__fat_dentry_type*)(buffer + FS_FAT_SEC_SIZE)) {
   \                     ??_FS_fat_find_file_5: (+1)
   \   00000080   0xF50A 0x7000      ADD      R0,R10,#+512
   \   00000084   0x4287             CMP      R7,R0
   \   00000086   0xD206             BCS.N    ??_FS_fat_find_file_6
    132                /* Entry found. Return number of 1st block of the file */
    133                if (pDirEntry) {
   \   00000088   0xB126             CBZ.N    R6,??_FS_fat_find_file_7
    134                  FS__CLIB_memcpy(pDirEntry, s, sizeof(FS__fat_dentry_type));
   \   0000008A   0x2220             MOVS     R2,#+32
   \   0000008C   0x4639             MOV      R1,R7
   \   0000008E   0x4630             MOV      R0,R6
   \   00000090   0x.... 0x....      BL       FS__CLIB_memcpy
    135                }
    136                FS__fat_free(buffer);
   \                     ??_FS_fat_find_file_7: (+1)
   \   00000094   0x....             B.N      ?Subroutine0
    137                dsec  = (FS_u32)s->data[26];
    138                dsec += (FS_u32)s->data[27] * 0x100UL;
    139                dsec += (FS_u32)s->data[20] * 0x10000UL;
    140                dsec += (FS_u32)s->data[21] * 0x1000000UL;
    141                return ((FS_i32)dsec);
    142              }
    143            }
   \                     ??_FS_fat_find_file_6: (+1)
   \   00000096   0x980D             LDR      R0,[SP, #+52]
   \   00000098   0x1C6D             ADDS     R5,R5,#+1
   \   0000009A   0x4285             CMP      R5,R0
   \   0000009C   0xD3CF             BCC.N    ??_FS_fat_find_file_2
    144            FS__fat_free(buffer);
   \                     ??_FS_fat_find_file_1: (+1)
   \   0000009E   0x4650             MOV      R0,R10
   \   000000A0   0x.... 0x....      BL       FS__fat_free
    145            return -1;
   \                     ??_FS_fat_find_file_0: (+1)
   \   000000A4   0xF04F 0x30FF      MOV      R0,#-1
   \   000000A8   0x....             B.N      ??Subroutine4_0
    146          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x4650             MOV      R0,R10
   \   00000002   0x.... 0x....      BL       FS__fat_free
   \   00000006   0x7EB8             LDRB     R0,[R7, #+26]
   \   00000008   0x7EF9             LDRB     R1,[R7, #+27]
   \   0000000A   0xEB00 0x2001      ADD      R0,R0,R1, LSL #+8
   \   0000000E   0x7D39             LDRB     R1,[R7, #+20]
   \   00000010   0xEB00 0x4001      ADD      R0,R0,R1, LSL #+16
   \   00000014   0x7D79             LDRB     R1,[R7, #+21]
   \   00000016   0xEB00 0x6001      ADD      R0,R0,R1, LSL #+24
   \   0000001A                      REQUIRE ??Subroutine4_0
   \   0000001A                      ;; // Fall through to label ??Subroutine4_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine4_0: (+1)
   \   00000000   0xB004             ADD      SP,SP,#+16
   \   00000002   0xE8BD 0x87F0      POP      {R4-R10,PC}
    147          
    148          
    149          /*********************************************************************
    150          *
    151          *             _FS_fat_IncDir
    152          *
    153            Description:
    154            FS internal function. Increase directory starting at DirStart.
    155            
    156            Parameters:
    157            Idx         - Index of device in the device information table 
    158                          referred by FS__pDevInfo.
    159            Unit        - Unit number.
    160            DirStart    - 1st cluster of the directory.
    161            pDirSize    - Pointer to an FS_u32, which is used to return the new 
    162                          sector (not cluster) size of the directory.
    163           
    164            Return value:
    165            ==1         - Success.
    166            ==-1        - An error has occured.
    167          */
    168          
    169          static int _FS_fat_IncDir(int Idx, FS_u32 Unit, FS_u32 DirStart, FS_u32 *pDirSize) {
    170            FS_u32 i;
    171            FS_u32 dsec;
    172            FS_i32 last;
    173            char *buffer;
    174            int err;
    175          
    176            if (DirStart == 0) { 
    177              /* Increase root directory only, if not FAT12/16  */
    178              i = FS__FAT_aBPBUnit[Idx][Unit].RootEntCnt;
    179              if (i != 0) {
    180                return -1;  /* Not FAT32 */
    181              }
    182            }
    183            last = FS__fat_FAT_find_eof(Idx, Unit, DirStart, 0);
    184            if (last < 0) {
    185              return -1;  /* No EOF marker found */
    186            }
    187            last = FS__fat_FAT_alloc(Idx, Unit, last);  /* Allocate new cluster */
    188            if (last < 0) {
    189              return -1;
    190            }
    191            *pDirSize = *pDirSize + FS__FAT_aBPBUnit[Idx][Unit].SecPerClus;
    192            /* Clean new directory cluster */
    193            buffer = FS__fat_malloc(FS_FAT_SEC_SIZE);
    194            if (!buffer) {
    195              return -1;
    196            }
    197            FS__CLIB_memset(buffer, 0x00, (FS_size_t)FS_FAT_SEC_SIZE);
    198            for (i = *pDirSize - FS__FAT_aBPBUnit[Idx][Unit].SecPerClus; i < *pDirSize; i++) {
    199              dsec = FS__fat_dir_realsec(Idx, Unit, DirStart, i);
    200              if (dsec == 0) {
    201                FS__fat_free(buffer);
    202                return -1;
    203              }
    204              err = FS__lb_write(FS__pDevInfo[Idx].devdriver, Unit, dsec, (void*)buffer);
    205              if (err < 0) {
    206                FS__fat_free(buffer);
    207                return -1;
    208              }
    209            }
    210            FS__fat_free(buffer);
    211            return 1;
    212          }
    213          
    214          
    215          /*********************************************************************
    216          *
    217          *             _FS_fat_create_file
    218          *
    219            Description:
    220            FS internal function. Create a file in the directory specified
    221            with DirStart. Do not call, if you have not checked before for 
    222            existing file with name pFileName.
    223          
    224            Parameters:
    225            Idx         - Index of device in the device information table 
    226                          referred by FS__pDevInfo.
    227            Unit        - Unit number, which is passed to the device driver.
    228            pFileName   - File name. 
    229            DirStart    - Start of directory, where to create pDirName.
    230            DirSize     - Sector size of the directory starting at DirStart.
    231            
    232            Return value:
    233            >=0         - 1st cluster of the new file.
    234            ==-1        - An error has occured.
    235            ==-2        - Cannot create, because directory is full.
    236          */
    237          

   \                                 In section .text, align 2, keep-with-next
    238          static FS_i32 _FS_fat_create_file(int Idx, FS_u32 Unit,  const char *pFileName,
    239                                              FS_u32 DirStart, FS_u32 DirSize) {
   \                     _FS_fat_create_file: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x4688             MOV      R8,R1
    240            FS__fat_dentry_type *s;
    241            FS_u32 i;
    242            FS_u32 dsec;
    243            FS_i32 cluster;
    244            int len;
    245            int err;
    246            FS_u16 val;
    247            char *buffer;
    248          
    249            buffer = FS__fat_malloc(FS_FAT_SEC_SIZE);
   \   00000008   0xF44F 0x7000      MOV      R0,#+512
   \   0000000C   0x.... 0x....      BL       FS__fat_malloc
   \   00000010   0xEA5F 0x0900      MOVS     R9,R0
    250            if (!buffer) {
   \   00000014   0xD074             BEQ.N    ??_FS_fat_create_file_0
    251              return -1;
    252            }
    253            len = FS__CLIB_strlen(pFileName);
   \   00000016   0x9801             LDR      R0,[SP, #+4]
   \   00000018   0x.... 0x....      BL       FS__CLIB_strlen
   \   0000001C   0x4606             MOV      R6,R0
    254            if (len > 11) {
   \   0000001E   0x2E0C             CMP      R6,#+12
   \   00000020   0xBFA8             IT       GE 
   \   00000022   0x260B             MOVGE    R6,#+11
    255              len = 11;
    256            }
    257            /* Read directory */
    258            for (i = 0; i < DirSize; i++) {
   \   00000024   0x980C             LDR      R0,[SP, #+48]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xF04F 0x0B00      MOV      R11,#+0
   \   0000002C   0xD075             BEQ.N    ??_FS_fat_create_file_1
    259              dsec = FS__fat_dir_realsec(Idx, Unit, DirStart, i);
   \                     ??_FS_fat_create_file_2: (+1)
   \   0000002E   0x9A02             LDR      R2,[SP, #+8]
   \   00000030   0x465B             MOV      R3,R11
   \   00000032   0x4641             MOV      R1,R8
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       FS__fat_dir_realsec
   \   0000003A   0xEA5F 0x0A00      MOVS     R10,R0
    260              if (dsec == 0) {
   \   0000003E   0xD05C             BEQ.N    ??_FS_fat_create_file_3
    261                FS__fat_free(buffer);
    262                return -1;
    263              }
    264              err = FS__lb_read(FS__pDevInfo[Idx].devdriver, Unit, dsec, (void*)buffer);
    265              if (err < 0) {
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xEB00 0x1705      ADD      R7,R0,R5, LSL #+4
   \   0000004A   0x464B             MOV      R3,R9
   \   0000004C   0x68B8             LDR      R0,[R7, #+8]
   \   0000004E   0x4652             MOV      R2,R10
   \   00000050   0x4641             MOV      R1,R8
   \   00000052   0x.... 0x....      BL       FS__lb_read
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD44F             BMI.N    ??_FS_fat_create_file_3
    266                FS__fat_free(buffer);
    267                return -1;
    268              }
    269              s = (FS__fat_dentry_type*)buffer;
   \   0000005A   0x464C             MOV      R4,R9
   \   0000005C   0xE000             B.N      ??_FS_fat_create_file_4
    270              while (1) {
    271                if (s >= (FS__fat_dentry_type*)(buffer + FS_FAT_SEC_SIZE)) {
    272                  break;  /* End of sector reached */
    273                }
    274                if (s->data[0] == 0x00) {
    275                  break;  /* Empty entry found */
    276                }
    277                if (s->data[0] == (unsigned char)0xe5) {
    278                  break;  /* Deleted entry found */
    279                }
    280                s++;
   \                     ??_FS_fat_create_file_5: (+1)
   \   0000005E   0x3420             ADDS     R4,R4,#+32
   \                     ??_FS_fat_create_file_4: (+1)
   \   00000060   0x4620             MOV      R0,R4
   \   00000062   0xF509 0x7100      ADD      R1,R9,#+512
   \   00000066   0x4288             CMP      R0,R1
   \   00000068   0xD204             BCS.N    ??_FS_fat_create_file_6
   \   0000006A   0x7821             LDRB     R1,[R4, #+0]
   \   0000006C   0x2900             CMP      R1,#+0
   \   0000006E   0xBF18             IT       NE 
   \   00000070   0x29E5             CMPNE    R1,#+229
   \   00000072   0xD1F4             BNE.N    ??_FS_fat_create_file_5
    281              }
    282              if (s < (FS__fat_dentry_type*)(buffer + FS_FAT_SEC_SIZE)) {
   \                     ??_FS_fat_create_file_6: (+1)
   \   00000074   0xF509 0x7100      ADD      R1,R9,#+512
   \   00000078   0x4288             CMP      R0,R1
   \   0000007A   0xD249             BCS.N    ??_FS_fat_create_file_7
    283                /* Free entry found. Make entry and return 1st block of the file */
    284                FS__CLIB_strncpy((char*)s->data, pFileName, len);
   \   0000007C   0x9901             LDR      R1,[SP, #+4]
   \   0000007E   0x4632             MOV      R2,R6
   \   00000080   0x.... 0x....      BL       FS__CLIB_strncpy
    285                s->data[11] = FS_FAT_ATTR_ARCHIVE;
   \   00000084   0x2020             MOVS     R0,#+32
   \   00000086   0x72E0             STRB     R0,[R4, #+11]
    286                /* Alloc block in FAT */
    287                cluster = FS__fat_FAT_alloc(Idx, Unit, -1);
   \   00000088   0xF04F 0x32FF      MOV      R2,#-1
   \   0000008C   0x4641             MOV      R1,R8
   \   0000008E   0x4628             MOV      R0,R5
   \   00000090   0x.... 0x....      BL       FS__fat_FAT_alloc
   \   00000094   0x4605             MOV      R5,R0
    288                if (cluster >= 0) {
   \   00000096   0x2D00             CMP      R5,#+0
   \   00000098   0xD435             BMI.N    ??_FS_fat_create_file_8
    289                  s->data[12]     = 0x00;                           /* Res */
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x7320             STRB     R0,[R4, #+12]
    290                  s->data[13]     = 0x00;                           /* CrtTimeTenth (optional, not supported) */
   \   0000009E   0x7360             STRB     R0,[R4, #+13]
    291                  s->data[14]     = 0x00;                           /* CrtTime (optional, not supported) */
   \   000000A0   0x73A0             STRB     R0,[R4, #+14]
    292                  s->data[15]     = 0x00;
   \   000000A2   0x73E0             STRB     R0,[R4, #+15]
    293                  s->data[16]     = 0x00;                           /* CrtDate (optional, not supported) */
   \   000000A4   0x7420             STRB     R0,[R4, #+16]
    294                  s->data[17]     = 0x00;
   \   000000A6   0x7460             STRB     R0,[R4, #+17]
    295                  s->data[18]     = 0x00;                           /* LstAccDate (optional, not supported) */
   \   000000A8   0x74A0             STRB     R0,[R4, #+18]
    296                  s->data[19]     = 0x00;
   \   000000AA   0x74E0             STRB     R0,[R4, #+19]
    297                  val             = FS_X_OS_GetTime();
   \   000000AC   0x.... 0x....      BL       FS_X_OS_GetTime
    298                  s->data[22]     = (unsigned char)(val & 0xff);   /* WrtTime */
   \   000000B0   0x75A0             STRB     R0,[R4, #+22]
    299                  s->data[23]     = (unsigned char)(val / 256);
   \   000000B2   0x0A00             LSRS     R0,R0,#+8
   \   000000B4   0x75E0             STRB     R0,[R4, #+23]
    300                  val             = FS_X_OS_GetDate();
   \   000000B6   0x.... 0x....      BL       FS_X_OS_GetDate
    301                  s->data[24]     = (unsigned char)(val & 0xff);   /* WrtDate */
   \   000000BA   0x7620             STRB     R0,[R4, #+24]
    302                  s->data[25]     = (unsigned char)(val / 256);
    303                  s->data[26]     = (unsigned char)(cluster & 0xff);    /* FstClusLo / FstClusHi */ 
    304                  s->data[27]     = (unsigned char)((cluster / 256) & 0xff);
    305                  s->data[20]     = (unsigned char)((cluster / 0x10000L) & 0xff);
    306                  s->data[21]     = (unsigned char)((cluster / 0x1000000L) & 0xff);
    307                  s->data[28]     = 0x00;                           /* FileSize */
    308                  s->data[29]     = 0x00;
    309                  s->data[30]     = 0x00;
    310                  s->data[31]     = 0x00;
    311                  err = FS__lb_write(FS__pDevInfo[Idx].devdriver, Unit, dsec, (void*)buffer);
    312                  if (err < 0) {
   \   000000BC   0x464B             MOV      R3,R9
   \   000000BE   0x0A00             LSRS     R0,R0,#+8
   \   000000C0   0x7660             STRB     R0,[R4, #+25]
   \   000000C2   0x76A5             STRB     R5,[R4, #+26]
   \   000000C4   0x11E8             ASRS     R0,R5,#+7
   \   000000C6   0xEB05 0x6010      ADD      R0,R5,R0, LSR #+24
   \   000000CA   0x1200             ASRS     R0,R0,#+8
   \   000000CC   0x76E0             STRB     R0,[R4, #+27]
   \   000000CE   0x4652             MOV      R2,R10
   \   000000D0   0x13E8             ASRS     R0,R5,#+15
   \   000000D2   0xEB05 0x4010      ADD      R0,R5,R0, LSR #+16
   \   000000D6   0x1400             ASRS     R0,R0,#+16
   \   000000D8   0x7520             STRB     R0,[R4, #+20]
   \   000000DA   0x4641             MOV      R1,R8
   \   000000DC   0x15E8             ASRS     R0,R5,#+23
   \   000000DE   0xEB05 0x2010      ADD      R0,R5,R0, LSR #+8
   \   000000E2   0x1600             ASRS     R0,R0,#+24
   \   000000E4   0x7560             STRB     R0,[R4, #+21]
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0x7720             STRB     R0,[R4, #+28]
   \   000000EA   0x7760             STRB     R0,[R4, #+29]
   \   000000EC   0x77A0             STRB     R0,[R4, #+30]
   \   000000EE   0x77E0             STRB     R0,[R4, #+31]
   \   000000F0   0x68B8             LDR      R0,[R7, #+8]
   \   000000F2   0x.... 0x....      BL       FS__lb_write
   \   000000F6   0x2800             CMP      R0,#+0
   \   000000F8   0xD505             BPL.N    ??_FS_fat_create_file_8
    313                    FS__fat_free(buffer);
   \                     ??_FS_fat_create_file_3: (+1)
   \   000000FA   0x4648             MOV      R0,R9
   \   000000FC   0x.... 0x....      BL       FS__fat_free
    314                    return -1;
   \                     ??_FS_fat_create_file_0: (+1)
   \   00000100   0xF04F 0x30FF      MOV      R0,#-1
    315                  }
    316                }
   \   00000104   0x....             B.N      ?Subroutine1
    317                FS__fat_free(buffer);
   \                     ??_FS_fat_create_file_8: (+1)
   \   00000106   0x4648             MOV      R0,R9
   \   00000108   0x.... 0x....      BL       FS__fat_free
    318                return cluster;
   \   0000010C   0x4628             MOV      R0,R5
   \   0000010E   0x....             B.N      ?Subroutine1
    319              }
    320            }
   \                     ??_FS_fat_create_file_7: (+1)
   \   00000110   0x980C             LDR      R0,[SP, #+48]
   \   00000112   0xF10B 0x0B01      ADD      R11,R11,#+1
   \   00000116   0x4583             CMP      R11,R0
   \   00000118   0xD389             BCC.N    ??_FS_fat_create_file_2
    321            FS__fat_free(buffer);
   \                     ??_FS_fat_create_file_1: (+1)
   \   0000011A   0x4648             MOV      R0,R9
   \   0000011C   0x.... 0x....      BL       FS__fat_free
    322            return -2;      /* Directory is full */
   \   00000120   0xF06F 0x0001      MVN      R0,#+1
   \   00000124                      REQUIRE ?Subroutine1
   \   00000124                      ;; // Fall through to label ?Subroutine1
    323          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0xB003             ADD      SP,SP,#+12
   \   00000002   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    324          
    325          
    326          /*********************************************************************
    327          *
    328          *             Global functions section 1
    329          *
    330          **********************************************************************
    331          
    332            Functions in this section are global, but are used inside the FAT
    333            File System Layer only.
    334            
    335          */
    336          
    337          /*********************************************************************
    338          *
    339          *             FS__fat_DeleteFileOrDir
    340          *
    341            Description:
    342            FS internal function. Delete a file or directory.
    343            
    344            Parameters:
    345            Idx         - Index of device in the device information table 
    346                          referred by FS__pDevInfo.
    347            Unit        - Unit number, which is passed to the device driver.
    348            pName       - File or directory name. 
    349            DirStart    - Start of directory, where to create pDirName.
    350            DirSize     - Sector size of the directory starting at DirStart.
    351            RmFile      - 1 => remove a file
    352                          0 => remove a directory
    353            
    354            Return value:
    355            >=0         - Success. 
    356            <0          - An error has occured.
    357          */
    358          

   \                                 In section .text, align 2, keep-with-next
    359          FS_i32 FS__fat_DeleteFileOrDir(int Idx, FS_u32 Unit,  const char *pName,
    360                                              FS_u32 DirStart, FS_u32 DirSize, char RmFile) {
   \                     FS__fat_DeleteFileOrDir: (+1)
   \   00000000   0xE92D 0x4FFD      PUSH     {R0,R2-R11,LR}
   \   00000004   0xB08C             SUB      SP,SP,#+48
   \   00000006   0x468B             MOV      R11,R1
    361            FS__fat_dentry_type *s;
    362            FS_u32 dsec;
    363            FS_u32 i;
    364            FS_u32 value;
    365            FS_u32 fatsize;
    366            FS_u32 filesize;
    367            FS_i32 len;
    368            FS_i32 bytespersec;
    369            FS_i32 fatindex;
    370            FS_i32 fatsec;
    371            FS_i32 fatoffs;
    372            FS_i32 lastsec;
    373            FS_i32 curclst = 0;
    374            FS_i32 todo;
    375            char *buffer;
    376            int fattype;
    377            int err;
    378            int err2;
    379            int lexp;
    380            int x;
    381            unsigned char a;
    382            unsigned char b;
    383          #if (FS_FAT_NOFAT32==0)
    384            unsigned char c;
    385            unsigned char d;
    386          #endif /* FS_FAT_NOFAT32==0 */
    387          
    388            buffer = FS__fat_malloc(FS_FAT_SEC_SIZE);
   \   00000008   0xF44F 0x7000      MOV      R0,#+512
   \   0000000C   0x.... 0x....      BL       FS__fat_malloc
   \   00000010   0x2600             MOVS     R6,#+0
   \   00000012   0x0005             MOVS     R5,R0
    389            if (!buffer) {
   \   00000014   0xF000 0x816C      BEQ.W    ??FS__fat_DeleteFileOrDir_0
    390              return 0;
    391            }
    392            fattype = FS__fat_which_type(Idx, Unit);
   \   00000018   0x980C             LDR      R0,[SP, #+48]
   \   0000001A   0x4659             MOV      R1,R11
   \   0000001C   0x.... 0x....      BL       FS__fat_which_type
   \   00000020   0x9005             STR      R0,[SP, #+20]
    393          #if (FS_FAT_NOFAT32!=0)
    394            if (fattype == 2) {
    395              FS__fat_free(buffer);
    396              return -1;
    397            }
    398          #endif  /* FS_FAT_NOFAT32!=0 */
    399            fatsize = FS__FAT_aBPBUnit[Idx][Unit].FATSz16;
   \   00000022   0x990C             LDR      R1,[SP, #+48]
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable5_2
   \   00000028   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   0000002C   0xEB00 0x104B      ADD      R0,R0,R11, LSL #+5
   \   00000030   0x9003             STR      R0,[SP, #+12]
   \   00000032   0x8A40             LDRH     R0,[R0, #+18]
   \   00000034   0x9001             STR      R0,[SP, #+4]
    400            if (fatsize == 0) {
   \   00000036   0xB910             CBNZ.N   R0,??FS__fat_DeleteFileOrDir_1
    401              fatsize = FS__FAT_aBPBUnit[Idx][Unit].FATSz32;
   \   00000038   0x9803             LDR      R0,[SP, #+12]
   \   0000003A   0x6840             LDR      R0,[R0, #+4]
   \   0000003C   0x9001             STR      R0,[SP, #+4]
    402            }
    403            bytespersec = (FS_i32)FS__FAT_aBPBUnit[Idx][Unit].BytesPerSec;
   \                     ??FS__fat_DeleteFileOrDir_1: (+1)
   \   0000003E   0x9803             LDR      R0,[SP, #+12]
   \   00000040   0x8980             LDRH     R0,[R0, #+12]
   \   00000042   0x9002             STR      R0,[SP, #+8]
    404            len = FS__CLIB_strlen(pName);
   \   00000044   0x980D             LDR      R0,[SP, #+52]
   \   00000046   0x.... 0x....      BL       FS__CLIB_strlen
   \   0000004A   0x9008             STR      R0,[SP, #+32]
    405            if (len > 11) {
   \   0000004C   0x280C             CMP      R0,#+12
   \   0000004E   0xBFA4             ITT      GE 
   \   00000050   0x200B             MOVGE    R0,#+11
   \   00000052   0x9008             STRGE    R0,[SP, #+32]
    406              len = 11;
    407            }
    408            /* Read directory */
    409            for (i = 0; i < DirSize; i++) {
   \   00000054   0x9818             LDR      R0,[SP, #+96]
   \   00000056   0x9604             STR      R6,[SP, #+16]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xF000 0x8146      BEQ.W    ??FS__fat_DeleteFileOrDir_2
   \   0000005E   0x9802             LDR      R0,[SP, #+8]
   \   00000060   0x1940             ADDS     R0,R0,R5
   \   00000062   0x9009             STR      R0,[SP, #+36]
   \   00000064   0x9802             LDR      R0,[SP, #+8]
   \   00000066   0x1E40             SUBS     R0,R0,#+1
   \   00000068   0x900B             STR      R0,[SP, #+44]
    410              curclst = -1;
    411              dsec = FS__fat_dir_realsec(Idx, Unit, DirStart, i);
   \                     ??FS__fat_DeleteFileOrDir_3: (+1)
   \   0000006A   0x9B04             LDR      R3,[SP, #+16]
   \   0000006C   0x9A0E             LDR      R2,[SP, #+56]
   \   0000006E   0x980C             LDR      R0,[SP, #+48]
   \   00000070   0x4659             MOV      R1,R11
   \   00000072   0x.... 0x....      BL       FS__fat_dir_realsec
   \   00000076   0x0004             MOVS     R4,R0
   \   00000078   0xF04F 0x36FF      MOV      R6,#-1
    412              if (dsec == 0) {
   \   0000007C   0xF000 0x80EE      BEQ.W    ??FS__fat_DeleteFileOrDir_4
    413                FS__fat_free(buffer);
    414                return -1;
    415              }
    416              err = FS__lb_read(FS__pDevInfo[Idx].devdriver, Unit, dsec, (void*)buffer);
    417              if (err < 0) {
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000084   0x990C             LDR      R1,[SP, #+48]
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0xEB00 0x1001      ADD      R0,R0,R1, LSL #+4
   \   0000008C   0x9000             STR      R0,[SP, #+0]
   \   0000008E   0x462B             MOV      R3,R5
   \   00000090   0x6880             LDR      R0,[R0, #+8]
   \   00000092   0x4622             MOV      R2,R4
   \   00000094   0x4659             MOV      R1,R11
   \   00000096   0x.... 0x....      BL       FS__lb_read
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xF100 0x80DE      BMI.W    ??FS__fat_DeleteFileOrDir_4
    418                FS__fat_free(buffer);
    419                return -1;
    420              }
    421              /* Scan for pName in the directory sector */
    422              s = (FS__fat_dentry_type*) buffer;
   \   000000A0   0x462F             MOV      R7,R5
   \   000000A2   0xE000             B.N      ??FS__fat_DeleteFileOrDir_5
    423              while (1) {
    424                if (s >= (FS__fat_dentry_type*)(buffer + bytespersec)) {
    425                  break;  /* End of sector reached */
    426                }
    427                x = FS__CLIB_strncmp((char*)s->data, pName, len);
    428                if (x == 0) { /* Name does match */
    429                  if (s->data[11] != 0) {
    430                    break;  /* Entry found */
    431                  }
    432                }
    433                s++;
   \                     ??FS__fat_DeleteFileOrDir_6: (+1)
   \   000000A4   0x3720             ADDS     R7,R7,#+32
   \                     ??FS__fat_DeleteFileOrDir_5: (+1)
   \   000000A6   0x9809             LDR      R0,[SP, #+36]
   \   000000A8   0x4287             CMP      R7,R0
   \   000000AA   0xD209             BCS.N    ??FS__fat_DeleteFileOrDir_7
   \   000000AC   0x9A08             LDR      R2,[SP, #+32]
   \   000000AE   0x990D             LDR      R1,[SP, #+52]
   \   000000B0   0x4638             MOV      R0,R7
   \   000000B2   0x.... 0x....      BL       FS__CLIB_strncmp
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD1F4             BNE.N    ??FS__fat_DeleteFileOrDir_6
   \   000000BA   0x7AF8             LDRB     R0,[R7, #+11]
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD0F1             BEQ.N    ??FS__fat_DeleteFileOrDir_6
    434              }
    435              if (s < (FS__fat_dentry_type*)(buffer + bytespersec)) {
   \                     ??FS__fat_DeleteFileOrDir_7: (+1)
   \   000000C0   0x9809             LDR      R0,[SP, #+36]
   \   000000C2   0x4287             CMP      R7,R0
   \   000000C4   0xF080 0x810A      BCS.W    ??FS__fat_DeleteFileOrDir_8
    436                /* Entry has been found, delete directory entry */
    437                s->data[0]  = 0xe5;
   \   000000C8   0x20E5             MOVS     R0,#+229
   \   000000CA   0x7038             STRB     R0,[R7, #+0]
    438                s->data[11] = 0;
    439                err = FS__lb_write(FS__pDevInfo[Idx].devdriver, Unit, dsec, (void*)buffer);
    440                if (err < 0) {
   \   000000CC   0x462B             MOV      R3,R5
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x72F8             STRB     R0,[R7, #+11]
   \   000000D2   0x4622             MOV      R2,R4
   \   000000D4   0x9800             LDR      R0,[SP, #+0]
   \   000000D6   0x6880             LDR      R0,[R0, #+8]
   \   000000D8   0x4659             MOV      R1,R11
   \   000000DA   0x.... 0x....      BL       FS__lb_write
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xF100 0x80BC      BMI.W    ??FS__fat_DeleteFileOrDir_4
    441                  FS__fat_free(buffer);
    442                  return -1;
    443                }
    444                /* Free blocks in FAT */
    445                /*
    446                   For normal files, there are no more clusters freed than the entrie's filesize
    447                   does indicate. That avoids corruption of the complete media in case there is
    448                   no EOF mark found for the file (FAT is corrupt!!!). 
    449                   If the function should remove a directory, filesize if always 0 and cannot
    450                   be used for that purpose. To avoid running into endless loop, todo is set
    451                   to 0x0ffffff8L, which is the maximum number of clusters for FAT32.
    452                */
    453                if (RmFile) {
   \   000000E4   0xF89D 0x0064      LDRB     R0,[SP, #+100]
   \   000000E8   0xB1A0             CBZ.N    R0,??FS__fat_DeleteFileOrDir_9
    454                  filesize  = s->data[28] + 0x100UL * s->data[29] + 0x10000UL * s->data[30] + 0x1000000UL * s->data[31];
   \   000000EA   0x7F38             LDRB     R0,[R7, #+28]
   \   000000EC   0x7F79             LDRB     R1,[R7, #+29]
    455                  todo      = filesize / (FS__FAT_aBPBUnit[Idx][Unit].SecPerClus * bytespersec);
   \   000000EE   0x9A02             LDR      R2,[SP, #+8]
   \   000000F0   0xEB00 0x2001      ADD      R0,R0,R1, LSL #+8
   \   000000F4   0x7FB9             LDRB     R1,[R7, #+30]
   \   000000F6   0xEB00 0x4001      ADD      R0,R0,R1, LSL #+16
   \   000000FA   0x7FF9             LDRB     R1,[R7, #+31]
   \   000000FC   0xEB00 0x6101      ADD      R1,R0,R1, LSL #+24
   \   00000100   0x9803             LDR      R0,[SP, #+12]
   \   00000102   0x7F00             LDRB     R0,[R0, #+28]
   \   00000104   0x4342             MULS     R2,R2,R0
   \   00000106   0xFBB1 0xF0F2      UDIV     R0,R1,R2
    456                  value     = filesize % (FS__FAT_aBPBUnit[Idx][Unit].SecPerClus * bytespersec);
    457                  if (value != 0) {
   \   0000010A   0xFB02 0x1110      MLS      R1,R2,R0,R1
   \   0000010E   0xB119             CBZ.N    R1,??FS__fat_DeleteFileOrDir_10
    458                    todo++;
   \   00000110   0x1C40             ADDS     R0,R0,#+1
   \   00000112   0xE001             B.N      ??FS__fat_DeleteFileOrDir_10
    459                  }
    460                } 
    461                else {
    462                  todo = (FS_i32)0x0ffffff8L;
   \                     ??FS__fat_DeleteFileOrDir_9: (+1)
   \   00000114   0x.... 0x....      LDR.W    R0,??DataTable5_3  ;; 0xffffff8
    463                }
    464                curclst = s->data[26] + 0x100L * s->data[27] + 0x10000L * s->data[20] + 0x1000000L * s->data[21];
   \                     ??FS__fat_DeleteFileOrDir_10: (+1)
   \   00000118   0x7EB9             LDRB     R1,[R7, #+26]
   \   0000011A   0x7EFA             LDRB     R2,[R7, #+27]
   \   0000011C   0xEB01 0x2102      ADD      R1,R1,R2, LSL #+8
   \   00000120   0x7D3A             LDRB     R2,[R7, #+20]
   \   00000122   0xEB01 0x4102      ADD      R1,R1,R2, LSL #+16
   \   00000126   0x7D7A             LDRB     R2,[R7, #+21]
   \   00000128   0xEB01 0x6602      ADD      R6,R1,R2, LSL #+24
    465                lastsec = -1;
   \   0000012C   0xF04F 0x31FF      MOV      R1,#-1
   \   00000130   0x2800             CMP      R0,#+0
   \   00000132   0x9107             STR      R1,[SP, #+28]
   \   00000134   0xF000 0x80D0      BEQ.W    ??FS__fat_DeleteFileOrDir_11
   \   00000138   0x9006             STR      R0,[SP, #+24]
    466                /* Free cluster loop */
    467                while (todo) {
    468                  if (fattype == 1) {
   \                     ??FS__fat_DeleteFileOrDir_12: (+1)
   \   0000013A   0x9805             LDR      R0,[SP, #+20]
   \   0000013C   0x2801             CMP      R0,#+1
   \   0000013E   0xD104             BNE.N    ??FS__fat_DeleteFileOrDir_13
    469                    fatindex = curclst + (curclst / 2);    /* FAT12 */
   \   00000140   0xEB06 0x70D6      ADD      R0,R6,R6, LSR #+31
   \   00000144   0xEB06 0x0060      ADD      R0,R6,R0, ASR #+1
   \   00000148   0xE003             B.N      ??FS__fat_DeleteFileOrDir_14
    470                  }
    471          #if (FS_FAT_NOFAT32==0)
    472                  else if (fattype == 2) {
   \                     ??FS__fat_DeleteFileOrDir_13: (+1)
   \   0000014A   0x2802             CMP      R0,#+2
   \   0000014C   0xBF0C             ITE      EQ 
   \   0000014E   0x00B0             LSLEQ    R0,R6,#+2
   \   00000150   0x0070             LSLNE    R0,R6,#+1
    473                    fatindex = curclst * 4;               /* FAT32 */
    474                  }
    475          #endif  /* FS_FAT_NOFAT32==0 */
    476                  else {
    477                    fatindex = curclst * 2;               /* FAT16 */
    478                  }
    479                  fatsec = FS__FAT_aBPBUnit[Idx][Unit].RsvdSecCnt + (fatindex / bytespersec);
   \                     ??FS__fat_DeleteFileOrDir_14: (+1)
   \   00000152   0x9A03             LDR      R2,[SP, #+12]
   \   00000154   0x9902             LDR      R1,[SP, #+8]
   \   00000156   0x8B52             LDRH     R2,[R2, #+26]
   \   00000158   0xFB90 0xF1F1      SDIV     R1,R0,R1
   \   0000015C   0x188F             ADDS     R7,R1,R2
    480                  fatoffs = fatindex % bytespersec;
   \   0000015E   0x9A02             LDR      R2,[SP, #+8]
   \   00000160   0xFB02 0x0411      MLS      R4,R2,R1,R0
    481                  if (fatsec != lastsec) {
   \   00000164   0x9807             LDR      R0,[SP, #+28]
   \   00000166   0x4287             CMP      R7,R0
   \   00000168   0xD01A             BEQ.N    ??FS__fat_DeleteFileOrDir_15
    482                    err = FS__lb_read(FS__pDevInfo[Idx].devdriver, Unit, fatsec, (void*)buffer);
    483                    if (err < 0) {
   \   0000016A   0x9800             LDR      R0,[SP, #+0]
   \   0000016C   0x6880             LDR      R0,[R0, #+8]
   \   0000016E   0x462B             MOV      R3,R5
   \   00000170   0x463A             MOV      R2,R7
   \   00000172   0x4659             MOV      R1,R11
   \   00000174   0x.... 0x....      BL       FS__lb_read
   \   00000178   0x2800             CMP      R0,#+0
   \   0000017A   0xD510             BPL.N    ??FS__fat_DeleteFileOrDir_16
    484                      err = FS__lb_read(FS__pDevInfo[Idx].devdriver, Unit, fatsize + fatsec, (void*)buffer);
    485                      if (err < 0) {
   \   0000017C   0x9801             LDR      R0,[SP, #+4]
   \   0000017E   0x183A             ADDS     R2,R7,R0
   \   00000180   0x9800             LDR      R0,[SP, #+0]
   \   00000182   0x6880             LDR      R0,[R0, #+8]
   \   00000184   0x462B             MOV      R3,R5
   \   00000186   0x4659             MOV      R1,R11
   \   00000188   0x.... 0x....      BL       FS__lb_read
   \   0000018C   0x2800             CMP      R0,#+0
   \   0000018E   0xD465             BMI.N    ??FS__fat_DeleteFileOrDir_4
    486                        FS__fat_free(buffer);
    487                        return -1;
    488                      }
    489                      /* Try to repair original FAT sector with contents of copy */
    490                      FS__lb_write(FS__pDevInfo[Idx].devdriver, Unit, fatsec, (void*)buffer);
   \   00000190   0x9800             LDR      R0,[SP, #+0]
   \   00000192   0x6880             LDR      R0,[R0, #+8]
   \   00000194   0x462B             MOV      R3,R5
   \   00000196   0x463A             MOV      R2,R7
   \   00000198   0x4659             MOV      R1,R11
   \   0000019A   0x.... 0x....      BL       FS__lb_write
    491                    }
    492                    lastsec = fatsec;
   \                     ??FS__fat_DeleteFileOrDir_16: (+1)
   \   0000019E   0x9707             STR      R7,[SP, #+28]
    493                  }
    494                  if (fattype == 1) {
   \                     ??FS__fat_DeleteFileOrDir_15: (+1)
   \   000001A0   0x9905             LDR      R1,[SP, #+20]
   \   000001A2   0x1960             ADDS     R0,R4,R5
   \   000001A4   0x2901             CMP      R1,#+1
   \   000001A6   0xF040 0x80A5      BNE.W    ??FS__fat_DeleteFileOrDir_17
    495                    if (fatoffs == (bytespersec - 1)) {
   \   000001AA   0x990B             LDR      R1,[SP, #+44]
   \   000001AC   0x428C             CMP      R4,R1
   \   000001AE   0x7801             LDRB     R1,[R0, #+0]
   \   000001B0   0x4688             MOV      R8,R1
   \   000001B2   0xD159             BNE.N    ??FS__fat_DeleteFileOrDir_18
    496                      a = buffer[fatoffs];
    497                      if (curclst & 1) {
   \   000001B4   0x07F2             LSLS     R2,R6,#+31
   \   000001B6   0xBF4C             ITE      MI 
   \   000001B8   0xF001 0x010F      ANDMI    R1,R1,#0xF
   \   000001BC   0x2100             MOVPL    R1,#+0
    498                        buffer[fatoffs] &= 0x0f;
    499                      }
    500                      else {
    501                        buffer[fatoffs]  = 0x00;
   \   000001BE   0x7001             STRB     R1,[R0, #+0]
    502                      }
    503                      err  = FS__lb_write(FS__pDevInfo[Idx].devdriver, Unit, fatsec, (void*)buffer);
   \   000001C0   0x462B             MOV      R3,R5
   \   000001C2   0x9800             LDR      R0,[SP, #+0]
   \   000001C4   0x6880             LDR      R0,[R0, #+8]
   \   000001C6   0x463A             MOV      R2,R7
   \   000001C8   0x4659             MOV      R1,R11
   \   000001CA   0x.... 0x....      BL       FS__lb_write
   \   000001CE   0x4604             MOV      R4,R0
    504                      err2 = FS__lb_write(FS__pDevInfo[Idx].devdriver, Unit, fatsize + fatsec, (void*)buffer);
   \   000001D0   0x9801             LDR      R0,[SP, #+4]
   \   000001D2   0xEB07 0x0900      ADD      R9,R7,R0
   \   000001D6   0x9800             LDR      R0,[SP, #+0]
   \   000001D8   0x6880             LDR      R0,[R0, #+8]
   \   000001DA   0x462B             MOV      R3,R5
   \   000001DC   0x464A             MOV      R2,R9
   \   000001DE   0x4659             MOV      R1,R11
   \   000001E0   0x.... 0x....      BL       FS__lb_write
    505                      lexp = (err < 0);
   \   000001E4   0x2C00             CMP      R4,#+0
   \   000001E6   0xBF58             IT       PL 
   \   000001E8   0x2800             CMPPL    R0,#+0
    506                      lexp = lexp || (err2 < 0);
   \   000001EA   0xD437             BMI.N    ??FS__fat_DeleteFileOrDir_4
    507                      if (lexp) {
    508                        FS__fat_free(buffer);
    509                        return -1;
    510                      }
    511                      err = FS__lb_read(FS__pDevInfo[Idx].devdriver, Unit, fatsec + 1, (void*)buffer);
    512                      if (err < 0) {
   \   000001EC   0x9800             LDR      R0,[SP, #+0]
   \   000001EE   0x6880             LDR      R0,[R0, #+8]
   \   000001F0   0x1C7F             ADDS     R7,R7,#+1
   \   000001F2   0x462B             MOV      R3,R5
   \   000001F4   0x463A             MOV      R2,R7
   \   000001F6   0x4659             MOV      R1,R11
   \   000001F8   0x.... 0x....      BL       FS__lb_read
   \   000001FC   0x2800             CMP      R0,#+0
   \   000001FE   0xD510             BPL.N    ??FS__fat_DeleteFileOrDir_19
    513                        err = FS__lb_read(FS__pDevInfo[Idx].devdriver, Unit, fatsize + fatsec + 1, (void*)buffer);
    514                        if (err < 0) {
   \   00000200   0x9800             LDR      R0,[SP, #+0]
   \   00000202   0x6880             LDR      R0,[R0, #+8]
   \   00000204   0x462B             MOV      R3,R5
   \   00000206   0xF109 0x0201      ADD      R2,R9,#+1
   \   0000020A   0x4659             MOV      R1,R11
   \   0000020C   0x.... 0x....      BL       FS__lb_read
   \   00000210   0x2800             CMP      R0,#+0
   \   00000212   0xD423             BMI.N    ??FS__fat_DeleteFileOrDir_4
    515                          FS__fat_free(buffer);
    516                          return -1;
    517                        }
    518                        /* Try to repair original FAT sector with contents of copy */
    519                        FS__lb_write(FS__pDevInfo[Idx].devdriver, Unit, fatsec + 1, (void*)buffer);
   \   00000214   0x9800             LDR      R0,[SP, #+0]
   \   00000216   0x6880             LDR      R0,[R0, #+8]
   \   00000218   0x462B             MOV      R3,R5
   \   0000021A   0x463A             MOV      R2,R7
   \   0000021C   0x4659             MOV      R1,R11
   \   0000021E   0x.... 0x....      BL       FS__lb_write
    520                      }
    521                      lastsec = fatsec + 1;
   \                     ??FS__fat_DeleteFileOrDir_19: (+1)
   \   00000222   0x9707             STR      R7,[SP, #+28]
    522                      b = buffer[0];
    523                      if (curclst & 1) {
   \   00000224   0x07F1             LSLS     R1,R6,#+31
   \   00000226   0x7828             LDRB     R0,[R5, #+0]
   \   00000228   0x4682             MOV      R10,R0
   \   0000022A   0xBF4C             ITE      MI 
   \   0000022C   0x2000             MOVMI    R0,#+0
   \   0000022E   0xF000 0x00F0      ANDPL    R0,R0,#0xF0
    524                        buffer[0]  = 0x00;;
    525                      }
    526                      else {
    527                        buffer[0] &= 0xf0;
   \   00000232   0x7028             STRB     R0,[R5, #+0]
    528                      }
    529                      err  = FS__lb_write(FS__pDevInfo[Idx].devdriver, Unit, fatsec + 1, (void*)buffer);
   \   00000234   0x462B             MOV      R3,R5
   \   00000236   0x9800             LDR      R0,[SP, #+0]
   \   00000238   0x6880             LDR      R0,[R0, #+8]
   \   0000023A   0x463A             MOV      R2,R7
   \   0000023C   0x4659             MOV      R1,R11
   \   0000023E   0x.... 0x....      BL       FS__lb_write
   \   00000242   0x4604             MOV      R4,R0
    530                      err2 = FS__lb_write(FS__pDevInfo[Idx].devdriver, Unit, fatsize + fatsec + 1, (void*)buffer);
   \   00000244   0x9800             LDR      R0,[SP, #+0]
   \   00000246   0x6880             LDR      R0,[R0, #+8]
   \   00000248   0x462B             MOV      R3,R5
   \   0000024A   0xF109 0x0201      ADD      R2,R9,#+1
   \   0000024E   0x4659             MOV      R1,R11
   \   00000250   0x.... 0x....      BL       FS__lb_write
    531                      lexp = (err < 0);
   \   00000254   0x2C00             CMP      R4,#+0
   \   00000256   0xBF58             IT       PL 
   \   00000258   0x2800             CMPPL    R0,#+0
    532                      lexp = lexp || (err2 < 0);
   \   0000025A   0xD52A             BPL.N    ??FS__fat_DeleteFileOrDir_20
    533                      if (lexp) {
    534                        FS__fat_free(buffer);
    535                        return -1;
    536                      }
    537                    }
    538                    else {
    539                      a = buffer[fatoffs];
    540                      b = buffer[fatoffs + 1];
    541                      if (curclst & 1) {
    542                        buffer[fatoffs]     &= 0x0f;
    543                        buffer[fatoffs + 1]  = 0x00;
    544                      }
    545                      else {
    546                        buffer[fatoffs]      = 0x00;
    547                        buffer[fatoffs + 1] &= 0xf0;
    548                      }
    549                      err  = FS__lb_write(FS__pDevInfo[Idx].devdriver, Unit, fatsec, (void*)buffer);
    550                      err2 = FS__lb_write(FS__pDevInfo[Idx].devdriver, Unit, fatsize + fatsec, (void*)buffer);
    551                      lexp = (err < 0);
    552                      lexp = lexp || (err2 < 0);
    553                      if (lexp) {
    554                        FS__fat_free(buffer);
    555                        return -1;
    556                      }
    557                    }
    558                    if (curclst & 1) {
    559                      curclst = ((a & 0xf0) >> 4) + 16 * b;
    560                    }
    561                    else {
    562                      curclst = a + 256 * (b & 0x0f);
    563                    }
    564                    curclst &= 0x0fff;
    565                    if (curclst >= 0x0ff8) {
    566                      FS__fat_free(buffer);
    567                      return 0;
    568                    }
    569                  }
    570          #if (FS_FAT_NOFAT32==0)
    571                  else if (fattype == 2) { /* FAT32 */
    572                    a = buffer[fatoffs];
    573                    b = buffer[fatoffs + 1];
    574                    c = buffer[fatoffs + 2];
    575                    d = buffer[fatoffs + 3] & 0x0f;
    576                    buffer[fatoffs]      = 0x00;
    577                    buffer[fatoffs + 1]  = 0x00;
    578                    buffer[fatoffs + 2]  = 0x00;
    579                    buffer[fatoffs + 3]  = 0x00;
    580                    err  = FS__lb_write(FS__pDevInfo[Idx].devdriver, Unit, fatsec, (void*)buffer);
    581                    err2 = FS__lb_write(FS__pDevInfo[Idx].devdriver, Unit, fatsize + fatsec, (void*)buffer);
    582                    lexp = (err < 0);
    583                    lexp = lexp || (err2 < 0);
    584                    if (lexp) {
    585                      FS__fat_free(buffer);
    586                      return -1;
    587                    }
    588                    curclst = a + 0x100 * b + 0x10000L * c + 0x1000000L * d;
    589                    curclst &= 0x0fffffffL;
    590                    if (curclst >= (FS_i32)0x0ffffff8L) {
    591                      FS__fat_free(buffer);
    592                      return 0;
    593                    }
    594                  }
    595          #endif /* FS_FAT_NOFAT32==0 */
    596                  else {
    597                    a = buffer[fatoffs];
    598                    b = buffer[fatoffs + 1];
    599                    buffer[fatoffs]     = 0x00;
    600                    buffer[fatoffs + 1] = 0x00;
    601                    err  = FS__lb_write(FS__pDevInfo[Idx].devdriver, Unit, fatsec, (void*)buffer);
    602                    err2 = FS__lb_write(FS__pDevInfo[Idx].devdriver, Unit, fatsize + fatsec, (void*)buffer);
    603                    lexp = (err < 0);
    604                    lexp = lexp || (err2 < 0);
    605                    if (lexp) {
    606                      FS__fat_free(buffer);
   \                     ??FS__fat_DeleteFileOrDir_4: (+1)
   \   0000025C   0x4628             MOV      R0,R5
   \   0000025E   0x.... 0x....      BL       FS__fat_free
    607                      return -1;
   \   00000262   0xF04F 0x30FF      MOV      R0,#-1
   \   00000266   0x....             B.N      ?Subroutine2
    608                    }
   \                     ??FS__fat_DeleteFileOrDir_18: (+1)
   \   00000268   0x1962             ADDS     R2,R4,R5
   \   0000026A   0xF892 0xA001      LDRB     R10,[R2, #+1]
   \   0000026E   0x07F2             LSLS     R2,R6,#+31
   \   00000270   0xD504             BPL.N    ??FS__fat_DeleteFileOrDir_21
   \   00000272   0xF001 0x010F      AND      R1,R1,#0xF
   \   00000276   0x7001             STRB     R1,[R0, #+0]
   \   00000278   0x2000             MOVS     R0,#+0
   \   0000027A   0xE004             B.N      ??FS__fat_DeleteFileOrDir_22
   \                     ??FS__fat_DeleteFileOrDir_21: (+1)
   \   0000027C   0x2100             MOVS     R1,#+0
   \   0000027E   0x7001             STRB     R1,[R0, #+0]
   \   00000280   0x7840             LDRB     R0,[R0, #+1]
   \   00000282   0xF000 0x00F0      AND      R0,R0,#0xF0
   \                     ??FS__fat_DeleteFileOrDir_22: (+1)
   \   00000286   0x1961             ADDS     R1,R4,R5
   \   00000288   0x462B             MOV      R3,R5
   \   0000028A   0x7048             STRB     R0,[R1, #+1]
   \   0000028C   0x463A             MOV      R2,R7
   \   0000028E   0x9800             LDR      R0,[SP, #+0]
   \   00000290   0x6880             LDR      R0,[R0, #+8]
   \   00000292   0x4659             MOV      R1,R11
   \   00000294   0x.... 0x....      BL       FS__lb_write
   \   00000298   0x4604             MOV      R4,R0
   \   0000029A   0x9801             LDR      R0,[SP, #+4]
   \   0000029C   0x183A             ADDS     R2,R7,R0
   \   0000029E   0x9800             LDR      R0,[SP, #+0]
   \   000002A0   0x6880             LDR      R0,[R0, #+8]
   \   000002A2   0x462B             MOV      R3,R5
   \   000002A4   0x4659             MOV      R1,R11
   \   000002A6   0x.... 0x....      BL       FS__lb_write
   \   000002AA   0x2C00             CMP      R4,#+0
   \   000002AC   0xBF58             IT       PL 
   \   000002AE   0x2800             CMPPL    R0,#+0
   \   000002B0   0xD4D4             BMI.N    ??FS__fat_DeleteFileOrDir_4
   \                     ??FS__fat_DeleteFileOrDir_20: (+1)
   \   000002B2   0x07F0             LSLS     R0,R6,#+31
   \   000002B4   0xBF47             ITTEE    MI 
   \   000002B6   0xEA4F 0x1018      LSRMI    R0,R8,#+4
   \   000002BA   0xEB00 0x160A      ADDMI    R6,R0,R10, LSL #+4
   \   000002BE   0xF00A 0x000F      ANDPL    R0,R10,#0xF
   \   000002C2   0xEB08 0x2600      ADDPL    R6,R8,R0, LSL #+8
   \   000002C6   0xF640 0x70F8      MOVW     R0,#+4088
   \   000002CA   0x4286             CMP      R6,R0
   \   000002CC   0xDA6D             BGE.N    ??FS__fat_DeleteFileOrDir_23
    609                    curclst  = a + 256 * b;
    610                    curclst &= 0xffff;
    611                    if (curclst >= (FS_i32)0xfff8) {
    612                      FS__fat_free(buffer);
    613                      return 0;
    614                    }
    615                  }
    616                  todo--;
   \                     ??FS__fat_DeleteFileOrDir_24: (+1)
   \   000002CE   0x9806             LDR      R0,[SP, #+24]
   \   000002D0   0x1E40             SUBS     R0,R0,#+1
   \   000002D2   0x9006             STR      R0,[SP, #+24]
   \   000002D4   0xF47F 0xAF31      BNE.W    ??FS__fat_DeleteFileOrDir_12
    617                } /* Free cluster loop */
    618              } /*  Delete entry */
    619              if (curclst > 0) {
   \                     ??FS__fat_DeleteFileOrDir_11: (+1)
   \   000002D8   0x2E01             CMP      R6,#+1
   \   000002DA   0xDA06             BGE.N    ??FS__fat_DeleteFileOrDir_2
   \                     ??FS__fat_DeleteFileOrDir_8: (+1)
   \   000002DC   0x9804             LDR      R0,[SP, #+16]
   \   000002DE   0x9918             LDR      R1,[SP, #+96]
   \   000002E0   0x1C40             ADDS     R0,R0,#+1
   \   000002E2   0x4288             CMP      R0,R1
   \   000002E4   0x9004             STR      R0,[SP, #+16]
   \   000002E6   0xF4FF 0xAEC0      BCC.W    ??FS__fat_DeleteFileOrDir_3
    620                FS__fat_free(buffer);
    621                return curclst;
    622              }
    623            } /* for */
    624            FS__fat_free(buffer);
   \                     ??FS__fat_DeleteFileOrDir_2: (+1)
   \   000002EA   0x4628             MOV      R0,R5
   \   000002EC   0x.... 0x....      BL       FS__fat_free
    625            return curclst;
   \                     ??FS__fat_DeleteFileOrDir_0: (+1)
   \   000002F0   0x4630             MOV      R0,R6
   \   000002F2   0x....             B.N      ?Subroutine2
   \                     ??FS__fat_DeleteFileOrDir_17: (+1)
   \   000002F4   0x9901             LDR      R1,[SP, #+4]
   \   000002F6   0xF890 0x8000      LDRB     R8,[R0, #+0]
   \   000002FA   0xEB07 0x0901      ADD      R9,R7,R1
   \   000002FE   0x9905             LDR      R1,[SP, #+20]
   \   00000300   0x2902             CMP      R1,#+2
   \   00000302   0xD130             BNE.N    ??FS__fat_DeleteFileOrDir_25
   \   00000304   0x1961             ADDS     R1,R4,R5
   \   00000306   0x462B             MOV      R3,R5
   \   00000308   0xF891 0xA001      LDRB     R10,[R1, #+1]
   \   0000030C   0x7889             LDRB     R1,[R1, #+2]
   \   0000030E   0xF88D 0x1028      STRB     R1,[SP, #+40]
   \   00000312   0x463A             MOV      R2,R7
   \   00000314   0x1961             ADDS     R1,R4,R5
   \   00000316   0x78C9             LDRB     R1,[R1, #+3]
   \   00000318   0xF001 0x060F      AND      R6,R1,#0xF
   \   0000031C   0x2100             MOVS     R1,#+0
   \   0000031E   0x7001             STRB     R1,[R0, #+0]
   \   00000320   0x2000             MOVS     R0,#+0
   \   00000322   0x1961             ADDS     R1,R4,R5
   \   00000324   0x7048             STRB     R0,[R1, #+1]
   \   00000326   0x7088             STRB     R0,[R1, #+2]
   \   00000328   0x70C8             STRB     R0,[R1, #+3]
   \   0000032A   0x4659             MOV      R1,R11
   \   0000032C   0x9800             LDR      R0,[SP, #+0]
   \   0000032E   0x6880             LDR      R0,[R0, #+8]
   \   00000330   0x.... 0x....      BL       FS__lb_write
   \   00000334   0x4604             MOV      R4,R0
   \   00000336   0x9800             LDR      R0,[SP, #+0]
   \   00000338   0x6880             LDR      R0,[R0, #+8]
   \   0000033A   0x462B             MOV      R3,R5
   \   0000033C   0x464A             MOV      R2,R9
   \   0000033E   0x4659             MOV      R1,R11
   \   00000340   0x.... 0x....      BL       FS__lb_write
   \   00000344   0x2C00             CMP      R4,#+0
   \   00000346   0xBF58             IT       PL 
   \   00000348   0x2800             CMPPL    R0,#+0
   \   0000034A   0xD487             BMI.N    ??FS__fat_DeleteFileOrDir_4
   \   0000034C   0xF89D 0x1028      LDRB     R1,[SP, #+40]
   \   00000350   0xEB08 0x200A      ADD      R0,R8,R10, LSL #+8
   \   00000354   0xEB00 0x4001      ADD      R0,R0,R1, LSL #+16
   \   00000358   0xEB00 0x6606      ADD      R6,R0,R6, LSL #+24
   \   0000035C   0x.... 0x....      LDR.W    R0,??DataTable5_3  ;; 0xffffff8
   \   00000360   0x4286             CMP      R6,R0
   \   00000362   0xDBB4             BLT.N    ??FS__fat_DeleteFileOrDir_24
   \   00000364   0xE021             B.N      ??FS__fat_DeleteFileOrDir_23
   \                     ??FS__fat_DeleteFileOrDir_25: (+1)
   \   00000366   0x1961             ADDS     R1,R4,R5
   \   00000368   0x462B             MOV      R3,R5
   \   0000036A   0xF891 0xA001      LDRB     R10,[R1, #+1]
   \   0000036E   0x2100             MOVS     R1,#+0
   \   00000370   0x7001             STRB     R1,[R0, #+0]
   \   00000372   0x2000             MOVS     R0,#+0
   \   00000374   0x1961             ADDS     R1,R4,R5
   \   00000376   0x463A             MOV      R2,R7
   \   00000378   0x7048             STRB     R0,[R1, #+1]
   \   0000037A   0x4659             MOV      R1,R11
   \   0000037C   0x9800             LDR      R0,[SP, #+0]
   \   0000037E   0x6880             LDR      R0,[R0, #+8]
   \   00000380   0x.... 0x....      BL       FS__lb_write
   \   00000384   0x4604             MOV      R4,R0
   \   00000386   0x9800             LDR      R0,[SP, #+0]
   \   00000388   0x6880             LDR      R0,[R0, #+8]
   \   0000038A   0x462B             MOV      R3,R5
   \   0000038C   0x464A             MOV      R2,R9
   \   0000038E   0x4659             MOV      R1,R11
   \   00000390   0x.... 0x....      BL       FS__lb_write
   \   00000394   0x2C00             CMP      R4,#+0
   \   00000396   0xBF58             IT       PL 
   \   00000398   0x2800             CMPPL    R0,#+0
   \   0000039A   0xF53F 0xAF5F      BMI.W    ??FS__fat_DeleteFileOrDir_4
   \   0000039E   0xEB08 0x260A      ADD      R6,R8,R10, LSL #+8
   \   000003A2   0xF64F 0x70F8      MOVW     R0,#+65528
   \   000003A6   0x4286             CMP      R6,R0
   \   000003A8   0xDB91             BLT.N    ??FS__fat_DeleteFileOrDir_24
   \                     ??FS__fat_DeleteFileOrDir_23: (+1)
   \   000003AA   0x4628             MOV      R0,R5
   \   000003AC   0x.... 0x....      BL       FS__fat_free
   \   000003B0   0x2000             MOVS     R0,#+0
   \   000003B2                      REQUIRE ?Subroutine2
   \   000003B2                      ;; // Fall through to label ?Subroutine2
    626          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0xB00F             ADD      SP,SP,#+60
   \   00000002   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    627          
    628          
    629          /*********************************************************************
    630          *
    631          *             FS__fat_make_realname
    632          *
    633            Description:
    634            FS internal function. Convert a given name to the format, which is
    635            used in the FAT directory.
    636            
    637            Parameters:
    638            pOrgName    - Pointer to name to be translated
    639            pEntryName  - Pointer to a buffer for storing the real name used
    640                          in a directory.
    641          
    642            Return value:
    643            None.
    644          */
    645          

   \                                 In section .text, align 2, keep-with-next
    646          void FS__fat_make_realname(char *pEntryName, const char *pOrgName) {
   \                     FS__fat_make_realname: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460E             MOV      R6,R1
    647            FS_FARCHARPTR ext;
    648            FS_FARCHARPTR s;
    649            int i;
    650          
    651            s = (FS_FARCHARPTR)pOrgName;
    652            ext = (FS_FARCHARPTR) FS__CLIB_strchr(s, '.');
   \   00000008   0x212E             MOVS     R1,#+46
   \   0000000A   0x4630             MOV      R0,R6
   \   0000000C   0x.... 0x....      BL       FS__CLIB_strchr
   \   00000010   0xEA5F 0x0800      MOVS     R8,R0
    653            if (!ext) {
   \   00000014   0xD104             BNE.N    ??FS__fat_make_realname_0
    654              ext = &s[FS__CLIB_strlen(s)];
   \   00000016   0x4630             MOV      R0,R6
   \   00000018   0x.... 0x....      BL       FS__CLIB_strlen
   \   0000001C   0xEB00 0x0806      ADD      R8,R0,R6
    655            }
    656            i=0;
   \                     ??FS__fat_make_realname_0: (+1)
   \   00000020   0x2500             MOVS     R5,#+0
   \   00000022   0x4627             MOV      R7,R4
   \   00000024   0xE003             B.N      ??FS__fat_make_realname_1
    657            while (1) {
    658              if (s >= ext) {
    659                break;  /* '.' reached */
    660              }
    661              if (i >= 8) {
    662                break;  /* If there is no '.', this is the end of the name */
    663              }
    664              if (*s == (char)0xe5) {
    665                pEntryName[i] = 0x05;
    666              }
    667              else {
    668                pEntryName[i] = (char)FS__CLIB_toupper(*s);
   \                     ??FS__fat_make_realname_2: (+1)
   \   00000026   0xF807 0x0B01      STRB     R0,[R7], #+1
    669              }
    670              i++;
   \   0000002A   0x1C6D             ADDS     R5,R5,#+1
    671              s++;
   \   0000002C   0x1C76             ADDS     R6,R6,#+1
   \                     ??FS__fat_make_realname_1: (+1)
   \   0000002E   0x4546             CMP      R6,R8
   \   00000030   0xD208             BCS.N    ??FS__fat_make_realname_3
   \   00000032   0x2D08             CMP      R5,#+8
   \   00000034   0xDA06             BGE.N    ??FS__fat_make_realname_3
   \   00000036   0x7830             LDRB     R0,[R6, #+0]
   \   00000038   0x28E5             CMP      R0,#+229
   \   0000003A   0xBF0C             ITE      EQ 
   \   0000003C   0x2005             MOVEQ    R0,#+5
   \   0000003E   0x.... 0x....      BLNE     FS__CLIB_toupper
   \   00000042   0xE7F0             B.N      ??FS__fat_make_realname_2
    672            }
    673            while (i < 8) {
   \                     ??FS__fat_make_realname_3: (+1)
   \   00000044   0x2D08             CMP      R5,#+8
   \   00000046   0xF1C5 0x0808      RSB      R8,R5,#+8
   \   0000004A   0xDA05             BGE.N    ??FS__fat_make_realname_4
    674              /* Fill name with spaces*/
    675              pEntryName[i] = ' ';
   \   0000004C   0x2220             MOVS     R2,#+32
   \   0000004E   0x4641             MOV      R1,R8
   \   00000050   0x1928             ADDS     R0,R5,R4
   \   00000052   0x.... 0x....      BL       __aeabi_memset
    676              i++;
   \   00000056   0x2508             MOVS     R5,#+8
    677            }
    678            if (*s == '.') {
   \                     ??FS__fat_make_realname_4: (+1)
   \   00000058   0x7830             LDRB     R0,[R6, #+0]
   \   0000005A   0x282E             CMP      R0,#+46
   \   0000005C   0xD104             BNE.N    ??FS__fat_make_realname_5
    679              s++;
   \   0000005E   0x1C76             ADDS     R6,R6,#+1
   \   00000060   0xE002             B.N      ??FS__fat_make_realname_5
    680            }
    681            while (i < 11) {
    682              if (*s != 0) {
    683                if (*s == (char)0xe5) {
    684                  pEntryName[i] = 0x05;
    685                }
    686                else {
    687                  pEntryName[i] = (char)FS__CLIB_toupper(*s);
    688                }
    689                s++;
    690              }
    691              else {
    692                pEntryName[i] = ' ';
   \                     ??FS__fat_make_realname_6: (+1)
   \   00000062   0x2020             MOVS     R0,#+32
   \   00000064   0x5528             STRB     R0,[R5, R4]
    693              }
    694              i++;
   \                     ??FS__fat_make_realname_7: (+1)
   \   00000066   0x1C6D             ADDS     R5,R5,#+1
   \                     ??FS__fat_make_realname_5: (+1)
   \   00000068   0x2D0B             CMP      R5,#+11
   \   0000006A   0xDA0A             BGE.N    ??FS__fat_make_realname_8
   \   0000006C   0x7830             LDRB     R0,[R6, #+0]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD0F7             BEQ.N    ??FS__fat_make_realname_6
   \   00000072   0x28E5             CMP      R0,#+229
   \   00000074   0xBF0C             ITE      EQ 
   \   00000076   0x2005             MOVEQ    R0,#+5
   \   00000078   0x.... 0x....      BLNE     FS__CLIB_toupper
   \   0000007C   0x5528             STRB     R0,[R5, R4]
   \   0000007E   0x1C76             ADDS     R6,R6,#+1
   \   00000080   0xE7F1             B.N      ??FS__fat_make_realname_7
    695            }
    696            pEntryName[11]=0;
   \                     ??FS__fat_make_realname_8: (+1)
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x72E0             STRB     R0,[R4, #+11]
    697          }
   \   00000086   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    698          
    699          
    700          /*********************************************************************
    701          *
    702          *             FS__fat_find_dir
    703          *
    704            Description:
    705            FS internal function. Find the directory with name pDirName in directory
    706            DirStart.
    707            
    708            Parameters:
    709            Idx         - Index of device in the device information table 
    710                          referred by FS__pDevInfo.
    711            Unit        - Unit number.
    712            pDirName    - Directory name; if zero, return the root directory.
    713            DirStart    - 1st cluster of the directory.
    714            DirSize     - Sector (not cluster) size of the directory.
    715           
    716            Return value:
    717            >0          - Directory found. Value is the first cluster of the file.
    718            ==0         - An error has occured.
    719          */
    720          

   \                                 In section .text, align 2, keep-with-next
    721          FS_u32 FS__fat_find_dir(int Idx, FS_u32 Unit, char *pDirName, FS_u32 DirStart, 
    722                                  FS_u32 DirSize) {
   \                     FS__fat_find_dir: (+1)
   \   00000000   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \   00000004   0xB408             PUSH     {R3}
   \   00000006   0xEA5F 0x0902      MOVS     R9,R2
   \   0000000A   0xB082             SUB      SP,SP,#+8
   \   0000000C   0x4604             MOV      R4,R0
   \   0000000E   0x4688             MOV      R8,R1
    723            FS__fat_dentry_type *s;
    724            FS_u32 dstart;
    725            FS_u32 i;
    726            FS_u32 dsec;
    727            FS_u32 fatsize;
    728            int len;
    729            int err;
    730            int c;
    731            char *buffer;
    732          
    733            if (pDirName == 0) {
   \   00000010   0xD115             BNE.N    ??FS__fat_find_dir_0
    734              /* Return root directory */
    735              if (FS__FAT_aBPBUnit[Idx][Unit].FATSz16) {
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable5_2
   \   00000016   0xEB00 0x1044      ADD      R0,R0,R4, LSL #+5
   \   0000001A   0xEB00 0x1048      ADD      R0,R0,R8, LSL #+5
   \   0000001E   0x8A41             LDRH     R1,[R0, #+18]
   \   00000020   0x7F42             LDRB     R2,[R0, #+29]
   \   00000022   0x2900             CMP      R1,#+0
   \   00000024   0x8B41             LDRH     R1,[R0, #+26]
   \   00000026   0xBF18             IT       NE 
   \   00000028   0x8A40             LDRHNE   R0,[R0, #+18]
    736                fatsize = FS__FAT_aBPBUnit[Idx][Unit].FATSz16;
    737                dstart  = FS__FAT_aBPBUnit[Idx][Unit].RsvdSecCnt + FS__FAT_aBPBUnit[Idx][Unit].NumFATs * fatsize;
   \   0000002A   0xD105             BNE.N    ??FS__fat_find_dir_1
    738              }
    739              else {
    740                fatsize = FS__FAT_aBPBUnit[Idx][Unit].FATSz32;
    741                dstart  = FS__FAT_aBPBUnit[Idx][Unit].RsvdSecCnt + FS__FAT_aBPBUnit[Idx][Unit].NumFATs * fatsize
    742                          + (FS__FAT_aBPBUnit[Idx][Unit].RootClus - 2) * FS__FAT_aBPBUnit[Idx][Unit].SecPerClus;
   \   0000002C   0x6843             LDR      R3,[R0, #+4]
   \   0000002E   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000032   0x6882             LDR      R2,[R0, #+8]
   \   00000034   0x7F00             LDRB     R0,[R0, #+28]
   \   00000036   0x1E92             SUBS     R2,R2,#+2
   \                     ??FS__fat_find_dir_1: (+1)
   \   00000038   0xFB00 0x1402      MLA      R4,R0,R2,R1
   \   0000003C   0xE04A             B.N      ??FS__fat_find_dir_2
    743              }
    744            }
    745            else {
    746              /* Find directory */
    747              buffer = FS__fat_malloc(FS_FAT_SEC_SIZE);
   \                     ??FS__fat_find_dir_0: (+1)
   \   0000003E   0xF44F 0x7000      MOV      R0,#+512
   \   00000042   0x.... 0x....      BL       FS__fat_malloc
   \   00000046   0xEA5F 0x0A00      MOVS     R10,R0
    748              if (!buffer) {
   \   0000004A   0xD023             BEQ.N    ??FS__fat_find_dir_3
    749                return 0;
    750              }
    751              len = FS__CLIB_strlen(pDirName);
   \   0000004C   0x4648             MOV      R0,R9
   \   0000004E   0x.... 0x....      BL       FS__CLIB_strlen
   \   00000052   0x4605             MOV      R5,R0
    752              if (len > 11) {
   \   00000054   0x2D0C             CMP      R5,#+12
   \   00000056   0xBFA8             IT       GE 
   \   00000058   0x250B             MOVGE    R5,#+11
    753                len = 11;
    754              }
    755              /* Read directory */
    756              for (i = 0; i < DirSize; i++) {
   \   0000005A   0x980C             LDR      R0,[SP, #+48]
   \   0000005C   0x2600             MOVS     R6,#+0
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD034             BEQ.N    ??FS__fat_find_dir_4
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0xEB00 0x1004      ADD      R0,R0,R4, LSL #+4
   \   0000006C   0x9000             STR      R0,[SP, #+0]
    757                dsec = FS__fat_dir_realsec(Idx, Unit, DirStart, i);
   \                     ??FS__fat_find_dir_5: (+1)
   \   0000006E   0x9A02             LDR      R2,[SP, #+8]
   \   00000070   0x4633             MOV      R3,R6
   \   00000072   0x4641             MOV      R1,R8
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0x.... 0x....      BL       FS__fat_dir_realsec
    758                if (dsec == 0) {
   \   0000007A   0xB140             CBZ.N    R0,??FS__fat_find_dir_6
    759                  FS__fat_free(buffer);
    760                  return 0;
    761                }
    762                err = FS__lb_read(FS__pDevInfo[Idx].devdriver, Unit, dsec, (void*)buffer);
    763                if (err < 0) {
   \   0000007C   0x4602             MOV      R2,R0
   \   0000007E   0x9800             LDR      R0,[SP, #+0]
   \   00000080   0x6880             LDR      R0,[R0, #+8]
   \   00000082   0x4653             MOV      R3,R10
   \   00000084   0x4641             MOV      R1,R8
   \   00000086   0x.... 0x....      BL       FS__lb_read
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD504             BPL.N    ??FS__fat_find_dir_7
    764                  FS__fat_free(buffer);
   \                     ??FS__fat_find_dir_6: (+1)
   \   0000008E   0x4650             MOV      R0,R10
   \   00000090   0x.... 0x....      BL       FS__fat_free
    765                  return 0;
   \                     ??FS__fat_find_dir_3: (+1)
   \   00000094   0x2000             MOVS     R0,#+0
    766                }
   \   00000096   0x....             B.N      ??Subroutine4_0
    767                s = (FS__fat_dentry_type*)buffer;
   \                     ??FS__fat_find_dir_7: (+1)
   \   00000098   0x4657             MOV      R7,R10
   \   0000009A   0xE000             B.N      ??FS__fat_find_dir_8
    768                while (1) {
    769                  if (s >= (FS__fat_dentry_type*)(buffer + FS_FAT_SEC_SIZE)) {
    770                    break;  /* End of sector reached */
    771                  }
    772                  c = FS__CLIB_strncmp((char*)s->data, pDirName, len);
    773                  if (c == 0) { /* Name does match */
    774                    if (s->data[11] & FS_FAT_ATTR_DIRECTORY) {
    775                      break;  /* Entry found */
    776                    }
    777                  }
    778                  s++;
   \                     ??FS__fat_find_dir_9: (+1)
   \   0000009C   0x3720             ADDS     R7,R7,#+32
   \                     ??FS__fat_find_dir_8: (+1)
   \   0000009E   0xF50A 0x7000      ADD      R0,R10,#+512
   \   000000A2   0x4287             CMP      R7,R0
   \   000000A4   0xD209             BCS.N    ??FS__fat_find_dir_10
   \   000000A6   0x462A             MOV      R2,R5
   \   000000A8   0x4649             MOV      R1,R9
   \   000000AA   0x4638             MOV      R0,R7
   \   000000AC   0x.... 0x....      BL       FS__CLIB_strncmp
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD1F3             BNE.N    ??FS__fat_find_dir_9
   \   000000B4   0x7AF8             LDRB     R0,[R7, #+11]
   \   000000B6   0x06C0             LSLS     R0,R0,#+27
   \   000000B8   0xD5F0             BPL.N    ??FS__fat_find_dir_9
    779                }
    780                if (s < (FS__fat_dentry_type*)(buffer + FS_FAT_SEC_SIZE)) {
   \                     ??FS__fat_find_dir_10: (+1)
   \   000000BA   0xF50A 0x7000      ADD      R0,R10,#+512
   \   000000BE   0x4287             CMP      R7,R0
   \   000000C0   0xD200             BCS.N    ??FS__fat_find_dir_11
    781                  /* Entry found. Return number of 1st block of the directory */
    782                  FS__fat_free(buffer);
   \   000000C2   0x....             B.N      ?Subroutine0
    783                  dstart  = (FS_u32)s->data[26];
    784                  dstart += (FS_u32)0x100UL * s->data[27];
    785                  dstart += (FS_u32)0x10000UL * s->data[20];
    786                  dstart += (FS_u32)0x1000000UL * s->data[21];
    787                  return dstart;
    788                }
    789              }
   \                     ??FS__fat_find_dir_11: (+1)
   \   000000C4   0x980C             LDR      R0,[SP, #+48]
   \   000000C6   0x1C76             ADDS     R6,R6,#+1
   \   000000C8   0x4286             CMP      R6,R0
   \   000000CA   0xD3D0             BCC.N    ??FS__fat_find_dir_5
    790              dstart = 0;
    791              FS__fat_free(buffer);
   \                     ??FS__fat_find_dir_4: (+1)
   \   000000CC   0x4650             MOV      R0,R10
   \   000000CE   0x.... 0x....      BL       FS__fat_free
   \   000000D2   0x2400             MOVS     R4,#+0
    792            }
    793            return dstart;
   \                     ??FS__fat_find_dir_2: (+1)
   \   000000D4   0x4620             MOV      R0,R4
   \   000000D6   0x....             B.N      ??Subroutine4_0
    794          }
    795          
    796          
    797          /*********************************************************************
    798          *
    799          *             FS__fat_dir_realsec
    800          *
    801            Description:
    802            FS internal function. Translate a directory relative sector number
    803            to a real sector number on the media.
    804            
    805            Parameters:
    806            Idx         - Index of device in the device information table 
    807                          referred by FS__pDevInfo.
    808            Unit        - Unit number.
    809            DirStart    - 1st cluster of the directory. This is zero to address 
    810                          the root directory. 
    811            DirSec      - Sector in the directory.
    812           
    813            Return value:
    814            >0          - Directory found. Value is the sector number on the media.
    815            ==0         - An error has occured.
    816          */
    817          

   \                                 In section .text, align 2, keep-with-next
    818          FS_u32 FS__fat_dir_realsec(int Idx, FS_u32 Unit, FS_u32 DirStart, FS_u32 DirSec) {
   \                     FS__fat_dir_realsec: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x469A             MOV      R10,R3
    819            FS_u32 rootdir;
    820            FS_u32 rsec;
    821            FS_u32 dclust;
    822            FS_u32 fatsize;
    823            int fattype;
    824            int lexp;
    825            unsigned char secperclus;
    826          
    827            fattype = FS__fat_which_type(Idx, Unit);
   \   0000000C   0x.... 0x....      BL       FS__fat_which_type
    828            lexp = (0 == DirStart);
   \   00000010   0xB966             CBNZ.N   R6,??FS__fat_dir_realsec_0
   \   00000012   0x2802             CMP      R0,#+2
   \   00000014   0xD00A             BEQ.N    ??FS__fat_dir_realsec_0
    829            lexp = lexp && (fattype != 2);
    830            if (lexp) {
    831              /* Sector in FAT12/FAT16 root directory */
    832              rootdir = FS__fat_find_dir(Idx, Unit, 0, 0, 0);
    833              rsec = rootdir + DirSec;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x9000             STR      R0,[SP, #+0]
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0x4649             MOV      R1,R9
   \   00000020   0x4640             MOV      R0,R8
   \   00000022   0x.... 0x....      BL       FS__fat_find_dir
   \   00000026   0x4450             ADD      R0,R10,R0
    834            }
    835            else {
    836              fatsize = FS__FAT_aBPBUnit[Idx][Unit].FATSz16;
    837              if (fatsize == 0) {
    838                fatsize = FS__FAT_aBPBUnit[Idx][Unit].FATSz32;
    839              }
    840              secperclus = FS__FAT_aBPBUnit[Idx][Unit].SecPerClus;
    841              dclust = DirSec / secperclus;
    842              if (0 == DirStart) {
    843                /* FAT32 root directory */
    844                rsec = FS__FAT_aBPBUnit[Idx][Unit].RootClus;
    845              } 
    846              else {
    847                rsec = FS__fat_diskclust(Idx, Unit, DirStart, dclust);
    848                if (rsec == 0) {
    849                  return 0;
    850                }
    851              }
    852              rsec -= 2;
    853              rsec *= secperclus;
    854              rsec += FS__FAT_aBPBUnit[Idx][Unit].RsvdSecCnt + FS__FAT_aBPBUnit[Idx][Unit].NumFATs * fatsize;
    855              rsec += ((FS_u32)((FS_u32)FS__FAT_aBPBUnit[Idx][Unit].RootEntCnt) * FS_FAT_DENTRY_SIZE) / FS_FAT_SEC_SIZE;
    856              rsec += (DirSec % secperclus);
    857            }
    858            return rsec;
   \   00000028   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   \                     ??FS__fat_dir_realsec_0: (+1)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable5_2
   \   00000030   0xEB00 0x1048      ADD      R0,R0,R8, LSL #+5
   \   00000034   0xEB00 0x1449      ADD      R4,R0,R9, LSL #+5
   \   00000038   0x8A65             LDRH     R5,[R4, #+18]
   \   0000003A   0xB905             CBNZ.N   R5,??FS__fat_dir_realsec_1
   \   0000003C   0x6865             LDR      R5,[R4, #+4]
   \                     ??FS__fat_dir_realsec_1: (+1)
   \   0000003E   0x7F27             LDRB     R7,[R4, #+28]
   \   00000040   0xFBBA 0xFBF7      UDIV     R11,R10,R7
   \   00000044   0xB986             CBNZ.N   R6,??FS__fat_dir_realsec_2
   \   00000046   0x68A0             LDR      R0,[R4, #+8]
   \                     ??FS__fat_dir_realsec_3: (+1)
   \   00000048   0x8B61             LDRH     R1,[R4, #+26]
   \   0000004A   0x1E80             SUBS     R0,R0,#+2
   \   0000004C   0xFB07 0x1000      MLA      R0,R7,R0,R1
   \   00000050   0x7F61             LDRB     R1,[R4, #+29]
   \   00000052   0xFB05 0x0001      MLA      R0,R5,R1,R0
   \   00000056   0x89E1             LDRH     R1,[R4, #+14]
   \   00000058   0x0149             LSLS     R1,R1,#+5
   \   0000005A   0xEB00 0x2051      ADD      R0,R0,R1, LSR #+9
   \   0000005E   0x4450             ADD      R0,R10,R0
   \   00000060   0xFB07 0x001B      MLS      R0,R7,R11,R0
   \   00000064   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \                     ??FS__fat_dir_realsec_2: (+1)
   \   00000068   0x465B             MOV      R3,R11
   \   0000006A   0x4632             MOV      R2,R6
   \   0000006C   0x4649             MOV      R1,R9
   \   0000006E   0x4640             MOV      R0,R8
   \   00000070   0x.... 0x....      BL       FS__fat_diskclust
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD1E7             BNE.N    ??FS__fat_dir_realsec_3
   \   00000078   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    859          }
    860          
    861          
    862          /*********************************************************************
    863          *
    864          *             FS__fat_dirsize
    865          *
    866            Description:
    867            FS internal function. Return the sector size of the directory 
    868            starting at DirStart.
    869            
    870            Parameters:
    871            Idx         - Index of device in the device information table 
    872                          referred by FS__pDevInfo.
    873            Unit        - Unit number.
    874            DirStart    - 1st cluster of the directory. This is zero to address 
    875                          the root directory. 
    876           
    877            Return value:
    878            >0          - Sector (not cluster) size of the directory.
    879            ==0         - An error has occured.
    880          */
    881          

   \                                 In section .text, align 2, keep-with-next
    882          FS_u32 FS__fat_dir_size(int Idx, FS_u32 Unit, FS_u32 DirStart) {
   \                     FS__fat_dir_size: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    883            FS_u32 dsize;
    884            FS_i32 value;
    885          
    886            if (DirStart == 0) {
   \   00000006   0xBB02             CBNZ.N   R2,??FS__fat_dir_size_0
    887              /* For FAT12/FAT16 root directory, the size can be found in BPB */
    888              dsize = ((FS_u32)((FS_u32)FS__FAT_aBPBUnit[Idx][Unit].RootEntCnt)
    889                      * FS_FAT_DENTRY_SIZE) / ((FS_u32)FS__FAT_aBPBUnit[Idx][Unit].BytesPerSec);
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable5_2
   \   0000000C   0xEB00 0x1044      ADD      R0,R0,R4, LSL #+5
   \   00000010   0xEB00 0x1045      ADD      R0,R0,R5, LSL #+5
   \   00000014   0x89C1             LDRH     R1,[R0, #+14]
   \   00000016   0x8982             LDRH     R2,[R0, #+12]
   \   00000018   0x0149             LSLS     R1,R1,#+5
   \   0000001A   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   0000001E   0x9100             STR      R1,[SP, #+0]
    890              if (dsize == 0) {
   \   00000020   0xB989             CBNZ.N   R1,??FS__fat_dir_size_1
    891                /* Size in BPB is 0, so it is a FAT32 (FAT32 does not have a real root dir) */
    892                value = FS__fat_FAT_find_eof(Idx, Unit, FS__FAT_aBPBUnit[Idx][Unit].RootClus, &dsize);
    893                if (value < 0) {
   \   00000022   0x6882             LDR      R2,[R0, #+8]
   \   00000024   0x466B             MOV      R3,SP
   \   00000026   0x4629             MOV      R1,R5
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       FS__fat_FAT_find_eof
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD410             BMI.N    ??FS__fat_dir_size_2
    894                  dsize = 0;
    895                }
    896                else {
    897                  dsize *= FS__FAT_aBPBUnit[Idx][Unit].SecPerClus;
    898                }
    899              }
    900            }
    901            else {
    902              /* Calc size of a sub-dir */
    903              value = FS__fat_FAT_find_eof(Idx, Unit, DirStart, &dsize);
    904              if (value < 0) {
    905                dsize = 0;
    906              }
    907              else {
    908                dsize *= FS__FAT_aBPBUnit[Idx][Unit].SecPerClus;
   \                     ??FS__fat_dir_size_3: (+1)
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable5_2
   \   00000036   0x9800             LDR      R0,[SP, #+0]
   \   00000038   0xEB01 0x1144      ADD      R1,R1,R4, LSL #+5
   \   0000003C   0xEB01 0x1145      ADD      R1,R1,R5, LSL #+5
   \   00000040   0x7F09             LDRB     R1,[R1, #+28]
   \   00000042   0x4348             MULS     R0,R1,R0
   \                     ??FS__fat_dir_size_4: (+1)
   \   00000044   0x9000             STR      R0,[SP, #+0]
    909              }
    910            }
    911            return dsize;
   \                     ??FS__fat_dir_size_1: (+1)
   \   00000046   0x9800             LDR      R0,[SP, #+0]
   \   00000048   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   \                     ??FS__fat_dir_size_0: (+1)
   \   0000004A   0x466B             MOV      R3,SP
   \   0000004C   0x.... 0x....      BL       FS__fat_FAT_find_eof
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD5EE             BPL.N    ??FS__fat_dir_size_3
   \                     ??FS__fat_dir_size_2: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xE7F5             B.N      ??FS__fat_dir_size_4
    912          }
    913          
    914          
    915          /*********************************************************************
    916          *
    917          *             FS__fat_findpath
    918          *
    919            Description:
    920            FS internal function. Return start cluster and size of the directory
    921            of the file name in pFileName.
    922            
    923            Parameters:
    924            Idx         - Index of device in the device information table 
    925                          referred by FS__pDevInfo.
    926            pFullName   - Fully qualified file name w/o device name.
    927            pFileName   - Pointer to a pointer, which is modified to point to the
    928                          file name part of pFullName.
    929            pUnit       - Pointer to an FS_u32 for returning the unit number.
    930            pDirStart   - Pointer to an FS_u32 for returning the start cluster of
    931                          the directory.
    932          
    933            Return value:
    934            >0          - Sector (not cluster) size of the directory.
    935            ==0         - An error has occured.
    936          */
    937          

   \                                 In section .text, align 2, keep-with-next
    938          FS_u32 FS__fat_findpath(int Idx, const char *pFullName, FS_FARCHARPTR *pFileName, 
    939                                  FS_u32 *pUnit, FS_u32 *pDirStart) {
   \                     FS__fat_findpath: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0x4683             MOV      R11,R0
   \   00000006   0x460F             MOV      R7,R1
   \   00000008   0xB087             SUB      SP,SP,#+28
   \   0000000A   0x4615             MOV      R5,R2
   \   0000000C   0x461E             MOV      R6,R3
    940            FS_u32 dsize;
    941            FS_i32 i;
    942            FS_i32 j;
    943            FS_FARCHARPTR dname_start;
    944            FS_FARCHARPTR dname_stop;
    945            FS_FARCHARPTR chprt;
    946            int x;
    947            char dname[12];
    948            char realname[12];
    949          
    950            /* Find correct unit (unit:name) */
    951            *pFileName = (FS_FARCHARPTR)FS__CLIB_strchr(pFullName, ':');
   \   0000000E   0x213A             MOVS     R1,#+58
   \   00000010   0x4638             MOV      R0,R7
   \   00000012   0x.... 0x....      BL       FS__CLIB_strchr
   \   00000016   0x6028             STR      R0,[R5, #+0]
    952            if (*pFileName) {
   \   00000018   0xB138             CBZ.N    R0,??FS__fat_findpath_0
    953              /* Scan for unit number */
    954              *pUnit = FS__CLIB_atoi(pFullName);
   \   0000001A   0x4638             MOV      R0,R7
   \   0000001C   0x.... 0x....      BL       FS__CLIB_atoi
   \   00000020   0x6030             STR      R0,[R6, #+0]
    955              (*pFileName)++;
   \   00000022   0x6828             LDR      R0,[R5, #+0]
   \   00000024   0x1C40             ADDS     R0,R0,#+1
   \   00000026   0x6028             STR      R0,[R5, #+0]
   \   00000028   0xE001             B.N      ??FS__fat_findpath_1
    956            }
    957            else {
    958              /* Use 1st unit as default */
    959              *pUnit = 0;
   \                     ??FS__fat_findpath_0: (+1)
   \   0000002A   0x6030             STR      R0,[R6, #+0]
    960              *pFileName = (FS_FARCHARPTR) pFullName;
   \   0000002C   0x602F             STR      R7,[R5, #+0]
    961            }
    962            /* Check volume */
    963            x = !FS__fat_checkunit(Idx, *pUnit);
   \                     ??FS__fat_findpath_1: (+1)
   \   0000002E   0x4658             MOV      R0,R11
   \   00000030   0x6831             LDR      R1,[R6, #+0]
   \   00000032   0x.... 0x....      BL       FS__fat_checkunit
   \   00000036   0xB380             CBZ.N    R0,??FS__fat_findpath_2
   \   00000038   0x9F10             LDR      R7,[SP, #+64]
    964            if (x) {
    965              return 0;
    966            }
    967            /* Setup pDirStart/dsize for root directory */
    968            *pDirStart = 0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x6038             STR      R0,[R7, #+0]
    969            dsize      = FS__fat_dir_size(Idx, *pUnit, 0);
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x6831             LDR      R1,[R6, #+0]
   \   00000042   0x4658             MOV      R0,R11
   \   00000044   0x.... 0x....      BL       FS__fat_dir_size
   \   00000048   0x4680             MOV      R8,R0
   \   0000004A   0xF10D 0x0904      ADD      R9,SP,#+4
    970            /* Find correct directory */
    971            do {
    972              dname_start = (FS_FARCHARPTR)FS__CLIB_strchr(*pFileName, '\\');
   \                     ??FS__fat_findpath_3: (+1)
   \   0000004E   0x6828             LDR      R0,[R5, #+0]
   \   00000050   0x215C             MOVS     R1,#+92
   \   00000052   0x.... 0x....      BL       FS__CLIB_strchr
    973              if (dname_start) {
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD042             BEQ.N    ??FS__fat_findpath_4
    974                dname_start++;
   \   0000005A   0xF100 0x0A01      ADD      R10,R0,#+1
    975                *pFileName = dname_start;
   \   0000005E   0xF8C5 0xA000      STR      R10,[R5, #+0]
    976                dname_stop = (FS_FARCHARPTR)FS__CLIB_strchr(dname_start, '\\');
   \   00000062   0x215C             MOVS     R1,#+92
   \   00000064   0x4650             MOV      R0,R10
   \   00000066   0x.... 0x....      BL       FS__CLIB_strchr
    977              }
    978              else {
    979                dname_stop = 0;
    980              }
    981              if (dname_stop) {
   \   0000006A   0xB3B0             CBZ.N    R0,??FS__fat_findpath_5
    982                i = dname_stop-dname_start;
   \   0000006C   0x4651             MOV      R1,R10
   \   0000006E   0x1A44             SUBS     R4,R0,R1
    983                if (i >= 12) {
   \   00000070   0x2C0C             CMP      R4,#+12
   \   00000072   0xDB14             BLT.N    ??FS__fat_findpath_6
    984                  j = 0;
   \   00000074   0x2200             MOVS     R2,#+0
    985                  for (chprt = dname_start; chprt < dname_stop; chprt++) {
   \   00000076   0x4281             CMP      R1,R0
   \   00000078   0x4653             MOV      R3,R10
   \   0000007A   0xD20E             BCS.N    ??FS__fat_findpath_2
    986                    if (*chprt == '.') {
   \                     ??FS__fat_findpath_7: (+1)
   \   0000007C   0x7819             LDRB     R1,[R3, #+0]
   \   0000007E   0x292E             CMP      R1,#+46
   \   00000080   0xBF08             IT       EQ 
   \   00000082   0x1E64             SUBEQ    R4,R4,#+1
    987                      i--;
   \   00000084   0xD004             BEQ.N    ??FS__fat_findpath_8
    988                    }
    989                    else if (j < 12) {
   \   00000086   0x2A0C             CMP      R2,#+12
   \   00000088   0xBFBC             ITT      LT 
   \   0000008A   0xF802 0x1009      STRBLT   R1,[R2, R9]
   \   0000008E   0x1C52             ADDLT    R2,R2,#+1
    990                      realname[j] = *chprt;
    991                      j++;
    992                    }
    993                  }
   \                     ??FS__fat_findpath_8: (+1)
   \   00000090   0x1C5B             ADDS     R3,R3,#+1
   \   00000092   0x4283             CMP      R3,R0
   \   00000094   0xD3F2             BCC.N    ??FS__fat_findpath_7
    994                  if (i >= 12) {
   \   00000096   0x2C0C             CMP      R4,#+12
   \   00000098   0xDB05             BLT.N    ??FS__fat_findpath_9
    995                    return 0;
   \                     ??FS__fat_findpath_2: (+1)
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x....             B.N      ?Subroutine3
    996                  }
    997                }
    998                else {
    999                  FS__CLIB_strncpy(realname, dname_start, i);
   \                     ??FS__fat_findpath_6: (+1)
   \   0000009E   0x4622             MOV      R2,R4
   \   000000A0   0xA801             ADD      R0,SP,#+4
   \   000000A2   0x.... 0x....      BL       FS__CLIB_strncpy
   1000                }
   1001                realname[i] = 0;
   \                     ??FS__fat_findpath_9: (+1)
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0xF804 0x0009      STRB     R0,[R4, R9]
   1002                FS__fat_make_realname(dname, realname);
   \   000000AC   0xA901             ADD      R1,SP,#+4
   \   000000AE   0xA804             ADD      R0,SP,#+16
   \   000000B0   0x.... 0x....      BL       FS__fat_make_realname
   1003                *pDirStart =  FS__fat_find_dir(Idx, *pUnit, dname, *pDirStart, dsize);
   \   000000B4   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   000000B8   0x683B             LDR      R3,[R7, #+0]
   \   000000BA   0x6831             LDR      R1,[R6, #+0]
   \   000000BC   0xAA04             ADD      R2,SP,#+16
   \   000000BE   0x4658             MOV      R0,R11
   \   000000C0   0x.... 0x....      BL       FS__fat_find_dir
   \   000000C4   0x6038             STR      R0,[R7, #+0]
   1004                if (*pDirStart) {
   \   000000C6   0xB130             CBZ.N    R0,??FS__fat_findpath_10
   1005                  dsize  =  FS__fat_dir_size(Idx, *pUnit, *pDirStart);
   \   000000C8   0x4602             MOV      R2,R0
   \   000000CA   0x6831             LDR      R1,[R6, #+0]
   \   000000CC   0x4658             MOV      R0,R11
   \   000000CE   0x.... 0x....      BL       FS__fat_dir_size
   \   000000D2   0x4680             MOV      R8,R0
   \   000000D4   0xE001             B.N      ??FS__fat_findpath_5
   1006                }
   1007                else {
   1008                  dsize = 0;    /* Directory NOT found */
   \                     ??FS__fat_findpath_10: (+1)
   \   000000D6   0xF04F 0x0800      MOV      R8,#+0
   1009                }
   1010              }
   1011            } while (dname_start);
   \                     ??FS__fat_findpath_5: (+1)
   \   000000DA   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000DE   0xD1B6             BNE.N    ??FS__fat_findpath_3
   1012            return dsize;
   \                     ??FS__fat_findpath_4: (+1)
   \   000000E0   0x4640             MOV      R0,R8
   \   000000E2                      REQUIRE ?Subroutine3
   \   000000E2                      ;; // Fall through to label ?Subroutine3
   1013          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0xB007             ADD      SP,SP,#+28
   \   00000002   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1014          
   1015          
   1016          /*********************************************************************
   1017          *
   1018          *             Global functions section 2
   1019          *
   1020          **********************************************************************
   1021          
   1022            These are real global functions, which are used by the API Layer
   1023            of the file system.
   1024            
   1025          */
   1026          
   1027          /*********************************************************************
   1028          *
   1029          *             FS__fat_fopen
   1030          *
   1031            Description:
   1032            FS internal function. Open an existing file or create a new one.
   1033          
   1034            Parameters:
   1035            pFileName   - File name. 
   1036            pMode       - Mode for opening the file.
   1037            pFile       - Pointer to an FS_FILE data structure.
   1038            
   1039            Return value:
   1040            ==0         - Unable to open the file.
   1041            !=0         - Address of the FS_FILE data structure.
   1042          */
   1043          

   \                                 In section .text, align 2, keep-with-next
   1044          FS_FILE *FS__fat_fopen(const char *pFileName, const char *pMode, FS_FILE *pFile) {
   \                     FS__fat_fopen: (+1)
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0x0014             MOVS     R4,R2
   \   00000006   0xB094             SUB      SP,SP,#+80
   \   00000008   0x4605             MOV      R5,R0
   1045            FS_u32 unit;
   1046            FS_u32 dstart;
   1047            FS_u32 dsize;
   1048            FS_i32 i;
   1049            FS_FARCHARPTR fname;
   1050            FS__fat_dentry_type s;
   1051            char realname[12];
   1052            int lexp_a;
   1053            int lexp_b;
   1054            
   1055            if (!pFile) {
   \   0000000A   0xF000 0x817E      BEQ.W    ??FS__fat_fopen_0
   1056              return 0;  /* Not a valid pointer to an FS_FILE structure*/
   1057            }
   1058            dsize = FS__fat_findpath(pFile->dev_index, pFileName, &fname, &unit, &dstart);
   \   0000000E   0x69E0             LDR      R0,[R4, #+28]
   \   00000010   0x9001             STR      R0,[SP, #+4]
   \   00000012   0x213A             MOVS     R1,#+58
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0x.... 0x....      BL       FS__CLIB_strchr
   \   0000001A   0x0006             MOVS     R6,R0
   \   0000001C   0xD005             BEQ.N    ??FS__fat_fopen_1
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0x.... 0x....      BL       FS__CLIB_atoi
   \   00000024   0x4683             MOV      R11,R0
   \   00000026   0x1C75             ADDS     R5,R6,#+1
   \   00000028   0xE001             B.N      ??FS__fat_fopen_2
   \                     ??FS__fat_fopen_1: (+1)
   \   0000002A   0xF04F 0x0B00      MOV      R11,#+0
   \                     ??FS__fat_fopen_2: (+1)
   \   0000002E   0x9801             LDR      R0,[SP, #+4]
   \   00000030   0x4659             MOV      R1,R11
   \   00000032   0x.... 0x....      BL       FS__fat_checkunit
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xF000 0x8167      BEQ.W    ??FS__fat_fopen_0
   \   0000003C   0x9801             LDR      R0,[SP, #+4]
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x4659             MOV      R1,R11
   \   00000042   0x.... 0x....      BL       FS__fat_dir_size
   \   00000046   0xF04F 0x0800      MOV      R8,#+0
   \   0000004A   0x4606             MOV      R6,R0
   \   0000004C   0xF10D 0x0934      ADD      R9,SP,#+52
   \                     ??FS__fat_fopen_3: (+1)
   \   00000050   0x215C             MOVS     R1,#+92
   \   00000052   0x4628             MOV      R0,R5
   \   00000054   0x.... 0x....      BL       FS__CLIB_strchr
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD042             BEQ.N    ??FS__fat_fopen_4
   \   0000005C   0x215C             MOVS     R1,#+92
   \   0000005E   0x1C47             ADDS     R7,R0,#+1
   \   00000060   0x4638             MOV      R0,R7
   \   00000062   0x.... 0x....      BL       FS__CLIB_strchr
   \   00000066   0x463D             MOV      R5,R7
   \   00000068   0xB3C8             CBZ.N    R0,??FS__fat_fopen_5
   \   0000006A   0x4639             MOV      R1,R7
   \   0000006C   0xEBA0 0x0A01      SUB      R10,R0,R1
   \   00000070   0xF1BA 0x0F0C      CMP      R10,#+12
   \   00000074   0xDB16             BLT.N    ??FS__fat_fopen_6
   \   00000076   0x2200             MOVS     R2,#+0
   \   00000078   0x4281             CMP      R1,R0
   \   0000007A   0x463B             MOV      R3,R7
   \   0000007C   0xF080 0x8145      BCS.W    ??FS__fat_fopen_0
   \                     ??FS__fat_fopen_7: (+1)
   \   00000080   0x7819             LDRB     R1,[R3, #+0]
   \   00000082   0x292E             CMP      R1,#+46
   \   00000084   0xBF08             IT       EQ 
   \   00000086   0xF1AA 0x0A01      SUBEQ    R10,R10,#+1
   \   0000008A   0xD004             BEQ.N    ??FS__fat_fopen_8
   \   0000008C   0x2A0C             CMP      R2,#+12
   \   0000008E   0xBFBC             ITT      LT 
   \   00000090   0xF802 0x1009      STRBLT   R1,[R2, R9]
   \   00000094   0x1C52             ADDLT    R2,R2,#+1
   \                     ??FS__fat_fopen_8: (+1)
   \   00000096   0x1C5B             ADDS     R3,R3,#+1
   \   00000098   0x4283             CMP      R3,R0
   \   0000009A   0xD3F1             BCC.N    ??FS__fat_fopen_7
   \   0000009C   0xF1BA 0x0F0C      CMP      R10,#+12
   \   000000A0   0xDB04             BLT.N    ??FS__fat_fopen_9
   \   000000A2   0xE132             B.N      ??FS__fat_fopen_0
   \                     ??FS__fat_fopen_6: (+1)
   \   000000A4   0x4652             MOV      R2,R10
   \   000000A6   0xA80D             ADD      R0,SP,#+52
   \   000000A8   0x.... 0x....      BL       FS__CLIB_strncpy
   \                     ??FS__fat_fopen_9: (+1)
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0xF80A 0x0009      STRB     R0,[R10, R9]
   \   000000B2   0xA90D             ADD      R1,SP,#+52
   \   000000B4   0xA810             ADD      R0,SP,#+64
   \   000000B6   0x.... 0x....      BL       FS__fat_make_realname
   \   000000BA   0x9801             LDR      R0,[SP, #+4]
   \   000000BC   0x9600             STR      R6,[SP, #+0]
   \   000000BE   0x4643             MOV      R3,R8
   \   000000C0   0xAA10             ADD      R2,SP,#+64
   \   000000C2   0x4659             MOV      R1,R11
   \   000000C4   0x.... 0x....      BL       FS__fat_find_dir
   \   000000C8   0xEA5F 0x0800      MOVS     R8,R0
   \   000000CC   0xD006             BEQ.N    ??FS__fat_fopen_10
   \   000000CE   0x9801             LDR      R0,[SP, #+4]
   \   000000D0   0x4642             MOV      R2,R8
   \   000000D2   0x4659             MOV      R1,R11
   \   000000D4   0x.... 0x....      BL       FS__fat_dir_size
   \   000000D8   0x4606             MOV      R6,R0
   \   000000DA   0xE000             B.N      ??FS__fat_fopen_5
   \                     ??FS__fat_fopen_10: (+1)
   \   000000DC   0x2600             MOVS     R6,#+0
   \                     ??FS__fat_fopen_5: (+1)
   \   000000DE   0x2F00             CMP      R7,#+0
   \   000000E0   0xD1B6             BNE.N    ??FS__fat_fopen_3
   1059            if (dsize == 0) {
   \                     ??FS__fat_fopen_4: (+1)
   \   000000E2   0x2E00             CMP      R6,#+0
   \   000000E4   0xF000 0x8111      BEQ.W    ??FS__fat_fopen_0
   1060              return 0;  /* Directory not found */
   1061            }
   1062            FS__lb_ioctl(FS__pDevInfo[pFile->dev_index].devdriver, unit, FS_CMD_INC_BUSYCNT, 0, (void*)0);  /* Turn on busy signal */
   \   000000E8   0x....             LDR.N    R0,??DataTable5_1
   \   000000EA   0xF8D0 0x9000      LDR      R9,[R0, #+0]
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x9000             STR      R0,[SP, #+0]
   \   000000F2   0x2300             MOVS     R3,#+0
   \   000000F4   0x69E0             LDR      R0,[R4, #+28]
   \   000000F6   0xEB09 0x1000      ADD      R0,R9,R0, LSL #+4
   \   000000FA   0xF640 0x32B9      MOVW     R2,#+3001
   \   000000FE   0x6880             LDR      R0,[R0, #+8]
   \   00000100   0x4659             MOV      R1,R11
   \   00000102   0x.... 0x....      BL       FS__lb_ioctl
   1063            FS__fat_make_realname(realname, fname);  /* Convert name to FAT real name */
   \   00000106   0x4629             MOV      R1,R5
   \   00000108   0xA802             ADD      R0,SP,#+8
   \   0000010A   0x.... 0x....      BL       FS__fat_make_realname
   1064            /* FileSize = 0 */
   1065            s.data[28] = 0x00;      
   \   0000010E   0x2000             MOVS     R0,#+0
   \   00000110   0x900C             STR      R0,[SP, #+48]
   1066            s.data[29] = 0x00;
   1067            s.data[30] = 0x00;
   1068            s.data[31] = 0x00;
   1069            i = _FS_fat_find_file(pFile->dev_index, unit, realname, &s, dstart, dsize);
   \   00000112   0x9601             STR      R6,[SP, #+4]
   \   00000114   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000118   0xAB05             ADD      R3,SP,#+20
   \   0000011A   0x69E0             LDR      R0,[R4, #+28]
   \   0000011C   0xAA02             ADD      R2,SP,#+8
   \   0000011E   0x4659             MOV      R1,R11
   \   00000120   0x.... 0x....      BL       _FS_fat_find_file
   \   00000124   0x4607             MOV      R7,R0
   1070            /* Delete file */
   1071            lexp_b = (FS__CLIB_strcmp(pMode, "del") == 0);    /* Delete file request */
   \   00000126   0x9814             LDR      R0,[SP, #+80]
   \   00000128   0x....             ADR.N    R1,??DataTable5  ;; "del"
   \   0000012A   0x.... 0x....      BL       FS__CLIB_strcmp
   \   0000012E   0xB970             CBNZ.N   R0,??FS__fat_fopen_11
   \   00000130   0x69E0             LDR      R0,[R4, #+28]
   \   00000132   0x2F00             CMP      R7,#+0
   \   00000134   0xD44C             BMI.N    ??FS__fat_fopen_12
   1072            lexp_a = lexp_b && (i >= 0);                      /* File does exist */
   1073            if (lexp_a) {
   1074              i = FS__fat_DeleteFileOrDir(pFile->dev_index, unit, realname, dstart, dsize, 1);
   1075              if (i != 0) {
   \   00000136   0x2101             MOVS     R1,#+1
   \   00000138   0x9101             STR      R1,[SP, #+4]
   \   0000013A   0x9600             STR      R6,[SP, #+0]
   \   0000013C   0x4643             MOV      R3,R8
   \   0000013E   0xAA02             ADD      R2,SP,#+8
   \   00000140   0x4659             MOV      R1,R11
   \   00000142   0x.... 0x....      BL       FS__fat_DeleteFileOrDir
   \   00000146   0xB3A8             CBZ.N    R0,??FS__fat_fopen_13
   1076                pFile->error = -1;
   \   00000148   0xF04F 0x30FF      MOV      R0,#-1
   \   0000014C   0xE032             B.N      ??FS__fat_fopen_13
   1077              }
   1078              else {
   1079                pFile->error = 0;
   1080              }
   1081              FS__lb_ioctl(FS__pDevInfo[pFile->dev_index].devdriver, pFile->fileid_lo, FS_CMD_FLUSH_CACHE, 2, (void*)0);
   1082              FS__lb_ioctl(FS__pDevInfo[pFile->dev_index].devdriver, unit, FS_CMD_DEC_BUSYCNT, 0, (void*)0);  /* Turn off busy signal */
   1083              return 0;
   1084            }
   1085            else if (lexp_b) {
   1086              FS__lb_ioctl(FS__pDevInfo[pFile->dev_index].devdriver, unit, FS_CMD_DEC_BUSYCNT, 0, (void*)0);  /* Turn off busy signal */
   1087              pFile->error = -1;
   1088              return 0;
   1089            }
   1090            /* Check read only */
   1091            lexp_a = ((i >= 0) && ((s.data[11] & FS_FAT_ATTR_READ_ONLY) != 0)) &&
   1092                    ((pFile->mode_w) || (pFile->mode_a) || (pFile->mode_c));
   \                     ??FS__fat_fopen_11: (+1)
   \   0000014E   0x2F00             CMP      R7,#+0
   \   00000150   0xF104 0x0522      ADD      R5,R4,#+34
   \   00000154   0xD461             BMI.N    ??FS__fat_fopen_14
   \   00000156   0xF89D 0x001F      LDRB     R0,[SP, #+31]
   \   0000015A   0x07C0             LSLS     R0,R0,#+31
   \   0000015C   0xD547             BPL.N    ??FS__fat_fopen_15
   \   0000015E   0x78A8             LDRB     R0,[R5, #+2]
   \   00000160   0x2800             CMP      R0,#+0
   \   00000162   0xBF01             ITTTT    EQ 
   \   00000164   0x78E8             LDRBEQ   R0,[R5, #+3]
   \   00000166   0x2800             CMPEQ    R0,#+0
   \   00000168   0x7928             LDRBEQ   R0,[R5, #+4]
   \   0000016A   0x2800             CMPEQ    R0,#+0
   \   0000016C   0xF040 0x80C1      BNE.W    ??FS__fat_fopen_16
   1093            if (lexp_a) {
   1094              /* Files is RO and we try to create, write or append */
   1095              FS__lb_ioctl(FS__pDevInfo[pFile->dev_index].devdriver, unit, FS_CMD_DEC_BUSYCNT, 0, (void*)0);  /* Turn off busy signal */
   1096              return 0;
   1097            }
   1098            lexp_a = ( i>= 0) && (!pFile->mode_a) && (((pFile->mode_w) && (!pFile->mode_r)) || 
   1099                    ((pFile->mode_w) && (pFile->mode_c) && (pFile->mode_r)) );
   1100            if (lexp_a) {
   1101              /* Delete old file */
   1102              i = FS__fat_DeleteFileOrDir(pFile->dev_index, unit, realname, dstart, dsize, 1);
   1103              /* FileSize = 0 */
   1104              s.data[28] = 0x00;      
   1105              s.data[29] = 0x00;
   1106              s.data[30] = 0x00;
   1107              s.data[31] = 0x00;
   1108              i=-1;
   1109            }
   1110            if ((!pFile->mode_c) && (i < 0)) {
   1111              /* File does not exist and we must not create */
   1112              FS__lb_ioctl(FS__pDevInfo[pFile->dev_index].devdriver, unit, FS_CMD_DEC_BUSYCNT, 0, (void*)0);  /* Turn off busy signal */
   1113              return 0;
   1114            }
   1115            else if ((pFile->mode_c) && (i < 0)) {
   1116              /* Create new file */
   1117              i = _FS_fat_create_file(pFile->dev_index, unit, realname, dstart, dsize);
   1118              if (i < 0) {
   1119                /* Could not create file */
   1120                if (i == -2) {
   1121                  /* Directory is full, try to increase */
   1122                  i = _FS_fat_IncDir(pFile->dev_index, unit, dstart, &dsize);
   1123                  if (i > 0) {
   1124                    i = _FS_fat_create_file(pFile->dev_index, unit, realname, dstart, dsize);
   1125                  }
   1126                }
   1127                if (i < 0) {
   1128                  FS__lb_ioctl(FS__pDevInfo[pFile->dev_index].devdriver, unit, FS_CMD_DEC_BUSYCNT, 0, (void*)0);  /* Turn off busy signal */
   1129                  return 0;
   1130                }
   1131              }
   1132            }
   1133            pFile->fileid_lo  = unit;
   1134            pFile->fileid_hi  = i;
   1135            pFile->fileid_ex  = dstart;
   1136            pFile->EOFClust   = -1;
   \                     ??FS__fat_fopen_17: (+1)
   \   00000170   0xF04F 0x30FF      MOV      R0,#-1
   \   00000174   0xF8C4 0xB000      STR      R11,[R4, #+0]
   \   00000178   0x6067             STR      R7,[R4, #+4]
   \   0000017A   0x60E0             STR      R0,[R4, #+12]
   \   0000017C   0xF8C4 0x8008      STR      R8,[R4, #+8]
   1137            pFile->CurClust   = 0;
   \   00000180   0x2000             MOVS     R0,#+0
   \   00000182   0x6120             STR      R0,[R4, #+16]
   1138            pFile->error      = 0;
   \   00000184   0x8420             STRH     R0,[R4, #+32]
   1139            pFile->size       = (FS_u32)s.data[28];   /* FileSize */
   \   00000186   0xF89D 0x0030      LDRB     R0,[SP, #+48]
   \   0000018A   0x61A0             STR      R0,[R4, #+24]
   1140            pFile->size      += (FS_u32)0x100UL * s.data[29];
   \   0000018C   0xF89D 0x1031      LDRB     R1,[SP, #+49]
   \   00000190   0xEB00 0x2001      ADD      R0,R0,R1, LSL #+8
   \   00000194   0x61A0             STR      R0,[R4, #+24]
   1141            pFile->size      += (FS_u32)0x10000UL * s.data[30];
   \   00000196   0xF89D 0x1032      LDRB     R1,[SP, #+50]
   \   0000019A   0xEB00 0x4001      ADD      R0,R0,R1, LSL #+16
   \   0000019E   0x61A0             STR      R0,[R4, #+24]
   1142            pFile->size      += (FS_u32)0x1000000UL * s.data[31];
   \   000001A0   0xF89D 0x1033      LDRB     R1,[SP, #+51]
   \   000001A4   0xEB00 0x6001      ADD      R0,R0,R1, LSL #+24
   \   000001A8   0x61A0             STR      R0,[R4, #+24]
   1143            if (pFile->mode_a) {
   \   000001AA   0x78E9             LDRB     R1,[R5, #+3]
   \   000001AC   0x2900             CMP      R1,#+0
   \   000001AE   0xBF08             IT       EQ 
   \   000001B0   0x2000             MOVEQ    R0,#+0
   1144              pFile->filepos   = pFile->size;
   1145            }
   1146            else {
   1147              pFile->filepos   = 0;
   \   000001B2   0xE0B2             B.N      ??FS__fat_fopen_18
   \                     ??FS__fat_fopen_13: (+1)
   \   000001B4   0x8420             STRH     R0,[R4, #+32]
   \   000001B6   0x2302             MOVS     R3,#+2
   \   000001B8   0x2000             MOVS     R0,#+0
   \   000001BA   0x9000             STR      R0,[SP, #+0]
   \   000001BC   0xF44F 0x727A      MOV      R2,#+1000
   \   000001C0   0x69E0             LDR      R0,[R4, #+28]
   \   000001C2   0x6821             LDR      R1,[R4, #+0]
   \   000001C4   0xEB09 0x1000      ADD      R0,R9,R0, LSL #+4
   \   000001C8   0x6880             LDR      R0,[R0, #+8]
   \   000001CA   0x.... 0x....      BL       FS__lb_ioctl
   \   000001CE   0xE090             B.N      ??FS__fat_fopen_16
   \                     ??FS__fat_fopen_12: (+1)
   \   000001D0   0x2100             MOVS     R1,#+0
   \   000001D2   0xEB09 0x1000      ADD      R0,R9,R0, LSL #+4
   \   000001D6   0x9100             STR      R1,[SP, #+0]
   \   000001D8   0x2300             MOVS     R3,#+0
   \   000001DA   0x6880             LDR      R0,[R0, #+8]
   \   000001DC   0xF640 0x32BA      MOVW     R2,#+3002
   \   000001E0   0x4659             MOV      R1,R11
   \   000001E2   0x.... 0x....      BL       FS__lb_ioctl
   \   000001E6   0xF04F 0x30FF      MOV      R0,#-1
   \   000001EA   0x8420             STRH     R0,[R4, #+32]
   \   000001EC   0xE08D             B.N      ??FS__fat_fopen_0
   \                     ??FS__fat_fopen_15: (+1)
   \   000001EE   0x78E8             LDRB     R0,[R5, #+3]
   \   000001F0   0xB998             CBNZ.N   R0,??FS__fat_fopen_14
   \   000001F2   0x78A8             LDRB     R0,[R5, #+2]
   \   000001F4   0xB188             CBZ.N    R0,??FS__fat_fopen_14
   \   000001F6   0x7868             LDRB     R0,[R5, #+1]
   \   000001F8   0xB110             CBZ.N    R0,??FS__fat_fopen_19
   \   000001FA   0x7928             LDRB     R0,[R5, #+4]
   \   000001FC   0x2800             CMP      R0,#+0
   \   000001FE   0xD0B7             BEQ.N    ??FS__fat_fopen_17
   \                     ??FS__fat_fopen_19: (+1)
   \   00000200   0x2001             MOVS     R0,#+1
   \   00000202   0x9001             STR      R0,[SP, #+4]
   \   00000204   0x9600             STR      R6,[SP, #+0]
   \   00000206   0x4643             MOV      R3,R8
   \   00000208   0x69E0             LDR      R0,[R4, #+28]
   \   0000020A   0xAA02             ADD      R2,SP,#+8
   \   0000020C   0x4659             MOV      R1,R11
   \   0000020E   0x.... 0x....      BL       FS__fat_DeleteFileOrDir
   \   00000212   0x2000             MOVS     R0,#+0
   \   00000214   0x900C             STR      R0,[SP, #+48]
   \   00000216   0xF04F 0x37FF      MOV      R7,#-1
   \                     ??FS__fat_fopen_14: (+1)
   \   0000021A   0x7928             LDRB     R0,[R5, #+4]
   \   0000021C   0x2800             CMP      R0,#+0
   \   0000021E   0xD065             BEQ.N    ??FS__fat_fopen_20
   \   00000220   0x2F00             CMP      R7,#+0
   \   00000222   0xD5A5             BPL.N    ??FS__fat_fopen_17
   \   00000224   0x9600             STR      R6,[SP, #+0]
   \   00000226   0x4643             MOV      R3,R8
   \   00000228   0x69E0             LDR      R0,[R4, #+28]
   \   0000022A   0xAA02             ADD      R2,SP,#+8
   \   0000022C   0x4659             MOV      R1,R11
   \   0000022E   0x.... 0x....      BL       _FS_fat_create_file
   \   00000232   0x4607             MOV      R7,R0
   \   00000234   0x2F00             CMP      R7,#+0
   \   00000236   0xD59B             BPL.N    ??FS__fat_fopen_17
   \   00000238   0xF117 0x0F02      CMN      R7,#+2
   \   0000023C   0xD159             BNE.N    ??FS__fat_fopen_16
   \   0000023E   0x69E0             LDR      R0,[R4, #+28]
   \   00000240   0x9000             STR      R0,[SP, #+0]
   \   00000242   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000246   0xD108             BNE.N    ??FS__fat_fopen_21
   \   00000248   0x9900             LDR      R1,[SP, #+0]
   \   0000024A   0x....             LDR.N    R0,??DataTable5_2
   \   0000024C   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   00000250   0xEB00 0x104B      ADD      R0,R0,R11, LSL #+5
   \   00000254   0x89C0             LDRH     R0,[R0, #+14]
   \   00000256   0x2800             CMP      R0,#+0
   \   00000258   0xD14B             BNE.N    ??FS__fat_fopen_16
   \                     ??FS__fat_fopen_21: (+1)
   \   0000025A   0x9800             LDR      R0,[SP, #+0]
   \   0000025C   0x2300             MOVS     R3,#+0
   \   0000025E   0x4642             MOV      R2,R8
   \   00000260   0x4659             MOV      R1,R11
   \   00000262   0x.... 0x....      BL       FS__fat_FAT_find_eof
   \   00000266   0x0002             MOVS     R2,R0
   \   00000268   0xD443             BMI.N    ??FS__fat_fopen_16
   \   0000026A   0x9800             LDR      R0,[SP, #+0]
   \   0000026C   0x4659             MOV      R1,R11
   \   0000026E   0x.... 0x....      BL       FS__fat_FAT_alloc
   \   00000272   0x2800             CMP      R0,#+0
   \   00000274   0xD43D             BMI.N    ??FS__fat_fopen_16
   \   00000276   0x9900             LDR      R1,[SP, #+0]
   \   00000278   0x....             LDR.N    R0,??DataTable5_2
   \   0000027A   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   0000027E   0xEB00 0x1A4B      ADD      R10,R0,R11, LSL #+5
   \   00000282   0xF89A 0x001C      LDRB     R0,[R10, #+28]
   \   00000286   0x1986             ADDS     R6,R0,R6
   \   00000288   0xF44F 0x7000      MOV      R0,#+512
   \   0000028C   0x.... 0x....      BL       FS__fat_malloc
   \   00000290   0x0007             MOVS     R7,R0
   \   00000292   0xD02E             BEQ.N    ??FS__fat_fopen_16
   \   00000294   0xF44F 0x7200      MOV      R2,#+512
   \   00000298   0x2100             MOVS     R1,#+0
   \   0000029A   0x.... 0x....      BL       FS__CLIB_memset
   \   0000029E   0xF89A 0x001C      LDRB     R0,[R10, #+28]
   \   000002A2   0xEBA6 0x0A00      SUB      R10,R6,R0
   \   000002A6   0x45B2             CMP      R10,R6
   \   000002A8   0xD215             BCS.N    ??FS__fat_fopen_22
   \                     ??FS__fat_fopen_23: (+1)
   \   000002AA   0x9800             LDR      R0,[SP, #+0]
   \   000002AC   0x4653             MOV      R3,R10
   \   000002AE   0x4642             MOV      R2,R8
   \   000002B0   0x4659             MOV      R1,R11
   \   000002B2   0x.... 0x....      BL       FS__fat_dir_realsec
   \   000002B6   0xB360             CBZ.N    R0,??FS__fat_fopen_24
   \   000002B8   0x4602             MOV      R2,R0
   \   000002BA   0x9800             LDR      R0,[SP, #+0]
   \   000002BC   0xEB09 0x1000      ADD      R0,R9,R0, LSL #+4
   \   000002C0   0x463B             MOV      R3,R7
   \   000002C2   0x6880             LDR      R0,[R0, #+8]
   \   000002C4   0x4659             MOV      R1,R11
   \   000002C6   0x.... 0x....      BL       FS__lb_write
   \   000002CA   0x2800             CMP      R0,#+0
   \   000002CC   0xD421             BMI.N    ??FS__fat_fopen_24
   \   000002CE   0xF10A 0x0A01      ADD      R10,R10,#+1
   \   000002D2   0x45B2             CMP      R10,R6
   \   000002D4   0xD3E9             BCC.N    ??FS__fat_fopen_23
   \                     ??FS__fat_fopen_22: (+1)
   \   000002D6   0x4638             MOV      R0,R7
   \   000002D8   0x.... 0x....      BL       FS__fat_free
   \   000002DC   0x9600             STR      R6,[SP, #+0]
   \   000002DE   0x4643             MOV      R3,R8
   \   000002E0   0x69E0             LDR      R0,[R4, #+28]
   \   000002E2   0xAA02             ADD      R2,SP,#+8
   \   000002E4   0x4659             MOV      R1,R11
   \   000002E6   0x.... 0x....      BL       _FS_fat_create_file
   \   000002EA   0x4607             MOV      R7,R0
   \                     ??FS__fat_fopen_20: (+1)
   \   000002EC   0x2F00             CMP      R7,#+0
   \   000002EE   0xF57F 0xAF3F      BPL.W    ??FS__fat_fopen_17
   \                     ??FS__fat_fopen_16: (+1)
   \   000002F2   0x2000             MOVS     R0,#+0
   \   000002F4   0x9000             STR      R0,[SP, #+0]
   \   000002F6   0x2300             MOVS     R3,#+0
   \   000002F8   0x69E0             LDR      R0,[R4, #+28]
   \   000002FA   0xEB09 0x1000      ADD      R0,R9,R0, LSL #+4
   \   000002FE   0xF640 0x32BA      MOVW     R2,#+3002
   \   00000302   0x6880             LDR      R0,[R0, #+8]
   \   00000304   0x4659             MOV      R1,R11
   \   00000306   0x.... 0x....      BL       FS__lb_ioctl
   \                     ??FS__fat_fopen_0: (+1)
   \   0000030A   0x2000             MOVS     R0,#+0
   \   0000030C   0xB015             ADD      SP,SP,#+84
   \   0000030E   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??FS__fat_fopen_24: (+1)
   \   00000312   0x4638             MOV      R0,R7
   \   00000314   0x.... 0x....      BL       FS__fat_free
   \   00000318   0xE7EB             B.N      ??FS__fat_fopen_16
   \                     ??FS__fat_fopen_18: (+1)
   \   0000031A   0x6160             STR      R0,[R4, #+20]
   1148            }
   1149            pFile->inuse     = 1;
   \   0000031C   0x2001             MOVS     R0,#+1
   \   0000031E   0x7028             STRB     R0,[R5, #+0]
   1150            return pFile;
   \   00000320   0xB015             ADD      SP,SP,#+84
   \   00000322   0x4620             MOV      R0,R4
   \   00000324   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1151          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x64 0x65          DC8      "del"
   \              0x6C 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     FS__pDevInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     FS__FAT_aBPBUnit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x0FFFFFF8         DC32     0xffffff8

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x64 0x65          DC8 "del"
   \              0x6C 0x00    
   1152          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      96   FS__fat_DeleteFileOrDir
        96   -> FS__CLIB_strlen
        96   -> FS__CLIB_strncmp
        96   -> FS__fat_dir_realsec
        96   -> FS__fat_free
        96   -> FS__fat_malloc
        96   -> FS__fat_which_type
        96   -> FS__lb_read
        96   -> FS__lb_write
      40   FS__fat_dir_realsec
        40   -> FS__fat_diskclust
        40   -> FS__fat_find_dir
        40   -> FS__fat_which_type
      16   FS__fat_dir_size
        16   -> FS__fat_FAT_find_eof
      48   FS__fat_find_dir
        48   -> FS__CLIB_strlen
        48   -> FS__CLIB_strncmp
        48   -> FS__fat_dir_realsec
        48   -> FS__fat_free
        48   -> FS__fat_malloc
        48   -> FS__lb_read
      64   FS__fat_findpath
        64   -> FS__CLIB_atoi
        64   -> FS__CLIB_strchr
        64   -> FS__CLIB_strncpy
        64   -> FS__fat_checkunit
        64   -> FS__fat_dir_size
        64   -> FS__fat_find_dir
        64   -> FS__fat_make_realname
     120   FS__fat_fopen
       120   -> FS__CLIB_atoi
       120   -> FS__CLIB_memset
       120   -> FS__CLIB_strchr
       120   -> FS__CLIB_strcmp
       120   -> FS__CLIB_strncpy
       120   -> FS__fat_DeleteFileOrDir
       120   -> FS__fat_FAT_alloc
       120   -> FS__fat_FAT_find_eof
       120   -> FS__fat_checkunit
       120   -> FS__fat_dir_realsec
       120   -> FS__fat_dir_size
       120   -> FS__fat_find_dir
       120   -> FS__fat_free
       120   -> FS__fat_make_realname
       120   -> FS__fat_malloc
       120   -> FS__lb_ioctl
       120   -> FS__lb_write
       120   -> _FS_fat_create_file
       120   -> _FS_fat_find_file
      24   FS__fat_make_realname
        24   -> FS__CLIB_strchr
        24   -> FS__CLIB_strlen
        24   -> FS__CLIB_toupper
        24   -> __aeabi_memset
      48   _FS_fat_create_file
        48   -> FS_X_OS_GetDate
        48   -> FS_X_OS_GetTime
        48   -> FS__CLIB_strlen
        48   -> FS__CLIB_strncpy
        48   -> FS__fat_FAT_alloc
        48   -> FS__fat_dir_realsec
        48   -> FS__fat_free
        48   -> FS__fat_malloc
        48   -> FS__lb_read
        48   -> FS__lb_write
      48   _FS_fat_find_file
        48   -> FS__CLIB_memcpy
        48   -> FS__CLIB_strlen
        48   -> FS__CLIB_strncmp
        48   -> FS__fat_dir_realsec
        48   -> FS__fat_free
        48   -> FS__fat_malloc
        48   -> FS__lb_read


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       6  ??Subroutine4_0
      26  ?Subroutine0
       6  ?Subroutine1
       6  ?Subroutine2
       6  ?Subroutine3
       4  ?_0
     946  FS__fat_DeleteFileOrDir
     124  FS__fat_dir_realsec
      88  FS__fat_dir_size
     216  FS__fat_find_dir
     226  FS__fat_findpath
     808  FS__fat_fopen
     138  FS__fat_make_realname
     292  _FS_fat_create_file
     170  _FS_fat_find_file

 
     4 bytes in section .rodata
 3 074 bytes in section .text
 
 3 074 bytes of CODE  memory
     4 bytes of CONST memory

Errors: none
Warnings: none
