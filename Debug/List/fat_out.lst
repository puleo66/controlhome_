###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       09/Feb/2018  16:14:53
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\HW Projects\ControlHome\CntrHome - RF69w\uC-FatFS\fsl\fat\fat_out.c
#    Command line =  
#        "E:\HW Projects\ControlHome\CntrHome -
#        RF69w\uC-FatFS\fsl\fat\fat_out.c" -lCN "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Debug\List" -o "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Debug\Obj" --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\APP\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\BSP\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\CPU\inc\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-CPU\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-RTC\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-LIB\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uCOS-II\Ports\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uCOS-II\Source\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\I2C-Out\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Direct_Sw\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\Wdt_led\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-LCD\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-RF\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\api\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\config\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\os\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\fsl\fat\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\clib\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\lbl\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\device\mmc\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-FatFS\file\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-Terminal\src\" -I "E:\HW
#        Projects\ControlHome\CntrHome - RF69w\uC-Terminal\inc\" -Oh
#    List file    =  
#        E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\List\fat_out.lst
#    Object file  =  
#        E:\HW Projects\ControlHome\CntrHome - RF69w\Debug\Obj\fat_out.o
#
###############################################################################

E:\HW Projects\ControlHome\CntrHome - RF69w\uC-FatFS\fsl\fat\fat_out.c
      1          /*
      2          **********************************************************************
      3          *                          Micrium, Inc.
      4          *                      949 Crestview Circle
      5          *                     Weston,  FL 33327-1848
      6          *
      7          *                            uC/FS
      8          *
      9          *             (c) Copyright 2001 - 2003, Micrium, Inc.
     10          *                      All rights reserved.
     11          *
     12          ***********************************************************************
     13          
     14          ----------------------------------------------------------------------
     15          File        : fat_out.c
     16          Purpose     : FAT12/FAT16/FAT32 Filesystem file write routines
     17          ----------------------------------------------------------------------
     18          Known problems or limitations with current version
     19          ----------------------------------------------------------------------
     20          None.
     21          ---------------------------END-OF-HEADER------------------------------
     22          */
     23          
     24          /*********************************************************************
     25          *
     26          *             #include Section
     27          *
     28          **********************************************************************
     29          */
     30          
     31          #include "fs_conf.h"
     32          #include "fs_port.h"
     33          #ifndef FS_FARCHARPTR
     34            #define FS_FARCHARPTR char *
     35          #endif
     36          #ifndef FS_FAT_FWRITE_UPDATE_DIR
     37            #define FS_FAT_FWRITE_UPDATE_DIR 1
     38          #endif
     39          #include "fs_dev.h"
     40          #include "fs_api.h"
     41          #include "fs_fsl.h"
     42          #include "fs_int.h"
     43          #include "fs_os.h"
     44          #include "fs_lbl.h"
     45          #include "fs_fat.h"
     46          #include "fs_clib.h"
     47          
     48          
     49          /*********************************************************************
     50          *
     51          *             Local functions
     52          *
     53          **********************************************************************
     54          */
     55          
     56          /*********************************************************************
     57          *
     58          *             _FS_fat_write_dentry
     59          *
     60            Description:
     61            FS internal function. Write a directory entry.
     62          
     63            Parameters:
     64            Idx         - Index of device in the device information table 
     65                          referred by FS__pDevInfo.
     66            Unit        - Unit number.
     67            FirstClust  - First cluster of the file, which's directory entry 
     68                          will be written.
     69            pDirEntry   - Pointer to an FS__fat_dentry_type structure, which 
     70                          contains the new directory entry.
     71            DirSec      - Sector, which contains the directory entry.
     72            pBuffer     - Pointer to a buffer, which contains the sector with 
     73                          the old directory entry.
     74           
     75            Return value:
     76            ==1         - Directory entry has been written.
     77            ==0         - An error has occured.
     78          */
     79          
     80          static int _FS_fat_write_dentry(int Idx, FS_u32 Unit, FS_u32 FirstClust, FS__fat_dentry_type *pDirEntry, 
     81                                          FS_u32 DirSec, char *pBuffer) {
     82            FS__fat_dentry_type *s;
     83            FS_u32 value;
     84            int err;
     85          
     86            if (DirSec == 0) {
     87              return 0;  /* Not a valid directory sector */
     88            }
     89            if (pBuffer == 0) {
     90              return 0;  /* No buffer */
     91            }
     92            /* Scan for the directory entry with FirstClust in the directory sector */
     93            s = (FS__fat_dentry_type*)pBuffer;
     94            while (1) {
     95              if (s >= (FS__fat_dentry_type*)(pBuffer + FS_FAT_SEC_SIZE)) {
     96                break;  /* End of sector reached */
     97              }
     98              value = (FS_u32)s->data[26] + 0x100UL * s->data[27] + 0x10000UL * s->data[20] + 0x1000000UL * s->data[21];
     99              if (value == FirstClust) {
    100                break;  /* Entry found */
    101              }
    102              s++;
    103            }
    104            if (s < (FS__fat_dentry_type*)(pBuffer + FS_FAT_SEC_SIZE)) {
    105              if (pDirEntry) {
    106                FS__CLIB_memcpy(s, pDirEntry, sizeof(FS__fat_dentry_type));
    107                err = FS__lb_write(FS__pDevInfo[Idx].devdriver, Unit, DirSec, (void*)pBuffer);
    108                if (err < 0) {
    109                  return 0;
    110                }
    111              }
    112              return 1;
    113            }
    114            return 0;
    115          }
    116          
    117          
    118          /*********************************************************************
    119          *
    120          *             _FS_fat_read_dentry
    121          *
    122            Description:
    123            FS internal function. Read a directory entry.
    124          
    125            Parameters:
    126            Idx         - Index of device in the device information table 
    127                          referred by FS__pDevInfo.
    128            Unit        - Unit number.
    129            FirstClust  - First cluster of the file, which's directory entry 
    130                          will be read.
    131            DirStart    - Start of directory, where to read the entry.
    132            pDirEntry   - Pointer to an FS__fat_dentry_type structure, which is 
    133                          used to read the directory entry.
    134            pDirSec     - Pointer to an FS_u32, which is used to store the sector
    135                          number, in which the directory entry has been read.
    136            pBuffer     - Pointer to a buffer, which is used for reading the
    137                          directory.
    138           
    139            Return value:
    140            ==1         - Directory entry has been read.
    141            ==0         - An error has occured.
    142          */
    143          
    144          static int _FS_fat_read_dentry(int Idx, FS_u32 Unit, FS_u32 FirstClust, 
    145                                        FS_u32 DirStart, FS__fat_dentry_type *pDirEntry, FS_u32 *pDirSec, char *pBuffer) {
    146            FS_u32 i;
    147            FS_u32 dsize;
    148            FS_u32 value;
    149            FS__fat_dentry_type *s;
    150            int err;
    151          
    152            if (pBuffer == 0) {
    153              return 0;
    154            }
    155            dsize  =  FS__fat_dir_size(Idx, Unit, DirStart);
    156            /* Read the directory */
    157            for (i = 0; i < dsize; i++) {
    158              *pDirSec = FS__fat_dir_realsec(Idx, Unit, DirStart, i);
    159              if (*pDirSec == 0) {
    160                return 0;  /* Unable to translate relative directory sector to absolute setor */
    161              }
    162              err = FS__lb_read(FS__pDevInfo[Idx].devdriver, Unit, *pDirSec, (void*)pBuffer);
    163              if (err < 0) {
    164                return 0;
    165              }
    166              /* Scan for entry with FirstClus in the sector */
    167              s = (FS__fat_dentry_type*)pBuffer;
    168              while (1) {
    169                if (s >= (FS__fat_dentry_type*)(pBuffer + FS_FAT_SEC_SIZE)) {
    170                  break;  /* End of sector reached */
    171                }
    172                value = (FS_u32)s->data[26] + 0x100UL * s->data[27] + 0x10000UL * s->data[20] + 0x1000000UL * s->data[21];
    173                if (value == FirstClust) {
    174                  break;  /* Entry found */
    175                }
    176                s++;
    177              }
    178              if (s < (FS__fat_dentry_type*)(pBuffer + FS_FAT_SEC_SIZE)) {
    179                if (pDirEntry) {
    180                  /* Read the complete directory entry from the buffer */
    181                  FS__CLIB_memcpy(pDirEntry, s, sizeof(FS__fat_dentry_type));
    182                }
    183                return 1;
    184              }
    185            }
    186            return 0;
    187          }
    188          
    189          
    190          /*********************************************************************
    191          *
    192          *             Global functions
    193          *
    194          **********************************************************************
    195          */
    196          
    197          /*********************************************************************
    198          *
    199          *             FS__fat_fwrite
    200          *
    201            Description:
    202            FS internal function. Write data to a file.
    203          
    204            Parameters:
    205            pData       - Pointer to data, which will be written to the file. 
    206            Size        - Size of an element to be transferred to a file.
    207            N           - Number of elements to be transferred to the file.
    208            pFile       - Pointer to a FS_FILE data structure.
    209            
    210            Return value:
    211            Number of elements written.
    212          */
    213          

   \                                 In section .text, align 2, keep-with-next
    214          FS_size_t FS__fat_fwrite(const void *pData, FS_size_t Size, FS_size_t N, FS_FILE *pFile) {
   \                     FS__fat_fwrite: (+1)
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0x001C             MOVS     R4,R3
   \   00000006   0xB08E             SUB      SP,SP,#+56
   \   00000008   0x4606             MOV      R6,R0
   \   0000000A   0x4615             MOV      R5,R2
    215            FS_size_t todo;
    216            FS_u32 dstart;
    217            FS_u32 dsize;
    218            FS_u32 bytesperclus;
    219            FS_u32 datastart;
    220            FS_u32 fatsize;
    221            FS_u32 fileclustnum;
    222            FS_u32 diskclustnum;
    223            FS_u32 prevclust;
    224            FS_i32 last;
    225            FS_i32 i;
    226            FS_i32 j;
    227          #if (FS_FAT_FWRITE_UPDATE_DIR)
    228            FS__fat_dentry_type s;
    229            FS_u32 dsec = 0;
    230            FS_u16 val;
    231          #endif /* FS_FAT_FWRITE_UPDATE_DIR */
    232            int err;
    233            int lexp;
    234            char *buffer;
    235          
    236            if (!pFile) {
   \   0000000C   0xD064             BEQ.N    ??FS__fat_fwrite_0
    237                return 0;
    238            }
    239            /* Check if media is OK */
    240            err = FS__lb_status(FS__pDevInfo[pFile->dev_index].devdriver, pFile->fileid_lo);
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable0
   \   00000012   0xF8D0 0x8000      LDR      R8,[R0, #+0]
   \   00000016   0x69E0             LDR      R0,[R4, #+28]
   \   00000018   0x6821             LDR      R1,[R4, #+0]
   \   0000001A   0xEB08 0x1000      ADD      R0,R8,R0, LSL #+4
   \   0000001E   0x6880             LDR      R0,[R0, #+8]
   \   00000020   0x.... 0x....      BL       FS__lb_status
    241            if (err == FS_LBL_MEDIACHANGED) {
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD103             BNE.N    ??FS__fat_fwrite_1
    242              pFile->error = FS_ERR_DISKCHANGED;
   \   00000028   0xF06F 0x007F      MVN      R0,#+127
   \   0000002C   0x8420             STRH     R0,[R4, #+32]
    243              return 0;
   \   0000002E   0xE053             B.N      ??FS__fat_fwrite_0
    244            }
    245            else if (err < 0) {
   \                     ??FS__fat_fwrite_1: (+1)
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD503             BPL.N    ??FS__fat_fwrite_2
    246              pFile->error = FS_ERR_WRITEERROR;
   \   00000034   0xF06F 0x006F      MVN      R0,#+111
   \   00000038   0x8420             STRH     R0,[R4, #+32]
    247              return 0;
   \   0000003A   0xE04D             B.N      ??FS__fat_fwrite_0
    248            }
    249            buffer = FS__fat_malloc(FS_FAT_SEC_SIZE);
   \                     ??FS__fat_fwrite_2: (+1)
   \   0000003C   0xF44F 0x7000      MOV      R0,#+512
   \   00000040   0x.... 0x....      BL       FS__fat_malloc
   \   00000044   0xEA5F 0x0900      MOVS     R9,R0
    250            if (!buffer) {
   \   00000048   0xD046             BEQ.N    ??FS__fat_fwrite_0
    251              return 0;
    252            }
    253            fatsize = FS__FAT_aBPBUnit[pFile->dev_index][pFile->fileid_lo].FATSz16;
   \   0000004A   0x69E0             LDR      R0,[R4, #+28]
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x.... 0x....      LDR.W    R11,??DataTable0_1
   \   00000052   0xEB0B 0x1240      ADD      R2,R11,R0, LSL #+5
   \   00000056   0xEB02 0x1241      ADD      R2,R2,R1, LSL #+5
   \   0000005A   0x8A53             LDRH     R3,[R2, #+18]
   \   0000005C   0x9302             STR      R3,[SP, #+8]
    254            if (fatsize == 0) {
   \   0000005E   0xB90B             CBNZ.N   R3,??FS__fat_fwrite_3
    255              /* FAT32 */
    256              fatsize = FS__FAT_aBPBUnit[pFile->dev_index][pFile->fileid_lo].FATSz32;
   \   00000060   0x6853             LDR      R3,[R2, #+4]
   \   00000062   0x9302             STR      R3,[SP, #+8]
    257            }
    258            todo = N * Size;  /* Number of bytes to be written */
   \                     ??FS__fat_fwrite_3: (+1)
   \   00000064   0x9B0E             LDR      R3,[SP, #+56]
   \   00000066   0x436B             MULS     R3,R3,R5
   \   00000068   0x001F             MOVS     R7,R3
   \   0000006A   0x9304             STR      R3,[SP, #+16]
    259            if (!todo) {
   \   0000006C   0xD031             BEQ.N    ??FS__fat_fwrite_4
    260              FS__fat_free(buffer);
    261              return 0;
    262            }
    263            /* Alloc new clusters if required */
    264            bytesperclus = (FS_u32)FS__FAT_aBPBUnit[pFile->dev_index][pFile->fileid_lo].SecPerClus *
    265                           ((FS_u32)FS__FAT_aBPBUnit[pFile->dev_index][pFile->fileid_lo].BytesPerSec);
   \   0000006E   0x7F13             LDRB     R3,[R2, #+28]
   \   00000070   0x8992             LDRH     R2,[R2, #+12]
   \   00000072   0x435A             MULS     R2,R2,R3
   \   00000074   0x9200             STR      R2,[SP, #+0]
   \   00000076   0x6962             LDR      R2,[R4, #+20]
    266            /* Calculate number of clusters required */
    267            i = (pFile->filepos + todo) / bytesperclus;
    268            if ((pFile->filepos + todo) % bytesperclus) {
   \   00000078   0xF8DD 0xC000      LDR      R12,[SP, #+0]
   \   0000007C   0x18BB             ADDS     R3,R7,R2
   \   0000007E   0x9A00             LDR      R2,[SP, #+0]
   \   00000080   0xFBB3 0xF2F2      UDIV     R2,R3,R2
   \   00000084   0xFB0C 0x3312      MLS      R3,R12,R2,R3
   \   00000088   0xB103             CBZ.N    R3,??FS__fat_fwrite_5
    269              i++;
   \   0000008A   0x1C52             ADDS     R2,R2,#+1
    270            }
    271            /* Calculate clusters already allocated */
    272            j = pFile->size / bytesperclus;
   \                     ??FS__fat_fwrite_5: (+1)
   \   0000008C   0x69A3             LDR      R3,[R4, #+24]
   \   0000008E   0xFBB3 0xF5FC      UDIV     R5,R3,R12
    273            lexp = (pFile->size % bytesperclus);
    274            lexp = lexp || (pFile->size == 0);
   \   00000092   0xFB0C 0x3C15      MLS      R12,R12,R5,R3
   \   00000096   0xF1BC 0x0F00      CMP      R12,#+0
   \   0000009A   0xD100             BNE.N    ??FS__fat_fwrite_6
   \   0000009C   0xB903             CBNZ.N   R3,??FS__fat_fwrite_7
    275            if (lexp) {
    276              j++;
   \                     ??FS__fat_fwrite_6: (+1)
   \   0000009E   0x1C6D             ADDS     R5,R5,#+1
    277            }
    278            i -= j;
   \                     ??FS__fat_fwrite_7: (+1)
   \   000000A0   0xEBA2 0x0A05      SUB      R10,R2,R5
    279            if (i > 0) {
   \   000000A4   0xF1BA 0x0F01      CMP      R10,#+1
   \   000000A8   0xDB1B             BLT.N    ??FS__fat_fwrite_8
    280              /* Alloc new clusters */
    281              last = pFile->EOFClust;
   \   000000AA   0x68E2             LDR      R2,[R4, #+12]
    282              if (last < 0) {
   \   000000AC   0x2A00             CMP      R2,#+0
   \   000000AE   0xD504             BPL.N    ??FS__fat_fwrite_9
    283                /* Position of EOF is unknown, so we scan the whole file to find it */
    284                last = FS__fat_FAT_find_eof(pFile->dev_index, pFile->fileid_lo, pFile->fileid_hi, 0);
   \   000000B0   0x6862             LDR      R2,[R4, #+4]
   \   000000B2   0x2300             MOVS     R3,#+0
   \   000000B4   0x.... 0x....      BL       FS__fat_FAT_find_eof
   \   000000B8   0x4602             MOV      R2,R0
    285              }
    286              if (last < 0) {
   \                     ??FS__fat_fwrite_9: (+1)
   \   000000BA   0x2A00             CMP      R2,#+0
   \   000000BC   0xD409             BMI.N    ??FS__fat_fwrite_4
    287                /* No EOF found */
    288                FS__fat_free(buffer);
    289                return 0;
    290              }
    291              while (i) {
    292                last = FS__fat_FAT_alloc(pFile->dev_index, pFile->fileid_lo, last);  /* Allocate new cluster */
   \                     ??FS__fat_fwrite_10: (+1)
   \   000000BE   0x6821             LDR      R1,[R4, #+0]
   \   000000C0   0x69E0             LDR      R0,[R4, #+28]
   \   000000C2   0x.... 0x....      BL       FS__fat_FAT_alloc
   \   000000C6   0x0002             MOVS     R2,R0
    293                pFile->EOFClust = last;
   \   000000C8   0x60E2             STR      R2,[R4, #+12]
    294                if (last < 0) {
   \   000000CA   0xD507             BPL.N    ??FS__fat_fwrite_11
    295                  /* Cluster allocation failed */
    296                  pFile->size += (N * Size - todo);
    297                  pFile->error = FS_ERR_DISKFULL;
   \   000000CC   0xF06F 0x001F      MVN      R0,#+31
   \   000000D0   0x8420             STRH     R0,[R4, #+32]
    298                  FS__fat_free(buffer);
   \                     ??FS__fat_fwrite_4: (+1)
   \   000000D2   0x4648             MOV      R0,R9
   \   000000D4   0x.... 0x....      BL       FS__fat_free
    299                  return ((N * Size - todo) / Size);
   \                     ??FS__fat_fwrite_0: (+1)
   \   000000D8   0x2000             MOVS     R0,#+0
    300                }
   \   000000DA   0x....             B.N      ?Subroutine0
    301                i--;
   \                     ??FS__fat_fwrite_11: (+1)
   \   000000DC   0xF1BA 0x0A01      SUBS     R10,R10,#+1
    302              }
   \   000000E0   0xD1ED             BNE.N    ??FS__fat_fwrite_10
   \                     ??FS__fat_fwrite_8: (+1)
   \   000000E2   0x69E0             LDR      R0,[R4, #+28]
   \   000000E4   0x6821             LDR      R1,[R4, #+0]
   \   000000E6   0x9B02             LDR      R3,[SP, #+8]
   \   000000E8   0xEB0B 0x1040      ADD      R0,R11,R0, LSL #+5
   \   000000EC   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   000000F0   0x8B41             LDRH     R1,[R0, #+26]
   \   000000F2   0x7F42             LDRB     R2,[R0, #+29]
   \   000000F4   0x89C0             LDRH     R0,[R0, #+14]
   \   000000F6   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   000000FA   0x0140             LSLS     R0,R0,#+5
   \   000000FC   0xEB01 0x2050      ADD      R0,R1,R0, LSR #+9
   \   00000100   0x9003             STR      R0,[SP, #+12]
    303            }
    304            /* Get absolute postion of data area on the media */
    305            dstart    = (FS_u32)FS__FAT_aBPBUnit[pFile->dev_index][pFile->fileid_lo].RsvdSecCnt + 
    306                        FS__FAT_aBPBUnit[pFile->dev_index][pFile->fileid_lo].NumFATs * fatsize;
    307            dsize     = ((FS_u32)((FS_u32)FS__FAT_aBPBUnit[pFile->dev_index][pFile->fileid_lo].RootEntCnt) * FS_FAT_DENTRY_SIZE) / FS_FAT_SEC_SIZE;
    308            datastart = dstart + dsize;
    309            /* Write data to clusters */
    310            prevclust = 0;
   \   00000102   0x2000             MOVS     R0,#+0
   \   00000104   0x9001             STR      R0,[SP, #+4]
   \   00000106   0x9804             LDR      R0,[SP, #+16]
   \   00000108   0x1980             ADDS     R0,R0,R6
   \   0000010A   0x9002             STR      R0,[SP, #+8]
    311            while (todo) {  /* Write data loop */
    312              /* Translate file ppinter position to cluster position*/
    313              fileclustnum = pFile->filepos / bytesperclus;
   \                     ??FS__fat_fwrite_12: (+1)
   \   0000010C   0x6960             LDR      R0,[R4, #+20]
   \   0000010E   0x9900             LDR      R1,[SP, #+0]
   \   00000110   0xFBB0 0xF3F1      UDIV     R3,R0,R1
    314              /* 
    315                 Translate the file relative cluster position to an absolute cluster
    316                 position on the media. To avoid scanning the whole FAT of the file,
    317                 we remember the current cluster position in the FS_FILE data structure.
    318              */
    319              if (prevclust == 0) {
   \   00000114   0x9801             LDR      R0,[SP, #+4]
   \   00000116   0xB918             CBNZ.N   R0,??FS__fat_fwrite_13
    320                diskclustnum = pFile->CurClust;
   \   00000118   0x6926             LDR      R6,[R4, #+16]
    321                if (diskclustnum == 0) {
   \   0000011A   0xB946             CBNZ.N   R6,??FS__fat_fwrite_14
    322                  /* No known current cluster position, we have to scan from the file's start cluster */
    323                  diskclustnum = FS__fat_diskclust(pFile->dev_index, pFile->fileid_lo, pFile->fileid_hi, fileclustnum);
   \   0000011C   0x6862             LDR      R2,[R4, #+4]
   \   0000011E   0xE001             B.N      ??FS__fat_fwrite_15
    324                }
    325              } 
    326              else {
    327                /* Get next cluster of the file starting at the current cluster */
    328                diskclustnum = FS__fat_diskclust(pFile->dev_index, pFile->fileid_lo, prevclust, 1);
   \                     ??FS__fat_fwrite_13: (+1)
   \   00000120   0x2301             MOVS     R3,#+1
   \   00000122   0x4602             MOV      R2,R0
   \                     ??FS__fat_fwrite_15: (+1)
   \   00000124   0x6821             LDR      R1,[R4, #+0]
   \   00000126   0x69E0             LDR      R0,[R4, #+28]
   \   00000128   0x.... 0x....      BL       FS__fat_diskclust
   \   0000012C   0x4606             MOV      R6,R0
    329              }
    330              prevclust        = diskclustnum;
   \                     ??FS__fat_fwrite_14: (+1)
   \   0000012E   0x9601             STR      R6,[SP, #+4]
    331              pFile->CurClust  = diskclustnum;
   \   00000130   0x6126             STR      R6,[R4, #+16]
    332              if (diskclustnum == 0) {
   \   00000132   0xB35E             CBZ.N    R6,??FS__fat_fwrite_16
    333                /* Translation to absolute cluster failed */
    334                pFile->error = FS_ERR_WRITEERROR;
    335                FS__fat_free(buffer);
    336                return ((N * Size - todo) / Size);
    337              }
    338              diskclustnum -= 2;
    339              j = (pFile->filepos % bytesperclus) / FS_FAT_SEC_SIZE;
   \   00000134   0x6960             LDR      R0,[R4, #+20]
   \   00000136   0x9900             LDR      R1,[SP, #+0]
   \   00000138   0x9A00             LDR      R2,[SP, #+0]
   \   0000013A   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   0000013E   0xFB02 0x0011      MLS      R0,R2,R1,R0
   \   00000142   0x1EB6             SUBS     R6,R6,#+2
   \   00000144   0x0A45             LSRS     R5,R0,#+9
    340              while (1) {  /* Cluster loop */
    341                if (!todo) {
    342                  break;  /* Nothing more to write */
    343                }
    344                if (j >= FS__FAT_aBPBUnit[pFile->dev_index][pFile->fileid_lo].SecPerClus) {
   \                     ??FS__fat_fwrite_17: (+1)
   \   00000146   0x69E0             LDR      R0,[R4, #+28]
   \   00000148   0x6821             LDR      R1,[R4, #+0]
   \   0000014A   0xEB0B 0x1240      ADD      R2,R11,R0, LSL #+5
   \   0000014E   0xEB02 0x1241      ADD      R2,R2,R1, LSL #+5
   \   00000152   0x7F12             LDRB     R2,[R2, #+28]
   \   00000154   0x4295             CMP      R5,R2
   \   00000156   0xDAD9             BGE.N    ??FS__fat_fwrite_12
    345                  break; /* End of cluster reached */
    346                }
    347                i = pFile->filepos % FS_FAT_SEC_SIZE;
   \   00000158   0x6963             LDR      R3,[R4, #+20]
   \   0000015A   0xEA4F 0x2C23      ASR      R12,R3,#+8
   \   0000015E   0xEB03 0x5CDC      ADD      R12,R3,R12, LSR #+23
   \   00000162   0xEA4F 0x2C6C      ASR      R12,R12,#+9
   \   00000166   0xEBB3 0x2A4C      SUBS     R10,R3,R12, LSL #+9
    348                /* 
    349                   We only have to read the sector from the media, if we do not
    350                   modify the whole sector. That is the case if
    351          
    352                   a) Writing starts not at the first byte of the sector
    353                   b) Less data than the sector contains is written
    354                */
    355                lexp = (i != 0);
   \   0000016A   0xD102             BNE.N    ??FS__fat_fwrite_18
    356                lexp = lexp || (todo < FS_FAT_SEC_SIZE);
   \   0000016C   0xF5B7 0x7F00      CMP      R7,#+512
   \   00000170   0xD228             BCS.N    ??FS__fat_fwrite_19
    357                if (lexp) {
    358                  /* We have to read the old sector */
    359                  err = FS__lb_read(FS__pDevInfo[pFile->dev_index].devdriver, pFile->fileid_lo,
    360                                datastart +
    361                                diskclustnum * FS__FAT_aBPBUnit[pFile->dev_index][pFile->fileid_lo].SecPerClus + j,
    362                                (void*)buffer);
    363                  if (err < 0) {
   \                     ??FS__fat_fwrite_18: (+1)
   \   00000172   0xF8DD 0xC00C      LDR      R12,[SP, #+12]
   \   00000176   0xEB08 0x1000      ADD      R0,R8,R0, LSL #+4
   \   0000017A   0xFB02 0xC206      MLA      R2,R2,R6,R12
   \   0000017E   0x6880             LDR      R0,[R0, #+8]
   \   00000180   0x464B             MOV      R3,R9
   \   00000182   0x18AA             ADDS     R2,R5,R2
   \   00000184   0x.... 0x....      BL       FS__lb_read
   \   00000188   0x2800             CMP      R0,#+0
   \   0000018A   0xD508             BPL.N    ??FS__fat_fwrite_20
    364                    pFile->error = FS_ERR_WRITEERROR;
    365                    FS__fat_free(buffer);
    366                    return ((N * Size - todo) / Size);
    367                  }
    368                }
    369                while (1) {  /* Sector loop */
    370                  if (!todo) {
    371                    break;  /* Nothing more to write */
    372                  }
    373                  if (i >= FS_FAT_SEC_SIZE) {
    374                    break;  /* End of sector reached */
    375                  }
    376                  buffer[i] = *((FS_FARCHARPTR)(((FS_FARCHARPTR)pData) + N * Size - todo));
    377                  i++;
    378                  pFile->filepos++;
    379                  if (pFile->filepos > pFile->size) {
    380                    pFile->size = pFile->filepos;
    381                  }
    382                  todo--;
    383                }  /* Sector loop */
    384                /* Write the modified sector */
    385                err = FS__lb_write(FS__pDevInfo[pFile->dev_index].devdriver, pFile->fileid_lo,
    386                              datastart +
    387                              diskclustnum * FS__FAT_aBPBUnit[pFile->dev_index][pFile->fileid_lo].SecPerClus + j,
    388                              (void*)buffer);
    389                if (err < 0) {
    390                  pFile->error = FS_ERR_WRITEERROR;
    391                  FS__fat_free(buffer);
    392                  return ((N * Size - todo) / Size);
    393                }
    394                j++;
    395              }  /* Cluster loop */
    396            } /* Write data loop */
    397            if (i >= FS_FAT_SEC_SIZE) {
    398              if (j >= FS__FAT_aBPBUnit[pFile->dev_index][pFile->fileid_lo].SecPerClus) {
    399                /* File pointer is already in the next cluster */
    400                pFile->CurClust = FS__fat_diskclust(pFile->dev_index, pFile->fileid_lo, prevclust, 1);
    401              }
    402            }
    403          #if (FS_FAT_FWRITE_UPDATE_DIR)
    404            /* Modify directory entry */
    405            err = _FS_fat_read_dentry(pFile->dev_index, pFile->fileid_lo, pFile->fileid_hi, pFile->fileid_ex, &s, &dsec, buffer);
    406            if (err == 0) {
    407              pFile->error = FS_ERR_WRITEERROR;
   \                     ??FS__fat_fwrite_16: (+1)
   \   0000018C   0xF06F 0x006F      MVN      R0,#+111
   \   00000190   0x8420             STRH     R0,[R4, #+32]
    408              FS__fat_free(buffer);
   \   00000192   0x4648             MOV      R0,R9
   \   00000194   0x.... 0x....      BL       FS__fat_free
    409              return ((N * Size - todo) / Size);
   \   00000198   0x9804             LDR      R0,[SP, #+16]
   \   0000019A   0x1BC0             SUBS     R0,R0,R7
   \   0000019C   0xE0C8             B.N      ??FS__fat_fwrite_21
    410            }
   \                     ??FS__fat_fwrite_20: (+1)
   \   0000019E   0xF5BA 0x7F00      CMP      R10,#+512
   \   000001A2   0xDA11             BGE.N    ??FS__fat_fwrite_22
   \   000001A4   0x9802             LDR      R0,[SP, #+8]
   \   000001A6   0x1BC0             SUBS     R0,R0,R7
   \   000001A8   0x7800             LDRB     R0,[R0, #+0]
   \   000001AA   0xF80A 0x0009      STRB     R0,[R10, R9]
   \   000001AE   0xF10A 0x0A01      ADD      R10,R10,#+1
   \   000001B2   0x6960             LDR      R0,[R4, #+20]
   \   000001B4   0x69A1             LDR      R1,[R4, #+24]
   \   000001B6   0x1C40             ADDS     R0,R0,#+1
   \   000001B8   0x6160             STR      R0,[R4, #+20]
   \   000001BA   0x4281             CMP      R1,R0
   \   000001BC   0xBFB8             IT       LT 
   \   000001BE   0x4601             MOVLT    R1,R0
   \   000001C0   0x61A1             STR      R1,[R4, #+24]
   \   000001C2   0x1E7F             SUBS     R7,R7,#+1
   \                     ??FS__fat_fwrite_19: (+1)
   \   000001C4   0x2F00             CMP      R7,#+0
   \   000001C6   0xD1EA             BNE.N    ??FS__fat_fwrite_20
   \                     ??FS__fat_fwrite_22: (+1)
   \   000001C8   0x69E0             LDR      R0,[R4, #+28]
   \   000001CA   0x6821             LDR      R1,[R4, #+0]
   \   000001CC   0x9A03             LDR      R2,[SP, #+12]
   \   000001CE   0xEB0B 0x1C40      ADD      R12,R11,R0, LSL #+5
   \   000001D2   0xEB0C 0x1C41      ADD      R12,R12,R1, LSL #+5
   \   000001D6   0xEB08 0x1000      ADD      R0,R8,R0, LSL #+4
   \   000001DA   0xF89C 0xC01C      LDRB     R12,[R12, #+28]
   \   000001DE   0x6880             LDR      R0,[R0, #+8]
   \   000001E0   0xFB0C 0x2206      MLA      R2,R12,R6,R2
   \   000001E4   0x464B             MOV      R3,R9
   \   000001E6   0x18AA             ADDS     R2,R5,R2
   \   000001E8   0x.... 0x....      BL       FS__lb_write
   \   000001EC   0x2800             CMP      R0,#+0
   \   000001EE   0xD4CD             BMI.N    ??FS__fat_fwrite_16
   \   000001F0   0x1C6D             ADDS     R5,R5,#+1
   \   000001F2   0x2F00             CMP      R7,#+0
   \   000001F4   0xD1A7             BNE.N    ??FS__fat_fwrite_17
   \   000001F6   0xF5BA 0x7F00      CMP      R10,#+512
   \   000001FA   0xDB0D             BLT.N    ??FS__fat_fwrite_23
   \   000001FC   0x69E0             LDR      R0,[R4, #+28]
   \   000001FE   0x6821             LDR      R1,[R4, #+0]
   \   00000200   0xEB0B 0x1240      ADD      R2,R11,R0, LSL #+5
   \   00000204   0xEB02 0x1241      ADD      R2,R2,R1, LSL #+5
   \   00000208   0x7F12             LDRB     R2,[R2, #+28]
   \   0000020A   0x4295             CMP      R5,R2
   \   0000020C   0xDB04             BLT.N    ??FS__fat_fwrite_23
   \   0000020E   0x9A01             LDR      R2,[SP, #+4]
   \   00000210   0x2301             MOVS     R3,#+1
   \   00000212   0x.... 0x....      BL       FS__fat_diskclust
   \   00000216   0x6120             STR      R0,[R4, #+16]
   \                     ??FS__fat_fwrite_23: (+1)
   \   00000218   0x2500             MOVS     R5,#+0
   \   0000021A   0x68A0             LDR      R0,[R4, #+8]
   \   0000021C   0x9000             STR      R0,[SP, #+0]
   \   0000021E   0x6860             LDR      R0,[R4, #+4]
   \   00000220   0x9A00             LDR      R2,[SP, #+0]
   \   00000222   0x9002             STR      R0,[SP, #+8]
   \   00000224   0xF8D4 0xB000      LDR      R11,[R4, #+0]
   \   00000228   0x69E0             LDR      R0,[R4, #+28]
   \   0000022A   0x9001             STR      R0,[SP, #+4]
   \   0000022C   0x4659             MOV      R1,R11
   \   0000022E   0x.... 0x....      BL       FS__fat_dir_size
   \   00000232   0x2800             CMP      R0,#+0
   \   00000234   0x9003             STR      R0,[SP, #+12]
   \   00000236   0xD0A9             BEQ.N    ??FS__fat_fwrite_16
   \   00000238   0xF509 0x7600      ADD      R6,R9,#+512
   \                     ??FS__fat_fwrite_24: (+1)
   \   0000023C   0x9A00             LDR      R2,[SP, #+0]
   \   0000023E   0x9801             LDR      R0,[SP, #+4]
   \   00000240   0x462B             MOV      R3,R5
   \   00000242   0x4659             MOV      R1,R11
   \   00000244   0x.... 0x....      BL       FS__fat_dir_realsec
   \   00000248   0xEA5F 0x0A00      MOVS     R10,R0
   \   0000024C   0xD09E             BEQ.N    ??FS__fat_fwrite_16
   \   0000024E   0x9801             LDR      R0,[SP, #+4]
   \   00000250   0xEB08 0x1000      ADD      R0,R8,R0, LSL #+4
   \   00000254   0x464B             MOV      R3,R9
   \   00000256   0x6880             LDR      R0,[R0, #+8]
   \   00000258   0x4652             MOV      R2,R10
   \   0000025A   0x4659             MOV      R1,R11
   \   0000025C   0x.... 0x....      BL       FS__lb_read
   \   00000260   0x2800             CMP      R0,#+0
   \   00000262   0xD493             BMI.N    ??FS__fat_fwrite_16
   \   00000264   0x4649             MOV      R1,R9
   \   00000266   0xE000             B.N      ??FS__fat_fwrite_25
   \                     ??FS__fat_fwrite_26: (+1)
   \   00000268   0x3120             ADDS     R1,R1,#+32
   \                     ??FS__fat_fwrite_25: (+1)
   \   0000026A   0x42B1             CMP      R1,R6
   \   0000026C   0xD20C             BCS.N    ??FS__fat_fwrite_27
   \   0000026E   0x7E8A             LDRB     R2,[R1, #+26]
   \   00000270   0x7ECB             LDRB     R3,[R1, #+27]
   \   00000272   0xEB02 0x2203      ADD      R2,R2,R3, LSL #+8
   \   00000276   0x7D0B             LDRB     R3,[R1, #+20]
   \   00000278   0xEB02 0x4203      ADD      R2,R2,R3, LSL #+16
   \   0000027C   0x7D4B             LDRB     R3,[R1, #+21]
   \   0000027E   0xEB02 0x6203      ADD      R2,R2,R3, LSL #+24
   \   00000282   0x9B02             LDR      R3,[SP, #+8]
   \   00000284   0x429A             CMP      R2,R3
   \   00000286   0xD1EF             BNE.N    ??FS__fat_fwrite_26
   \                     ??FS__fat_fwrite_27: (+1)
   \   00000288   0x42B1             CMP      R1,R6
   \   0000028A   0xD305             BCC.N    ??FS__fat_fwrite_28
   \   0000028C   0x9803             LDR      R0,[SP, #+12]
   \   0000028E   0x1C6D             ADDS     R5,R5,#+1
   \   00000290   0x4285             CMP      R5,R0
   \   00000292   0xF4BF 0xAF7B      BCS.W    ??FS__fat_fwrite_16
   \   00000296   0xE7D1             B.N      ??FS__fat_fwrite_24
   \                     ??FS__fat_fwrite_28: (+1)
   \   00000298   0x2220             MOVS     R2,#+32
   \   0000029A   0xA805             ADD      R0,SP,#+20
   \   0000029C   0x.... 0x....      BL       FS__CLIB_memcpy
    411            s.data[28] = (unsigned char)(pFile->size & 0xff);   /* FileSize */
   \   000002A0   0x69A0             LDR      R0,[R4, #+24]
   \   000002A2   0xF88D 0x0030      STRB     R0,[SP, #+48]
    412            s.data[29] = (unsigned char)((pFile->size / 0x100UL) & 0xff);   
   \   000002A6   0x69A0             LDR      R0,[R4, #+24]
   \   000002A8   0x0A00             LSRS     R0,R0,#+8
   \   000002AA   0xF88D 0x0031      STRB     R0,[SP, #+49]
    413            s.data[30] = (unsigned char)((pFile->size / 0x10000UL) & 0xff);
   \   000002AE   0x69A0             LDR      R0,[R4, #+24]
   \   000002B0   0x0C00             LSRS     R0,R0,#+16
   \   000002B2   0xF88D 0x0032      STRB     R0,[SP, #+50]
    414            s.data[31] = (unsigned char)((pFile->size / 0x1000000UL) & 0xff);
   \   000002B6   0x69A0             LDR      R0,[R4, #+24]
   \   000002B8   0x0E00             LSRS     R0,R0,#+24
   \   000002BA   0xF88D 0x0033      STRB     R0,[SP, #+51]
    415            val = FS_X_OS_GetTime();
   \   000002BE   0x.... 0x....      BL       FS_X_OS_GetTime
    416            s.data[22] = (unsigned char)(val & 0xff);
   \   000002C2   0xF88D 0x002A      STRB     R0,[SP, #+42]
    417            s.data[23] = (unsigned char)((val / 0x100) & 0xff);
   \   000002C6   0x0A00             LSRS     R0,R0,#+8
   \   000002C8   0xF88D 0x002B      STRB     R0,[SP, #+43]
    418            val = FS_X_OS_GetDate();
   \   000002CC   0x.... 0x....      BL       FS_X_OS_GetDate
    419            s.data[24] = (unsigned char)(val & 0xff);
   \   000002D0   0xF88D 0x002C      STRB     R0,[SP, #+44]
    420            s.data[25] = (unsigned char)((val / 0x100) & 0xff);
   \   000002D4   0x0A00             LSRS     R0,R0,#+8
   \   000002D6   0xF88D 0x002D      STRB     R0,[SP, #+45]
    421            err = _FS_fat_write_dentry(pFile->dev_index, pFile->fileid_lo, pFile->fileid_hi, &s, dsec, buffer);
   \   000002DA   0x6861             LDR      R1,[R4, #+4]
   \   000002DC   0x6827             LDR      R7,[R4, #+0]
   \   000002DE   0x69E5             LDR      R5,[R4, #+28]
   \   000002E0   0x4648             MOV      R0,R9
   \   000002E2   0xE000             B.N      ??FS__fat_fwrite_29
   \                     ??FS__fat_fwrite_30: (+1)
   \   000002E4   0x3020             ADDS     R0,R0,#+32
   \                     ??FS__fat_fwrite_29: (+1)
   \   000002E6   0x42B0             CMP      R0,R6
   \   000002E8   0xD20B             BCS.N    ??FS__fat_fwrite_31
   \   000002EA   0x7E83             LDRB     R3,[R0, #+26]
   \   000002EC   0x7EC2             LDRB     R2,[R0, #+27]
   \   000002EE   0xEB03 0x2302      ADD      R3,R3,R2, LSL #+8
   \   000002F2   0x7D02             LDRB     R2,[R0, #+20]
   \   000002F4   0xEB03 0x4302      ADD      R3,R3,R2, LSL #+16
   \   000002F8   0x7D42             LDRB     R2,[R0, #+21]
   \   000002FA   0xEB03 0x6302      ADD      R3,R3,R2, LSL #+24
   \   000002FE   0x428B             CMP      R3,R1
   \   00000300   0xD1F0             BNE.N    ??FS__fat_fwrite_30
   \                     ??FS__fat_fwrite_31: (+1)
   \   00000302   0x42B0             CMP      R0,R6
   \   00000304   0xD20D             BCS.N    ??FS__fat_fwrite_32
   \   00000306   0x2220             MOVS     R2,#+32
   \   00000308   0xA905             ADD      R1,SP,#+20
   \   0000030A   0x.... 0x....      BL       FS__CLIB_memcpy
   \   0000030E   0xEB08 0x1005      ADD      R0,R8,R5, LSL #+4
   \   00000312   0x464B             MOV      R3,R9
   \   00000314   0x6880             LDR      R0,[R0, #+8]
   \   00000316   0x4652             MOV      R2,R10
   \   00000318   0x4639             MOV      R1,R7
   \   0000031A   0x.... 0x....      BL       FS__lb_write
   \   0000031E   0x2800             CMP      R0,#+0
   \   00000320   0xD502             BPL.N    ??FS__fat_fwrite_33
    422            if (err == 0) {
    423              pFile->error = FS_ERR_WRITEERROR;
   \                     ??FS__fat_fwrite_32: (+1)
   \   00000322   0xF06F 0x006F      MVN      R0,#+111
   \   00000326   0x8420             STRH     R0,[R4, #+32]
    424            }
    425          #endif /* FS_FAT_FWRITE_UPDATE_DIR */
    426            FS__fat_free(buffer);
   \                     ??FS__fat_fwrite_33: (+1)
   \   00000328   0x4648             MOV      R0,R9
   \   0000032A   0x.... 0x....      BL       FS__fat_free
    427            return ((N * Size - todo) / Size);
   \   0000032E   0x9804             LDR      R0,[SP, #+16]
   \                     ??FS__fat_fwrite_21: (+1)
   \   00000330   0x990E             LDR      R1,[SP, #+56]
   \   00000332   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000336                      REQUIRE ?Subroutine0
   \   00000336                      ;; // Fall through to label ?Subroutine0
    428          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xB00F             ADD      SP,SP,#+60
   \   00000002   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    429          
    430          
    431          /*********************************************************************
    432          *
    433          *             FS__fat_fclose
    434          *
    435            Description:
    436            FS internal function. Close a file referred by pFile.
    437          
    438            Parameters:
    439            pFile       - Pointer to a FS_FILE data structure. 
    440            
    441            Return value:
    442            None.
    443          */
    444          

   \                                 In section .text, align 2, keep-with-next
    445          void FS__fat_fclose(FS_FILE *pFile) {
   \                     FS__fat_fclose: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xB082             SUB      SP,SP,#+8
    446          #if (FS_FAT_FWRITE_UPDATE_DIR==0)
    447            FS__fat_dentry_type s;
    448            char *buffer;
    449            FS_u32 dsec;
    450            FS_u16 val;
    451          #endif /* FS_FAT_FWRITE_UPDATE_DIR */
    452            int err;
    453          
    454            if (!pFile) {
   \   00000006   0xD03D             BEQ.N    ??FS__fat_fclose_0
    455                return;
    456            }
    457            /* Check if media is OK */
    458            err = FS__lb_status(FS__pDevInfo[pFile->dev_index].devdriver, pFile->fileid_lo);
   \   00000008   0x....             LDR.N    R0,??DataTable0
   \   0000000A   0x6805             LDR      R5,[R0, #+0]
   \   0000000C   0x69E0             LDR      R0,[R4, #+28]
   \   0000000E   0x6821             LDR      R1,[R4, #+0]
   \   00000010   0xEB05 0x1000      ADD      R0,R5,R0, LSL #+4
   \   00000014   0x6880             LDR      R0,[R0, #+8]
   \   00000016   0x.... 0x....      BL       FS__lb_status
    459            if (err == FS_LBL_MEDIACHANGED) {
   \   0000001A   0x69E1             LDR      R1,[R4, #+28]
   \   0000001C   0xEB05 0x1601      ADD      R6,R5,R1, LSL #+4
   \   00000020   0x6821             LDR      R1,[R4, #+0]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xBF08             IT       EQ 
   \   00000026   0xF06F 0x007F      MVNEQ    R0,#+127
    460              pFile->error = FS_ERR_DISKCHANGED;
   \   0000002A   0xD003             BEQ.N    ??FS__fat_fclose_1
    461              FS__lb_ioctl(FS__pDevInfo[pFile->dev_index].devdriver, pFile->fileid_lo, FS_CMD_DEC_BUSYCNT, 0, (void*)0);  /* Turn off busy signal */
    462              pFile->inuse = 0;
    463              return;
    464            }
    465            else if (err < 0) {
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD50E             BPL.N    ??FS__fat_fclose_2
    466              pFile->error = FS_ERR_CLOSE;
   \   00000030   0xF06F 0x008F      MVN      R0,#+143
   \                     ??FS__fat_fclose_1: (+1)
   \   00000034   0x8420             STRH     R0,[R4, #+32]
    467              FS__lb_ioctl(FS__pDevInfo[pFile->dev_index].devdriver, pFile->fileid_lo, FS_CMD_DEC_BUSYCNT, 0, (void*)0);  /* Turn off busy signal */
   \   00000036   0x2300             MOVS     R3,#+0
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x9000             STR      R0,[SP, #+0]
   \   0000003C   0xF640 0x32BA      MOVW     R2,#+3002
   \   00000040   0x68B0             LDR      R0,[R6, #+8]
   \   00000042   0x.... 0x....      BL       FS__lb_ioctl
    468              pFile->inuse = 0;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xF884 0x0022      STRB     R0,[R4, #+34]
    469              return;
   \   0000004C   0xBD73             POP      {R0,R1,R4-R6,PC}
    470            }
    471          #if (FS_FAT_FWRITE_UPDATE_DIR==0)
    472            /* Modify directory entry */
    473            buffer = FS__fat_malloc(FS_FAT_SEC_SIZE);
    474            if (!buffer) {
    475              pFile->inuse = 0;
    476              pFile->error = FS_ERR_CLOSE;
    477              return;
    478            }
    479            err = _FS_fat_read_dentry(pFile->dev_index, pFile->fileid_lo, pFile->fileid_hi, pFile->fileid_ex, &s, &dsec, buffer);
    480            if (err == 0) {
    481              pFile->inuse = 0;
    482              pFile->error = FS_ERR_CLOSE;
    483              FS__fat_free(buffer);
    484              return;
    485            }
    486            s.data[28] = (unsigned char)(pFile->size & 0xff);   /* FileSize */
    487            s.data[29] = (unsigned char)((pFile->size / 0x100UL) & 0xff);   
    488            s.data[30] = (unsigned char)((pFile->size / 0x10000UL) & 0xff);
    489            s.data[31] = (unsigned char)((pFile->size / 0x1000000UL) & 0xff);
    490            val = FS_X_OS_GetTime();
    491            s.data[22] = (unsigned char)(val & 0xff);
    492            s.data[23] = (unsigned char)((val / 0x100) & 0xff);
    493            val = FS_X_OS_GetDate();
    494            s.data[24] = (unsigned char)(val & 0xff);
    495            s.data[25] = (unsigned char)((val / 0x100) & 0xff);
    496            err = _FS_fat_write_dentry(pFile->dev_index, pFile->fileid_lo, pFile->fileid_hi, &s, dsec, buffer);
    497            if (err == 0) {
    498              pFile->error = FS_ERR_CLOSE;
    499            }
    500            FS__fat_free(buffer);
    501          #endif /* FS_FAT_FWRITE_UPDATE_DIR */
    502            err = FS__lb_ioctl(FS__pDevInfo[pFile->dev_index].devdriver, pFile->fileid_lo, FS_CMD_FLUSH_CACHE, 2, (void*)0);
    503            if (err < 0) {
   \                     ??FS__fat_fclose_2: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x9000             STR      R0,[SP, #+0]
   \   00000052   0x2302             MOVS     R3,#+2
   \   00000054   0x68B0             LDR      R0,[R6, #+8]
   \   00000056   0xF44F 0x727A      MOV      R2,#+1000
   \   0000005A   0x.... 0x....      BL       FS__lb_ioctl
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xBF44             ITT      MI 
   \   00000062   0xF06F 0x006F      MVNMI    R0,#+111
   \   00000066   0x8420             STRHMI   R0,[R4, #+32]
    504              pFile->error = FS_ERR_WRITEERROR;
    505            }
    506            pFile->inuse = 0;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xF884 0x0022      STRB     R0,[R4, #+34]
    507            FS__lb_ioctl(FS__pDevInfo[pFile->dev_index].devdriver, pFile->fileid_lo, FS_CMD_DEC_BUSYCNT, 0, (void*)0);  /* Turn off busy signal */
   \   0000006E   0x9000             STR      R0,[SP, #+0]
   \   00000070   0x2300             MOVS     R3,#+0
   \   00000072   0x69E0             LDR      R0,[R4, #+28]
   \   00000074   0x6821             LDR      R1,[R4, #+0]
   \   00000076   0xEB05 0x1000      ADD      R0,R5,R0, LSL #+4
   \   0000007A   0xF640 0x32BA      MOVW     R2,#+3002
   \   0000007E   0x6880             LDR      R0,[R0, #+8]
   \   00000080   0x.... 0x....      BL       FS__lb_ioctl
    508          }
   \                     ??FS__fat_fclose_0: (+1)
   \   00000084   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x........         DC32     FS__pDevInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x........         DC32     FS__FAT_aBPBUnit
    509          
    510          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   FS__fat_fclose
        24   -> FS__lb_ioctl
        24   -> FS__lb_status
      96   FS__fat_fwrite
        96   -> FS_X_OS_GetDate
        96   -> FS_X_OS_GetTime
        96   -> FS__CLIB_memcpy
        96   -> FS__fat_FAT_alloc
        96   -> FS__fat_FAT_find_eof
        96   -> FS__fat_dir_realsec
        96   -> FS__fat_dir_size
        96   -> FS__fat_diskclust
        96   -> FS__fat_free
        96   -> FS__fat_malloc
        96   -> FS__lb_read
        96   -> FS__lb_status
        96   -> FS__lb_write


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       6  ?Subroutine0
     134  FS__fat_fclose
     822  FS__fat_fwrite

 
 970 bytes in section .text
 
 970 bytes of CODE memory

Errors: none
Warnings: none
